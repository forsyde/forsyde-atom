<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ForSyDe.Atom.Skel</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">forsyde-atom-0.3.0.0: Shallow-embedded DSL for modeling cyber-physical systems </span><ul class="links" id="page-menu"><li><a href="src/ForSyDe.Atom.Skel.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li><li><a href="https://forsyde.github.io/forsyde-atom/">Back to ForSyDe Web</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu KTH/ICT/ESY 2015</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr><tr><th>Extensions</th><td>PostfixOperators</td></tr></table><p class="caption">ForSyDe.Atom.Skel</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Atoms</a></li><li><a href="#g:2">Skeleton constructors</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines the Skeleton layer, and is concerned in modeling the aspects of
 inherent potential for parallelism in CPS. Its formal foundation is the theory of
 algorithmic skeletons <a href="ForSyDe-Atom.html#skillicorn05">[Skillicorn05]</a>, and it
 adapts it according to the atom approach. For more on our approach, and how it fits
 into the layered framework, please consult
 <a href="ForSyDe-Atom.html#ungureanu20a">[Ungureanu20a]</a></p><p>This library is concerned in modeling the theoretical aspects as faithfully as
 possible using a shallow DSL, and not necessarily reaping the benefits of
 parallelization directly in simulations. The latter would require further
 engineering and the modeling concepts are likely to be lost the process. Instead
 most of the atom and pattern formulations in this module and sub-modules might not
 be the most efficient implementations for the given functionality, but rather
 expose the fundamental properties which can be further exploited in design
 processes. Of these properties our special interest lies in the <em>factorization</em>
 theorem (see <a href="ForSyDe-Atom.html#skillicorn05">[Skillicorn05]</a>,
 <a href="ForSyDe-Atom.html#gorlatch03">[Gorlatch03]</a>), which sets the framework for any
 skeleton to be further transformed into semantically-equivalent forms, more
 appropriate for execution on various platforms.</p><p>Similar to other layer libraries, this module defines only atoms and patterns as
 type class methods, i.e. &quot;shells&quot; which are not loaded with any semantics. It is
 unlikely that the user will need this API, but rather load any of its sub-modules
 directly:</p><ul><li><a href="ForSyDe-Atom-Skel-Vector.html">ForSyDe.Atom.Skel.Vector</a> is a shallow interpretation of the <em>vector</em>
   category, susceptible to algorithmic skeletons. It defines a large library of
   patterns commonly used in designs.</li><li><a href="ForSyDe-Atom-Skel-FastVector.html">ForSyDe.Atom.Skel.FastVector</a> is an un-official alternative to
   <a href="ForSyDe-Atom-Skel-Vector.html">ForSyDe.Atom.Skel.Vector</a> meant for simulations of large data which is
   likely to become too cumbersome. It <em>does not</em> use atoms, but rather it wraps
   native Haskell types into <code>newtype</code> wrappers and uses <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html">Prelude</a> functions
   internally. The API tries to copy that of <a href="ForSyDe-Atom-Skel-Vector.html">ForSyDe.Atom.Skel.Vector</a> so that
   switching betwen libraries can be made seamlessly just by changing the import.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> c =&gt; <a href="#t:Skeleton">Skeleton</a> c <span class="keyword">where</span><ul class="subs"><li><a href="#v:-61-.-61-">(=.=)</a> :: (a -&gt; b) -&gt; c a -&gt; c b</li><li><a href="#v:-61--42--61-">(=*=)</a> :: c (a -&gt; b) -&gt; c a -&gt; c b</li><li><a href="#v:-61--92--61-">(=\=)</a> :: (a -&gt; a -&gt; a) -&gt; c a -&gt; a</li><li><a href="#v:-61--60--60--61-">(=&lt;&lt;=)</a> :: c (a -&gt; a) -&gt; a -&gt; a</li><li><a href="#v:first">first</a> :: c a -&gt; a</li><li><a href="#v:last">last</a> :: c a -&gt; a</li></ul></li><li class="src short"><a href="#v:farm22">farm22</a> :: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; c a1 -&gt; c a2 -&gt; (c b1, c b2)</li><li class="src short"><a href="#v:reduce">reduce</a> :: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c =&gt; (a -&gt; a -&gt; a) -&gt; c a -&gt; a</li><li class="src short"><a href="#v:reducei">reducei</a> :: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c =&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; c a -&gt; a</li><li class="src short"><a href="#v:pipe">pipe</a> :: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c =&gt; c (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:pipe2">pipe2</a> :: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; a -&gt; a) -&gt; c a1 -&gt; c a2 -&gt; a -&gt; a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Atoms</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> c =&gt; <a id="t:Skeleton" class="def">Skeleton</a> c <span class="keyword">where</span> <a href="src/ForSyDe.Atom.Skel.html#Skeleton" class="link">Source</a> <a href="#t:Skeleton" class="selflink">#</a></p><div class="doc"><p>Class containing all the Skeleton layer atoms.</p><p>This class is instantiated by a set of categorical types, i.e. types which describe
 an inherent potential for being evaluated in parallel. Skeletons are patterns from
 this layer. All skeletons can be described as composition of the three atoms
 below. This possible due to an existing theorem in the categorical type theory,
 also called the Bird-Merteens formalism:</p><p><a id="factorization"></a></p><dl><dt>factorization</dt><dd>A function on a categorical type is an algorithmic skeleton
 (i.e. catamorphism) <em>iff</em> it can be represented in a factorized form, i.e. as a
 <em>map</em> composed with a <em>reduce</em>.</dd></dl></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="ForSyDe-Atom-Skel.html#v:-61-.-61-" title="ForSyDe.Atom.Skel">(=.=)</a>, <a href="ForSyDe-Atom-Skel.html#v:-61--42--61-" title="ForSyDe.Atom.Skel">(=*=)</a>, <a href="ForSyDe-Atom-Skel.html#v:-61--92--61-" title="ForSyDe.Atom.Skel">(=\=)</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:-61-.-61-" class="def">(=.=)</a> :: (a -&gt; b) -&gt; c a -&gt; c b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe.Atom.Skel.html#%3D.%3D" class="link">Source</a> <a href="#v:-61-.-61-" class="selflink">#</a></p><div class="doc"><p>Atom which maps a function on each element of a structure
 (i.e. categorical type), defined as:</p><p><img src="fig/eqs-skel-atom-dot.png" /></p><p><code><a href="ForSyDe-Atom-Skel.html#v:-61-.-61-" title="ForSyDe.Atom.Skel">=.=</a></code> together with <code><a href="ForSyDe-Atom-Skel.html#v:-61--42--61-" title="ForSyDe.Atom.Skel">=*=</a></code> form the <code>map</code> pattern.</p></div><p class="src"><a id="v:-61--42--61-" class="def">(=*=)</a> :: c (a -&gt; b) -&gt; c a -&gt; c b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe.Atom.Skel.html#%3D%2A%3D" class="link">Source</a> <a href="#v:-61--42--61-" class="selflink">#</a></p><div class="doc"><p>Atom which applies the functions contained by as structure (i.e. categorical
 type), on the elements of another structure, defined as:</p><p><img src="fig/eqs-skel-atom-star.png" /></p><p><code><a href="ForSyDe-Atom-Skel.html#v:-61-.-61-" title="ForSyDe.Atom.Skel">=.=</a></code> together with <code><a href="ForSyDe-Atom-Skel.html#v:-61--42--61-" title="ForSyDe.Atom.Skel">=*=</a></code> form the <code>map</code> pattern.</p></div><p class="src"><a id="v:-61--92--61-" class="def">(=\=)</a> :: (a -&gt; a -&gt; a) -&gt; c a -&gt; a <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/ForSyDe.Atom.Skel.html#%3D%5C%3D" class="link">Source</a> <a href="#v:-61--92--61-" class="selflink">#</a></p><div class="doc"><p>Atom which reduces a structure to an element based on an <em>associative</em>
 function, defined as:</p><p><img src="fig/eqs-skel-atom-red.png" /></p></div><p class="src"><a id="v:-61--60--60--61-" class="def">(=&lt;&lt;=)</a> <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/ForSyDe.Atom.Skel.html#%3D%3C%3C%3D" class="link">Source</a> <a href="#v:-61--60--60--61-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: c (a -&gt; a)</td><td class="doc"><p>vector of functions</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>kernel element</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>result </p></td></tr></table></div><div class="doc"><p>Skeleton which <em>pipes</em> an element through all the functions contained by a
 structure. This is not an atom. It has an implicit definition which might be
 augmented by instances of this class to include edge cases.</p><p><img src="fig/eqs-skel-pattern-pipe.png" /></p><p>As the composition operation is not associative, we cannot treat <code>pipe</code> as a true
 reduction. However it can still be exploited in parallel since it exposes another
 type of parallelism: time parallelism.</p></div><p class="src"><a id="v:first" class="def">first</a> :: c a -&gt; a <a href="src/ForSyDe.Atom.Skel.html#first" class="link">Source</a> <a href="#v:first" class="selflink">#</a></p><div class="doc"><p>Returns the first element in a structure. This is not an atom. It has an
 implicit definition which might be replaced by instances of this class with a
 more efficient implementation.</p><p><img src="fig/eqs-skel-pattern-first.png" /></p></div><p class="src"><a id="v:last" class="def">last</a> :: c a -&gt; a <a href="src/ForSyDe.Atom.Skel.html#last" class="link">Source</a> <a href="#v:last" class="selflink">#</a></p><div class="doc"><p>Returns the last element in a structure. This is not an atom. It has an
 implicit definition which might be replaced by instances of this class with a
 more efficient implementation.</p><p><img src="fig/eqs-skel-pattern-last.png" /></p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Skeleton">Instances</h4><details id="i:Skeleton" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Skeleton:Skeleton:1"></span> <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a></span> <a href="src/ForSyDe.Atom.Skel.Vector.Core.html#line-103" class="link">Source</a> <a href="#t:Skeleton" class="selflink">#</a></td><td class="doc"><p>Ensures that <code><a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a></code> is a structure associated with the Skeleton Layer.</p></td></tr><tr><td colspan="2"><details id="i:ic:Skeleton:Skeleton:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-Skel-Vector-Core.html">ForSyDe.Atom.Skel.Vector.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61-.-61-">(=.=)</a> :: (a -&gt; b) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> b <a href="src/ForSyDe.Atom.Skel.html#%3D.%3D" class="link">Source</a> <a href="#v:-61-.-61-" class="selflink">#</a></p><p class="src"><a href="#v:-61--42--61-">(=*=)</a> :: <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (a -&gt; b) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> b <a href="src/ForSyDe.Atom.Skel.html#%3D%2A%3D" class="link">Source</a> <a href="#v:-61--42--61-" class="selflink">#</a></p><p class="src"><a href="#v:-61--92--61-">(=\=)</a> :: (a -&gt; a -&gt; a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a -&gt; a <a href="src/ForSyDe.Atom.Skel.html#%3D%5C%3D" class="link">Source</a> <a href="#v:-61--92--61-" class="selflink">#</a></p><p class="src"><a href="#v:-61--60--60--61-">(=&lt;&lt;=)</a> :: <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (a -&gt; a) -&gt; a -&gt; a <a href="src/ForSyDe.Atom.Skel.html#%3D%3C%3C%3D" class="link">Source</a> <a href="#v:-61--60--60--61-" class="selflink">#</a></p><p class="src"><a href="#v:first">first</a> :: <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a -&gt; a <a href="src/ForSyDe.Atom.Skel.html#first" class="link">Source</a> <a href="#v:first" class="selflink">#</a></p><p class="src"><a href="#v:last">last</a> :: <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a -&gt; a <a href="src/ForSyDe.Atom.Skel.html#last" class="link">Source</a> <a href="#v:last" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Skeleton constructors</h1></a><div class="doc"><p>Patterns of in the skeleton layer are provided, like all other patterns in
 ForSyDe-Atom, as constructors. If the layer below this one is the
 <code><a href="ForSyDe-Atom-MoC.html#v:MoC" title="ForSyDe.Atom.MoC">MoC</a></code> layer, i.e. the functions taken as arguments are
 processes, then these skeletons can be regarded as process network constructors,
 as the structures created are process networks with inherent potential for
 parallel implementation.</p></div><div class="top"><p class="src"><a id="v:farm22" class="def">farm22</a> :: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; c a1 -&gt; c a2 -&gt; (c b1, c b2) <a href="src/ForSyDe.Atom.Skel.html#farm22" class="link">Source</a> <a href="#v:farm22" class="selflink">#</a></p><div class="doc"><p><code>farm</code> maps a function on a vector. It is the embodiment of the
 <code>map</code> homomorphism, and its naming is inspired from the pattern
 predominant in HPC. Indeed, if we consider the layer below as being
 the <code><a href="ForSyDe-Atom-MoC.html#v:MoC" title="ForSyDe.Atom.MoC">MoC</a></code> layer (i.e. the passed functions are
 processes), the resulting structure could be regarded as a &quot;farm of
 data-parallel processes&quot;.</p><p>Constructors: <code>farm[1-8][1-4]</code>.</p><p><img src="fig/eqs-skel-pattern-farm.png" />
 <img src="fig/skel-pattern-farm.png" /></p></div></div><div class="top"><p class="src"><a id="v:reduce" class="def">reduce</a> <a href="src/ForSyDe.Atom.Skel.html#reduce" class="link">Source</a> <a href="#v:reduce" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; a -&gt; a)</td><td class="doc"><p>associative function (*)</p></td></tr><tr><td class="src">-&gt; c a</td><td class="doc"><p>structure</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>reduced element</p></td></tr></table></div><div class="doc"><p>Infix name for the <code><a href="ForSyDe-Atom-Skel.html#v:-61--92--61-" title="ForSyDe.Atom.Skel">=\=</a></code> atom operator.</p><p>(*) if the operation is not associative then the network can be
 treated like a pipeline.</p></div></div><div class="top"><p class="src"><a id="v:reducei" class="def">reducei</a> <a href="src/ForSyDe.Atom.Skel.html#reducei" class="link">Source</a> <a href="#v:reducei" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; a -&gt; a)</td><td class="doc"><p>associative function (*)</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>initial element of structure</p></td></tr><tr><td class="src">-&gt; c a</td><td class="doc"><p>structure</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>reduced element</p></td></tr></table></div><div class="doc"><p><code><a href="ForSyDe-Atom-Skel.html#v:reducei" title="ForSyDe.Atom.Skel">reducei</a></code> is special case of <code><a href="ForSyDe-Atom-Skel.html#v:reduce" title="ForSyDe.Atom.Skel">reduce</a></code> where an initial element is
 specified outside the reduced vector. It is implemented as a
 <code><a href="ForSyDe-Atom-Skel.html#v:pipe" title="ForSyDe.Atom.Skel">pipe</a></code> with switched arguments, and the reduction function is
 constrained to be associative. It is semantically equivalent to the
 pattern depicted below.</p><p>(*) if the operation is not associative then the network is
 semantically equivalent to <code>pipe1</code> (see <code><a href="ForSyDe-Atom-Skel.html#v:pipe2" title="ForSyDe.Atom.Skel">pipe2</a></code>).</p><p><img src="fig/eqs-skel-pattern-reducei.png" />
 <img src="fig/skel-pattern-reducei.png" /></p></div></div><div class="top"><p class="src"><a id="v:pipe" class="def">pipe</a> <a href="src/ForSyDe.Atom.Skel.html#pipe" class="link">Source</a> <a href="#v:pipe" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; c (a -&gt; a)</td><td class="doc"><p>vector of functions</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>kernel element</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>result </p></td></tr></table></div><div class="doc"><p>Infix name for the <code><a href="ForSyDe-Atom-Skel.html#v:-61--60--60--61-" title="ForSyDe.Atom.Skel">=&lt;&lt;=</a></code> skeleton operator.</p></div></div><div class="top"><p class="src"><a id="v:pipe2" class="def">pipe2</a> :: <a href="ForSyDe-Atom-Skel.html#t:Skeleton" title="ForSyDe.Atom.Skel">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; a -&gt; a) -&gt; c a1 -&gt; c a2 -&gt; a -&gt; a <a href="src/ForSyDe.Atom.Skel.html#pipe2" class="link">Source</a> <a href="#v:pipe2" class="selflink">#</a></p><div class="doc"><p>The <code>pipe</code> constructors are a more generic form of the <code><a href="ForSyDe-Atom-Skel.html#v:-61--60--60--61-" title="ForSyDe.Atom.Skel">=&lt;&lt;=</a></code>
 (<code><a href="ForSyDe-Atom-Skel.html#v:pipe" title="ForSyDe.Atom.Skel">pipe</a></code>) skeleton apt for successive partial application and create
 more robust parameterizable pipeline networks.</p><p>Constructors: <code>comb[1-8]</code>.</p><p><img src="fig/eqs-skel-pattern-pipe1.png" />
 <img src="fig/skel-pattern-pipe1.png" /></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>