<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ForSyDe.Atom.MoC.DE</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">forsyde-atom-0.3.0.0: Shallow-embedded DSL for modeling cyber-physical systems </span><ul class="links" id="page-menu"><li><a href="src/ForSyDe.Atom.MoC.DE.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li><li><a href="https://forsyde.github.io/forsyde-atom/">Back to ForSyDe Web</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu 2016-2017</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ForSyDe.Atom.MoC.DE</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Discrete event (<code>DE</code>)</a></li><li><a href="#g:2">Aliases &amp; utilities</a></li><li><a href="#g:3"><code>DE</code> process constuctors</a><ul><li><a href="#g:4">Simple</a></li><li><a href="#g:5">Hybrid</a></li><li><a href="#g:6">Interfaces</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <code>DE</code> library implements a DSL of atoms that operate according to a (safe
 instance of) the discrete event model of computation, along with helpers and
 patterns associated with this MoC.</p><p>This module exports a reduced interpretation of a DE language, where we assume that
 each event in a DE signal is persistent, i.e. happened at a discrete instant, and
 is buffered until a new event occurs. This enables to exploit the &quot;dataflow&quot; host
 of <code><a href="ForSyDe-Atom-MoC.html#v:Stream" title="ForSyDe.Atom.MoC">Stream</a></code>s in a conservative and <em>completely</em> deterministic
 manner. For an experimental DE language where events are not persistent but
 instantaneous, which goes along the classical interpretation of DE
 <a href="ForSyDe-Atom.html#cassandras09">[Cassandras09]</a> please check
 <a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a>.</p><p>Useful pointers:</p><ul><li><a href="ForSyDe-Atom.html">ForSyDe.Atom</a> contains general guidelines for using the API</li><li><a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a> documents details about the internals of the MoC layer, the
   atoms and the basic structure of all process constructors as MoC patterns.</li><li><a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a> contains useful utilities for plotting DE signals.</li><li><a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a> contains a (possibly non-conservative) DE language
   where events are treated as non-persistent.</li><li>the <a href="ForSyDe-Atom.html#naming_conv">naming convention</a> rules on how to interpret
   the function names based on their number of inputs and outputs.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:DE">DE</a> t a <span class="keyword">where</span><ul class="subs"><li><a href="#v:DE">DE</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; {..} -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:SignalBase">SignalBase</a> t a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Signal">Signal</a> a = <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp" title="ForSyDe.Atom.MoC.DE">TimeStamp</a> a</li><li class="src short"><span class="keyword">type</span> <a href="#t:TimeStamp">TimeStamp</a> = <a href="https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Clock.html#t:DiffTime" title="Data.Time.Clock">DiffTime</a></li><li class="src short"><a href="#v:unit2">unit2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; ((t, a1), (t, a2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2)</li><li class="src short"><a href="#v:infinite">infinite</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</li><li class="src short"><a href="#v:until">until</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; t -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</li><li class="src short"><a href="#v:signal">signal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; [(t, a)] -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</li><li class="src short"><a href="#v:checkSignal">checkSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a)</li><li class="src short"><a href="#v:readSignal">readSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</li><li class="src short"><a href="#v:delay">delay</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; t -&gt; a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</li><li class="src short"><a href="#v:delay-39-">delay'</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</li><li class="src short"><a href="#v:comb22">comb22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:reconfig22">reconfig22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:sync2">sync2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2)</li><li class="src short"><a href="#v:constant2">constant2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; (b1, b2) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:generate2">generate2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; (b1 -&gt; b2 -&gt; (b1, b2)) -&gt; ((t, b1), (t, b2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:stated22">stated22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; ((t, b1), (t, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:state22">state22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; ((t, b1), (t, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:moore22">moore22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; (b1, b2)) -&gt; (t, st) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:mealy22">mealy22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; (t, st) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</li><li class="src short"><a href="#v:embedSY22">embedSY22</a> :: (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> b2)</li><li class="src short"><a href="#v:toSY2">toSY2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b -&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> t, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> a, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> b)</li><li class="src short"><a href="#v:toCT2">toCT2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts (tm -&gt; a) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts (tm -&gt; b) -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b)</li><li class="src short"><a href="#v:zipx">zipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a)</li><li class="src short"><a href="#v:unzipx">unzipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a)</li><li class="src short"><a href="#v:unzipx-39-">unzipx'</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Discrete event (<code>DE</code>)</h1></a><div class="doc"><p>According to the tagged signal model <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>, &quot;a
 discrete-event system is a timed system <span class="mathjax">\(Q\)</span> where for all <span class="mathjax">\(s\in Q\)</span>, the tag
 sytem is order-isomorphic to a subset of the integers. Order-isomorphic means
 that there exists an order-preserving bijection between the events in and a
 subset of the integers (or the entire set of integers).&quot;</p><p>The discrete event (<code>DE</code>) MoC describes a notion of physical time through its
 tags, also called timestamps. An important property of the DE tag system is that
 between any two timestamps <span class="mathjax">\(t_u\)</span> and <span class="mathjax">\(t_v\)</span> there is a <strong><em>finite</em></strong> number of
 possible timestamps. Based on these observations we can formulate the folowing
 simplified definition:</p><dl><dt>The DE MoC</dt><dd>is abstracting the execution semantics of a system where
   synchronization is <em>discrete</em> (i.e. happens at discrete instants in time) and
   <em>time-dependent</em> (i.e. is based on an implicit algebra of tags).</dd></dl><p>There are many variants of discrete event simulators in literature. The execution
 model covered by the DE implementation in the <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a> module may be
 described as a <em>&quot;strictly causal cycle simulator&quot;</em> with no delta-delay nor
 superdense time. The signals behave as &quot;persistent channels&quot; (similar to an HDL
 simulator), and processes react instantaneously to any new event. The simplicity
 of the execution model is ideal for modeling safe DE systems, its monotonic
 dataflow internals making it somewhat comparable to the <em>conservative discrete</em>
 <em>event simulators</em> (see <a href="ForSyDe-Atom.html#fuji00">[Fujimoto00]</a>). Below you can
 see an example of a simple DE process, without any behavior extensions:</p><p><img src="fig/moc-de-example.png" /></p><p>A variant of the DE MoC where events are instantaneous and non-triggering
 behavior is implemented in <a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a>. Below are stated a few
 particularities of this DE MoC implementation:</p><ol><li>in the terms of <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>, our DE MoC is a one-sided
    system, i.e. time starts from an absolute <span class="mathjax">\(0\)</span>. While negative time cannot be
    represented, signals can be &quot;phase-aligned&quot; with the help of the
    <code><a href="ForSyDe-Atom-MoC.html#v:-45--38--45-" title="ForSyDe.Atom.MoC">-&amp;-</a></code> atom. All signals need to start from timestamp <span class="mathjax">\(0\)</span>,
    and events need to be positioned with their tags in strict ascending
    order. The <code><a href="ForSyDe-Atom-MoC-DE.html#v:checkSignal" title="ForSyDe.Atom.MoC.DE">checkSignal</a></code> utility enforces these rules. This restriction is
    lifted in <a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a>.</li><li>tags are explicit and a <code><a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> event will construct a type around both a tag and
    a value. Tags represent the start time of the event, the end time being
    implicit from the start time of the next event. By doing so, we ensure that
    the time domain is non-disjoint and continuous. This implies that, at any
    instant in time a <code><a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> system describes <em>one specific state</em>.</li><li>events are assumed to persist from their time of arrival until the next event
    arrives or, if there is no incoming event, until infinity. Hence, signals can
    be interpreted as either persistent channels (e.g. latched wires), or
    non-blocking buffers of size 1.</li><li>a safe <code><a href="ForSyDe-Atom-MoC-DE.html#v:delay" title="ForSyDe.Atom.MoC.DE">delay</a></code> consists in a prepend <code><a href="ForSyDe-Atom-MoC.html#v:-45--60--45-" title="ForSyDe.Atom.MoC">-&lt;-</a></code> (i.e. generating
    the new value) and a phase shift <code><a href="ForSyDe-Atom-MoC.html#v:-45--38--45-" title="ForSyDe.Atom.MoC">-&amp;-</a></code> (i.e. advancing time
    with a positive integer). This is done in order to both preserve causality and
    avoid deadlock.</li><li>as a consequence a pure <code><a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> feedback loop will generate an infinite number of
    events (strictly preceding each other), since it updates the value after a
    certain delay, and any input is assumed to go to infinity. Hence <em>all the</em>
    <em>stateful processes that involve a feedback loop, e.g. <code><a href="ForSyDe-Atom-MoC-DE.html#v:state22" title="ForSyDe.Atom.MoC.DE">state22</a></code>, <code><a href="ForSyDe-Atom-MoC-DE.html#v:moore22" title="ForSyDe.Atom.MoC.DE">moore22</a></code>,</em>
    <em><code><a href="ForSyDe-Atom-MoC-DE.html#v:mealy22" title="ForSyDe.Atom.MoC.DE">mealy22</a></code> are, by design choice, exposing this type of oscillating</em>
    <em>behavior</em>. For sateful processes that react &quot;instantaneously&quot;, one should
    consider defining a hybrid SY/DE process, see <code><a href="ForSyDe-Atom-MoC-DE.html#v:embedSY22" title="ForSyDe.Atom.MoC.DE">embedSY22</a></code>.</li><li>due to the reactive dataflow natures of the host <code><a href="ForSyDe-Atom-MoC.html#v:Stream" title="ForSyDe.Atom.MoC">Stream</a></code>s,
    DE processes <em>should not</em> to clean up events. Doing so might lead to deadlock
    wherever any feedback is involved. This means that a new event is created
    every time a new event arrives, regardless of what value it carries. This
    means that <em>all</em> values are propagated, justifying our system's conservative
    approach <a href="ForSyDe-Atom.html#fuji00">[Fujimoto00]</a>. <code><a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> atoms do not clean
    signals, however this restriction is lifted in <a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a>.</li><li>due to the pure and conservative approach, ForSyDe DE simulations, although
    not very efficient (i.e. suffer from the same drawback as the fist generation
    of conservative approaches, namey &quot;lookahead creep&quot;, see <em>unpublished yet</em>),
    are completely parallelizable. This is because processes are self-sufficient
    and do not depend on a global event queue (as compared to other cycle
    simulators).</li><li>any signal from outside needs to be sane ( <span class="mathjax">\(T\)</span> must be a total order) before
    being injected into a ForSyDe process network. Helper functions are equipped
    with sanity checkers. Inside a ForSyDe process network, transformations are
    monotonic, thus output signals are guaranteed to be sane.</li><li>since <span class="mathjax">\(T\)</span> is a total order, there is no need for an
    <a href="ForSyDe-Atom-MoC.html#context">execution context</a> and we can ignore the
    formatting of functions in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, thus
    <span class="mathjax">\[ \Gamma\vdash\alpha\rightarrow\beta = \alpha\rightarrow\beta \]</span></li></ol></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:DE" class="def">DE</a> t a <span class="keyword">where</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#DE" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></p><div class="doc"><p>The DE event. It identifies a discrete event signal. The type of the tag system
 needs to satisfy all of the three properties, as suggested by the type constraints
 imposed on it:</p><ul><li>it needs to be a numerical type, to express value 0 (global start) and every
   representable number needs to have an additive inverse.</li><li>it needs to be unambiguously comparable (defines a total order).</li><li>it needs to unambiguously define an equality operation.</li></ul><p>Due to these properties not all numerical types can represent DE tags. A typical
 example of inappropriate representation is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:DE" class="def">DE</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src">=&gt; { <a id="v:tag" class="def">tag</a> :: t</dfn><div class="doc"><p>timestamp</p></div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;, <a id="v:val" class="def">val</a> :: a</dfn><div class="doc"><p>the value</p></div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;} -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:DE">Instances</h4><details id="i:DE" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Functor:1"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t)</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-96" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc"><p>Allows for mapping of functions on a DE event.</p></td></tr><tr><td colspan="2"><details id="i:id:DE:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Applicative:2"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t)</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-100" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc"><p>Allows for lifting functions on a pair of DE events.</p></td></tr><tr><td colspan="2"><details id="i:id:DE:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t (a -&gt; b) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:MoC:3"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC.html#t:MoC" title="ForSyDe.Atom.MoC">MoC</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t)</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-60" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc"><p>Implenents the execution semantics for the DE MoC atoms.</p></td></tr><tr><td colspan="2"><details id="i:id:DE:MoC:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) a b <a href="src/ForSyDe.Atom.MoC.html#Fun" class="link">Source</a> <a href="#t:Fun" class="selflink">#</a></p><p class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) b <a href="src/ForSyDe.Atom.MoC.html#Ret" class="link">Source</a> <a href="#t:Ret" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-45-.-45-">(-.-)</a> :: <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) a b -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b) <a href="src/ForSyDe.Atom.MoC.html#-.-" class="link">Source</a> <a href="#v:-45-.-45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--42--45-">(-*-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t (<a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) a b)) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b) <a href="src/ForSyDe.Atom.MoC.html#-%2A-" class="link">Source</a> <a href="#v:-45--42--45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--42-">(-*)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t (<a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) b)) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t b) <a href="src/ForSyDe.Atom.MoC.html#-%2A" class="link">Source</a> <a href="#v:-45--42-" class="selflink">#</a></p><p class="src"><a href="#v:-45--60--45-">(-&lt;-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) <a href="src/ForSyDe.Atom.MoC.html#-%3C-" class="link">Source</a> <a href="#v:-45--60--45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--38--45-">(-&amp;-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) <a href="src/ForSyDe.Atom.MoC.html#-%26-" class="link">Source</a> <a href="#v:-45--38--45-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Eq:4"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a)</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-57" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:DE:Eq:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Read:5"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a)</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-90" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc"><p>Reads the string of type <code>v@t</code> as an event <code>DE t v</code>.</p></td></tr><tr><td colspan="2"><details id="i:id:DE:Read:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) <a href="#v:readsPrec" class="selflink">#</a></p><p class="src"><a href="#v:readList">readList</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> [<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a] <a href="#v:readList" class="selflink">#</a></p><p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) <a href="#v:readPrec" class="selflink">#</a></p><p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a] <a href="#v:readListPrec" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Show:6"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a)</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-86" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc"><p>Shows the event with tag <code>t</code> and value <code>v</code> as <code>v@t</code>.</p></td></tr><tr><td colspan="2"><details id="i:id:DE:Show:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a] -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Plot:7"></span> (<a href="ForSyDe-Atom-Utility-Plot.html#t:Plottable" title="ForSyDe.Atom.Utility.Plot">Plottable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Plot" title="ForSyDe.Atom.Utility.Plot">Plot</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a)</span> <a href="src/ForSyDe.Atom.Utility.Plot.html#line-228" class="link">Source</a> <a href="#t:Plot" class="selflink">#</a></td><td class="doc"><p>For plotting <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> signals.</p></td></tr><tr><td colspan="2"><details id="i:id:DE:Plot:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:sample">sample</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Samples" title="ForSyDe.Atom.Utility.Plot">Samples</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#sample" class="link">Source</a> <a href="#v:sample" class="selflink">#</a></p><p class="src"><a href="#v:sample-39-">sample'</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Samples" title="ForSyDe.Atom.Utility.Plot">Samples</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#sample%27" class="link">Source</a> <a href="#v:sample-39-" class="selflink">#</a></p><p class="src"><a href="#v:takeUntil">takeUntil</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a <a href="src/ForSyDe.Atom.Utility.Plot.html#takeUntil" class="link">Source</a> <a href="#v:takeUntil" class="selflink">#</a></p><p class="src"><a href="#v:getInfo">getInfo</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:PInfo" title="ForSyDe.Atom.Utility.Plot">PInfo</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#getInfo" class="link">Source</a> <a href="#v:getInfo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Ret:8"></span> <span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) b</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-62" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:DE:Ret:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) b = b</div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:DE:Fun:9"></span> <span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) a b</span> <a href="src/ForSyDe.Atom.MoC.DE.Core.html#line-61" class="link">Source</a> <a href="#t:DE" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:DE:Fun:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-Core.html">ForSyDe.Atom.MoC.DE.Core</a></p> <div class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t) a b = a -&gt; b</div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Aliases &amp; utilities</h1></a><div class="doc"><p>These are type synonyms and utilities provided for user
 convenience. They mainly concern the construction and usage of
 signals.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SignalBase" class="def">SignalBase</a> t a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) <a href="src/ForSyDe.Atom.MoC.DE.Core.html#SignalBase" class="link">Source</a> <a href="#t:SignalBase" class="selflink">#</a></p><div class="doc"><p>Type synonym for a base DE signal as a stream of <code><a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> events, where the type of
 tags has not been determined yet. In designs, it is advised to define a type alias
 for signals, using an appropriate numerical type for tags, e.g.</p><pre>import ForSyDe.Atom.MoC.DE hiding (Signal) -- hide provided alias, to use your own

type Signal a = SignalBase Int a</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Signal" class="def">Signal</a> a = <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp" title="ForSyDe.Atom.MoC.DE">TimeStamp</a> a <a href="src/ForSyDe.Atom.MoC.DE.Core.html#Signal" class="link">Source</a> <a href="#t:Signal" class="selflink">#</a></p><div class="doc"><p>Convenience alias for a DE signal, where tags are represented using our exported
 <code><a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp" title="ForSyDe.Atom.MoC.DE">TimeStamp</a></code> type.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:TimeStamp" class="def">TimeStamp</a> = <a href="https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Clock.html#t:DiffTime" title="Data.Time.Clock">DiffTime</a> <a href="src/ForSyDe.Atom.MoC.TimeStamp.html#TimeStamp" class="link">Source</a> <a href="#t:TimeStamp" class="selflink">#</a></p><div class="doc"><p>Alias for the type representing discrete time. It is inherently
 quantizable, the quantum being a picosecond ( <span class="mathjax">\(10^{-12}\)</span>
 seconds), thus it can be considered order-isomorphic with a set of
 integers, i.e. between any two timestamps there is a finite number
 of timestamps. Moreover, a timestamp can be easily translated into
 a rational number representing fractions of a second, so the
 conversion between timestamps (discrete time) and rationals
 (analog/continuous time) is straightforward.</p><p>This type is used in the explicit tags of the
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> MoC (and subsequently the discrete event
 evaluation engine for simulating the <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> MoC).</p></div></div><div class="top"><p class="src"><a id="v:unit2" class="def">unit2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; ((t, a1), (t, a2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2) <a href="src/ForSyDe.Atom.MoC.DE.Core.html#unit2" class="link">Source</a> <a href="#v:unit2" class="selflink">#</a></p><div class="doc"><p>Wraps a (tuple of) pair(s) <code>(tag, value)</code> into the equivalent
 unit signal(s). A unit signal is a signal with one event with the
 period <code>tag</code> carrying <code>value</code>.</p><p>Helpers: <code>unit|unit[2-4]</code>.</p></div></div><div class="top"><p class="src"><a id="v:infinite" class="def">infinite</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.Core.html#infinite" class="link">Source</a> <a href="#v:infinite" class="selflink">#</a></p><div class="doc"><p>Creates an infinite signal.</p></div></div><div class="top"><p class="src"><a id="v:until" class="def">until</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; t -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.Core.html#until" class="link">Source</a> <a href="#v:until" class="selflink">#</a></p><div class="doc"><p>Takes the first part of the signal util a given timestamp. The
 last event of the resulting signal is at the given timestamp and
 carries the previous value. This utility is useful when plotting
 a signal, to specify the interval of plotting.</p></div></div><div class="top"><p class="src"><a id="v:signal" class="def">signal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; [(t, a)] -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.Core.html#signal" class="link">Source</a> <a href="#v:signal" class="selflink">#</a></p><div class="doc"><p>Transforms a list of tuples <code>(tag, value)</code> into a DE
 signal. Checks if it is well-formed.</p></div></div><div class="top"><p class="src"><a id="v:checkSignal" class="def">checkSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t a) <a href="src/ForSyDe.Atom.MoC.DE.Core.html#checkSignal" class="link">Source</a> <a href="#v:checkSignal" class="selflink">#</a></p><div class="doc"><p>Checks if a signal is well-formed or not, according to the DE MoC
 interpretation in ForSyDe-Atom.</p></div></div><div class="top"><p class="src"><a id="v:readSignal" class="def">readSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.Core.html#readSignal" class="link">Source</a> <a href="#v:readSignal" class="selflink">#</a></p><div class="doc"><p>Reads a signal from a string and checks if it is well-formed.
 Like with the <code>read</code> function from <code>Prelude</code>, you must specify the
 type of the signal.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>readSignal &quot;{ 1@0, 2@2, 3@5, 4@7, 5@10 }&quot; :: Signal Int
</code></strong>{1@0s,2@2s,3@5s,4@7s,5@10s}
</pre><p>Incorrect usage (not covered by <code>doctest</code>):</p><pre>&#955;&gt; readSignal &quot;{ 1@0, 2@2, 3@5, 4@10, 5@7 }&quot; :: Signal Int
{1@0s,2@2s,3@5s*** Exception: [MoC.DE] malformed signal
&#955;&gt; readSignal &quot;{ 1@1, 2@2, 3@5, 4@7, 5@10 }&quot; :: Signal Int
*** Exception: [MoC.DE] signal does not start from global 0</pre></div></div><a href="#g:3" id="g:3"><h1><code>DE</code> process constuctors</h1></a><div class="doc"><p>These are specific implementations of the atom patterns defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>.</p></div><a href="#g:4" id="g:4"><h2>Simple</h2></a><div class="doc"><p>These are mainly direct instantiations of patterns defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, using DE-specific utilities.</p></div><div class="top"><p class="src"><a id="v:delay" class="def">delay</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#delay" class="link">Source</a> <a href="#v:delay" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; t</td><td class="doc"><p>time delay</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>The <code>delay</code> process &quot;delays&quot; a signal with one
 event. Instantiates the <code><a href="ForSyDe-Atom-MoC.html#v:delay" title="ForSyDe.Atom.MoC">delay</a></code> pattern defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay 3 0 s
</code></strong>{0@0s,1@3s,2@5s,3@9s,4@11s,5@12s}
</pre><p><img src="fig/moc-de-pattern-delay.png" /></p></div></div><div class="top"><p class="src"><a id="v:delay-39-" class="def">delay'</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#delay%27" class="link">Source</a> <a href="#v:delay-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</td><td class="doc"><p>signal &quot;borrowing&quot; the initial event</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>Similar to the previous, but this is the raw instantiation of the
 <code><a href="ForSyDe-Atom-MoC.html#v:delay" title="ForSyDe.Atom.MoC">delay</a></code> pattern from <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>. It
 &quot;borrows&quot; the first event from one signal and appends it at the
 head of another signal.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{3@0, 4@4, 5@5, 6@8, 7@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay' s1 s2
</code></strong>{1@0s,3@2s,4@6s,5@7s,6@10s,7@11s}
</pre><p><img src="fig/moc-de-pattern-delayp.png" /></p></div></div><div class="top"><p class="src"><a id="v:comb22" class="def">comb22</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#comb22" class="link">Source</a> <a href="#v:comb22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>function on values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>comb</code> processes map combinatorial functions on signals and take
 care of synchronization between input signals. It instantiates the
 <code>comb</code> pattern (see <code><a href="ForSyDe-Atom-MoC.html#v:comb22" title="ForSyDe.Atom.MoC">comb22</a></code> defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>comb[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = infinite 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb11 (+1) s2
</code></strong>{2@0s,3@2s,4@6s,5@8s,6@9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb22 (\a b-&gt; (a+b,a-b)) s1 s2
</code></strong>({2@0s,3@2s,4@6s,5@8s,6@9s},{0@0s,-1@2s,-2@6s,-3@8s,-4@9s})
</pre><p><img src="fig/moc-de-pattern-comb.png" /></p></div></div><div class="top"><p class="src"><a id="v:reconfig22" class="def">reconfig22</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#reconfig22" class="link">Source</a> <a href="#v:reconfig22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>signal carrying functions</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1</td><td class="doc"><p>first input signal carrying arguments</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2</td><td class="doc"><p>second input signal carrying arguments</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>reconfig</code> creates a DE adaptive process where the first signal
 carries functions and the other carry the arguments. It
 instantiates the <code>reconfig</code> atom pattern (see
 <code><a href="ForSyDe-Atom-MoC.html#v:reconfig22" title="ForSyDe.Atom.MoC">reconfig22</a></code> defined in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>reconfig[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sf = signal [(0,(+1)),(2,(*2)),(5,(+1)),(7,(*2))]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [(0,1),(3,2),(5,3),(9,4)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>reconfig11 sf s1
</code></strong>{2@0,2@2,4@3,4@5,6@7,8@9}
</pre><p><img src="fig/moc-de-pattern-reconfig.png" /></p></div></div><div class="top"><p class="src"><a id="v:sync2" class="def">sync2</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#sync2" class="link">Source</a> <a href="#v:sync2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>sync</code> synchronizes multiple signals, so that they have the same
 set of tags, and consequently, the same number of events. It
 instantiates the <code>comb</code> atom pattern (see <code><a href="ForSyDe-Atom-MoC.html#v:comb22" title="ForSyDe.Atom.MoC">comb22</a></code>
 defined in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>sync[1-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@0, 2@2, 3@6, 4@8,  5@9}&quot;  :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@0, 2@5, 3@6, 4@10, 5@12}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sync2 s1 s2
</code></strong>({1@0s,2@2s,2@5s,3@6s,4@8s,5@9s,5@10s,5@12s},{1@0s,1@2s,2@5s,3@6s,3@8s,3@9s,4@10s,5@12s})
</pre><p><img src="fig/moc-de-pattern-sync.png" /></p></div></div><div class="top"><p class="src"><a id="v:constant2" class="def">constant2</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#constant2" class="link">Source</a> <a href="#v:constant2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1, b2)</td><td class="doc"><p>values to be repeated</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A signal generator which keeps a value constant. As compared with
 the <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code>, it just constructs an infinite signal
 with constant value (i.e. a signal with one event starting from
 time 0).</p><p>Constructors: <code>constant[1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>constant1 2
</code></strong>{2@0}
</pre><p><img src="fig/moc-de-pattern-constant.png" /></p></div></div><div class="top"><p class="src"><a id="v:generate2" class="def">generate2</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#generate2" class="link">Source</a> <a href="#v:generate2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; (b1, b2))</td><td class="doc"><p>function to generate next value</p></td></tr><tr><td class="src">-&gt; ((t, b1), (t, b2))</td><td class="doc"><p>kernel values tupled with their generation rate.</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A signal generator based on a function and a kernel value. It is
 actually an instantiation of the <code>stated0X</code> constructor (check
 <code><a href="ForSyDe-Atom-MoC.html#v:stated22" title="ForSyDe.Atom.MoC">stated22</a></code> defined in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>generate[1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (s1,s2) = generate2 (\a b -&gt; (a+1,b+2)) ((3,1),(1,2))
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 5 s1
</code></strong>{1@0,2@3,2@4,2@5,3@6}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 s2
</code></strong>{2@0,4@1,6@2,8@3,10@4,12@5,14@6}
</pre><p><img src="fig/moc-de-pattern-generate.png" /></p></div></div><div class="top"><p class="src"><a id="v:stated22" class="def">stated22</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#stated22" class="link">Source</a> <a href="#v:stated22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; ((t, b1), (t, b2))</td><td class="doc"><p>initial state values tupled with their initial delay</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>stated</code> is a state machine without an output decoder. It is an
 instantiation of the <code>state</code> MoC constructor (see
 <code><a href="ForSyDe-Atom-MoC.html#v:stated22" title="ForSyDe.Atom.MoC">stated22</a></code> defined in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>stated[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ stated11 (+) (6,1) s
</code></strong>{1@0s,2@6s,3@8s,5@12s,7@14s,8@15s,10@18s}
</pre><p><img src="fig/moc-de-pattern-stated.png" /></p></div></div><div class="top"><p class="src"><a id="v:state22" class="def">state22</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#state22" class="link">Source</a> <a href="#v:state22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; ((t, b1), (t, b2))</td><td class="doc"><p>initial state values tupled with their initial delay</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>state</code> is a state machine without an output decoder, and the
 state non-transparent. It is an instantiation of the <code>state</code> MoC
 constructor (see <code><a href="ForSyDe-Atom-MoC.html#v:state22" title="ForSyDe.Atom.MoC">state22</a></code> defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>state[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ state11 (+) (6,1) s
</code></strong>{2@0s,3@2s,5@6s,7@8s,8@9s,10@12s,12@14s}
</pre><p><img src="fig/moc-de-pattern-state.png" />                   </p></div></div><div class="top"><p class="src"><a id="v:moore22" class="def">moore22</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#moore22" class="link">Source</a> <a href="#v:moore22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; (b1, b2))</td><td class="doc"><p>output decoder</p></td></tr><tr><td class="src">-&gt; (t, st)</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>moore</code> processes model Moore state machines. It is an
 instantiation of the <code>moore</code> MoC constructor (see
 <code><a href="ForSyDe-Atom-MoC.html#v:moore22" title="ForSyDe.Atom.MoC">moore22</a></code> defined in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>moore[1-4][1-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ moore11 (+) (+1) (6,1) s
</code></strong>{2@0s,3@6s,4@8s,6@12s,8@14s,9@15s,11@18s}
</pre><p><img src="fig/moc-de-pattern-moore.png" />          </p></div></div><div class="top"><p class="src"><a id="v:mealy22" class="def">mealy22</a> <a href="src/ForSyDe.Atom.MoC.DE.Lib.html#mealy22" class="link">Source</a> <a href="#v:mealy22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>outpt decoder</p></td></tr><tr><td class="src">-&gt; (t, st)</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>mealy</code> processes model Mealy state machines. It is an
 instantiation of the <code>mealy</code> MoC constructor (see
 <code><a href="ForSyDe-Atom-MoC.html#v:mealy22" title="ForSyDe.Atom.MoC">mealy22</a></code> defined in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>).</p><p>Constructors: <code>mealy[1-4][1-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ mealy11 (+) (-) (6,1) s
</code></strong>{0@0s,-1@2s,-1@6s,-1@8s,-2@9s,0@12s,2@14s}
</pre><p><img src="fig/moc-de-pattern-mealy.png" /></p></div></div><a href="#g:5" id="g:5"><h2>Hybrid</h2></a><div class="doc"><p>Processes that can wrap other MoCs inside a DE execution model.</p></div><div class="top"><p class="src"><a id="v:embedSY22" class="def">embedSY22</a> <a href="src/ForSyDe.Atom.MoC.DE.Hybrid.html#embedSY22" class="link">Source</a> <a href="#v:embedSY22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> b2))</td><td class="doc"><p><code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> process</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> a1</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> a2</td><td class="doc"><p>second input DE signal </p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal" title="ForSyDe.Atom.MoC.DE">Signal</a> b2)</td><td class="doc"><p>two output <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> signals</p></td></tr></table></div><div class="doc"><p>Embeds a <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> process inside a
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> environment. Internally, it synchronizes
 the input signals, translates them to SY, feeds them to a SY
 process and translates the result back to DE using the same input
 tags. Seen from outside, this process behaves like a DE process
 with &quot;instantaneous response&quot;, even for feedback loops.</p><p>Constructors: <code>embedSY[1-4][1-4]</code>.</p><p>For the following example, see the difference between its output
 and the one of <code><a href="ForSyDe-Atom-MoC-DE.html#v:stated22" title="ForSyDe.Atom.MoC.DE">stated22</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embedSY11 (SY.stated11 (+) 1) s
</code></strong>{1@0s,2@2s,4@6s,7@8s,11@9s}
</pre><p><img src="fig/moc-de-pattern-embedsy.png" /></p></div></div><a href="#g:6" id="g:6"><h2>Interfaces</h2></a><div class="top"><p class="src"><a id="v:toSY2" class="def">toSY2</a> <a href="src/ForSyDe.Atom.MoC.DE.Interface.html#toSY2" class="link">Source</a> <a href="#v:toSY2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t b</td><td class="doc"><p>second input DE signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> t, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> a, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> b)</td><td class="doc"><p>signal carrying timestamps tupled with the two output
 <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> signals</p></td></tr></table></div><div class="doc"><p>Synchronizes a (set of) <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> signal(s) an
 strips off their explicit tags, outputting the equivalent
 <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> signal(s), tupled with an SY signal
 carrying the timestamps for the synchronization points.</p><p>Constructors: <code>toSY[1-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.infinite 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = DE.readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toSY2 s1 s2
</code></strong>({0s,2s,6s,8s,9s},{1,1,1,1,1},{1,2,3,4,5})
</pre><p><img src="fig/moc-de-tosy.png" /></p></div></div><div class="top"><p class="src"><a id="v:toCT2" class="def">toCT2</a> <a href="src/ForSyDe.Atom.MoC.DE.Interface.html#toCT2" class="link">Source</a> <a href="#v:toCT2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts (tm -&gt; a)</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts (tm -&gt; b)</td><td class="doc"><p>second input DE signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b)</td><td class="doc"><p>two output <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> signals</p></td></tr></table></div><div class="doc"><p>Semantic preserving transformation between a (set of) DE
 signal(s) and the equivalent CT signals. The
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> events must carry a function of <code>Time</code>
 which will be lifted by providing it with <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code>
 implicit time semantics.</p><p>Constructors: <code>toCT[1-4]</code>.</p><p><img src="fig/moc-de-toct.png" /></p></div></div><div class="top"><p class="src"><a id="v:zipx" class="def">zipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) <a href="src/ForSyDe.Atom.MoC.DE.Interface.html#zipx" class="link">Source</a> <a href="#v:zipx" class="selflink">#</a></p><div class="doc"><p>Synchronizes all the signals contained by a vector and zips them
 into one signal of vectors. It instantiates the
 <code><a href="ForSyDe-Atom-Skel-Vector.html#v:zipx" title="ForSyDe.Atom.Skel.Vector">zipx</a></code> skeleton.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = DE.readSignal &quot;{1@0, 2@2, 3@4, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [s1,s1,s2,s2]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>v1
</code></strong>&lt;{1@0s,2@2s,3@6s,4@8s,5@9s},{1@0s,2@2s,3@6s,4@8s,5@9s},{1@0s,2@2s,3@4s,4@8s,5@9s},{1@0s,2@2s,3@4s,4@8s,5@9s}&gt;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>zipx v1
</code></strong>{&lt;1,1,1,1&gt;@0s,&lt;2,2,2,2&gt;@2s,&lt;2,2,3,3&gt;@4s,&lt;3,3,3,3&gt;@6s,&lt;4,4,4,4&gt;@8s,&lt;5,5,5,5&gt;@9s}
</pre><p><img src="fig/moc-de-zipx.png" /></p></div></div><div class="top"><p class="src"><a id="v:unzipx" class="def">unzipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a) <a href="src/ForSyDe.Atom.MoC.DE.Interface.html#unzipx" class="link">Source</a> <a href="#v:unzipx" class="selflink">#</a></p><div class="doc"><p>Unzips the vectors carried by a signal into a vector of
 signals. It instantiates the <code><a href="ForSyDe-Atom-Skel-Vector.html#v:unzipx" title="ForSyDe.Atom.Skel.Vector">unzipx</a></code>
 skeleton. To avoid infinite recurrence, the user needs to provide
 the length of the output vector.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [1,2,3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.signal [(0,v1),(2,v1),(6,v1),(8,v1),(9,v1)] :: DE.Signal (V.Vector Int)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s1
</code></strong>{&lt;1,2,3,4&gt;@0s,&lt;1,2,3,4&gt;@2s,&lt;1,2,3,4&gt;@6s,&lt;1,2,3,4&gt;@8s,&lt;1,2,3,4&gt;@9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unzipx 4 s1
</code></strong>&lt;{1@0s,1@2s,1@6s,1@8s,1@9s},{2@0s,2@2s,2@6s,2@8s,2@9s},{3@0s,3@2s,3@6s,3@8s,3@9s},{4@0s,4@2s,4@6s,4@8s,4@9s}&gt;
</pre><p><img src="fig/moc-de-unzipx.png" /></p></div></div><div class="top"><p class="src"><a id="v:unzipx-39-" class="def">unzipx'</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> t a) <a href="src/ForSyDe.Atom.MoC.DE.Interface.html#unzipx%27" class="link">Source</a> <a href="#v:unzipx-39-" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="ForSyDe-Atom-MoC-DE.html#v:unzipx" title="ForSyDe.Atom.MoC.DE">unzipx</a></code>, but &quot;sniffs&quot; the first event to determine the length of the output vector. Might have unsafe behavior!</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [1,2,3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.signal [(0,v1),(2,v1),(6,v1),(8,v1),(9,v1)] :: DE.Signal (V.Vector Int)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s1
</code></strong>{&lt;1,2,3,4&gt;@0s,&lt;1,2,3,4&gt;@2s,&lt;1,2,3,4&gt;@6s,&lt;1,2,3,4&gt;@8s,&lt;1,2,3,4&gt;@9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unzipx' s1
</code></strong>&lt;{1@0s,1@2s,1@6s,1@8s,1@9s},{2@0s,2@2s,2@6s,2@8s,2@9s},{3@0s,3@2s,3@6s,3@8s,3@9s},{4@0s,4@2s,4@6s,4@8s,4@9s}&gt;
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>