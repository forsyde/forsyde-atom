<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ForSyDe.Atom.MoC.SY.Clocked</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">forsyde-atom-0.3.0.0: Shallow-embedded DSL for modeling cyber-physical systems </span><ul class="links" id="page-menu"><li><a href="src/ForSyDe.Atom.MoC.SY.Clocked.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li><li><a href="https://forsyde.github.io/forsyde-atom/">Back to ForSyDe Web</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu 2020</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ForSyDe.Atom.MoC.SY.Clocked</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Lustre constructs</a></li><li><a href="#g:2">Auxiliary constructs</a></li><li><a href="#g:3">Regular constructors</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This is a small experimental library for modeling multi-clock rate SY systems in
 the style of Lustre <a href="ForSyDe-Atom.html#halbwachs91">[Halbwachs91]</a>. It is
 implemented mainly on top of the <a href="ForSyDe-Atom-MoC-SY.html">ForSyDe.Atom.MoC.SY</a> library, re-using it to the
 full extent, and it represents Lustre language constructs as specific
 patterns. Instead of developing and representing an inherent clock calculus like
 Lustre, this library merely propagates &quot;no-ops&quot; as absent
 (i.e. <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Abst" title="ForSyDe.Atom.ExB.Absent">Abst</a></code>) events and utilises the algebra of
 <a href="ForSyDe-Atom-ExB.html">ForSyDe.Atom.ExB</a> to model clock rates. </p><p>Internally, a <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> process constructor represents
 implicitly a <a href="ForSyDe-Atom-MoC-SY.html">ForSyDe.Atom.MoC.SY</a> MoC layer wrapping a <a href="ForSyDe-Atom-ExB-Absent.html">ForSyDe.Atom.ExB.Absent</a>
 behavior extension layer. Under these asumptions the <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a>
 models can be interpreted as follows:</p><ul><li>the host <a href="ForSyDe-Atom-MoC-SY.html">ForSyDe.Atom.MoC.SY</a> processes operate at the basic clock rate. I.e. a
   signal where all events are present is active in the basic time scale.</li><li>the wrapped <a href="ForSyDe-Atom-ExB.html">ForSyDe.Atom.ExB</a> behaviors operate on and propagate absent/present
   events based on the operating clock rate. <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Abst" title="ForSyDe.Atom.ExB.Absent">Abst</a></code> means
   that an event &quot;did not occur&quot;. Combining a present with an absent event in any
   regular operation (see <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:comb22" title="ForSyDe.Atom.MoC.SY.Clocked">comb22</a></code>) would violate the clock constraints of
   well-formed systems (see <a href="ForSyDe-Atom.html#halbwachs91">[Halbwachs91]</a>) and would
   throw a runtime error.</li><li>Although <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> is hosted on <a href="ForSyDe-Atom-MoC-SY.html">ForSyDe.Atom.MoC.SY</a>, the
   <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Abst" title="ForSyDe.Atom.ExB.Absent">Abst</a></code> &quot;value&quot; has no true meaning in a pure SY reactive
   system. Therefore to interface between these two SY domains should always be made
   through a <code>toDE</code>/<code>fromDE</code> interface. <strong>OBS:</strong> these interfaces are still
   experimental and higly unsafe especially when considering feedback loops.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:Signal">Signal</a> a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-SY.html#t:SY" title="ForSyDe.Atom.MoC.SY">SY</a> (<a href="ForSyDe-Atom-ExB-Absent.html#t:AbstExt" title="ForSyDe.Atom.ExB.Absent">AbstExt</a> a))</li><li class="src short"><a href="#v:pre">pre</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</li><li class="src short"><a href="#v:-45--62--45-">(-&gt;-)</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</li><li class="src short"><a href="#v:when">when</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</li><li class="src short"><a href="#v:current">current</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</li><li class="src short"><a href="#v:is">is</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:whenIs2">whenIs2</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</li><li class="src short"><a href="#v:whenPres2">whenPres2</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</li><li class="src short"><a href="#v:filter">filter</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</li><li class="src short"><a href="#v:fill">fill</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</li><li class="src short"><a href="#v:delay">delay</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</li><li class="src short"><a href="#v:comb22">comb22</a> :: (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</li><li class="src short"><a href="#v:stated22">stated22</a> :: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; (b1, b2) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</li><li class="src short"><a href="#v:state22">state22</a> :: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; (b1, b2) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</li><li class="src short"><a href="#v:moore22">moore22</a> :: (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; (b1, b2)) -&gt; st -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</li><li class="src short"><a href="#v:mealy22">mealy22</a> :: (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; st -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Signal" class="def">Signal</a> a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-SY.html#t:SY" title="ForSyDe.Atom.MoC.SY">SY</a> (<a href="ForSyDe-Atom-ExB-Absent.html#t:AbstExt" title="ForSyDe.Atom.ExB.Absent">AbstExt</a> a)) <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#Signal" class="link">Source</a> <a href="#t:Signal" class="selflink">#</a></p><div class="doc"><p>Alias showing that in the <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> domain, a signal is
 considered a stream of absent-extended SY events.</p></div></div><a href="#g:1" id="g:1"><h1>Lustre constructs</h1></a><div class="doc"><p>These are process constructors which imitate the behavior of Lustre constructs
 according to our <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> definition.</p></div><div class="top"><p class="src"><a id="v:pre" class="def">pre</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#pre" class="link">Source</a> <a href="#v:pre" class="selflink">#</a></p><div class="doc"><p>The <code>pre</code> construct in Lustre. <strong>OBS:</strong> instead of <em>nil</em>, the first value is an
 <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Abst" title="ForSyDe.Atom.ExB.Absent">Abst</a></code>. <em>TODO:</em> unclear if this breaks the SY assumption.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [Prst 1, Prst 2, Prst 3, Prst 4, Prst 5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>pre s1
</code></strong>{&#10178;,1,2,3,4,5}
</pre></div></div><div class="top"><p class="src"><a id="v:-45--62--45-" class="def">(-&gt;-)</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#-%3E-" class="link">Source</a> <a href="#v:-45--62--45-" class="selflink">#</a></p><div class="doc"><p>The <code>-&gt;</code> operator in Lustre.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [Prst 1, Prst 2, Prst 3, Prst 4, Prst 5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unit (Prst 10) -&gt;- s1
</code></strong>{10,2,3,4,5}
</pre></div></div><div class="top"><p class="src"><a id="v:when" class="def">when</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#when" class="link">Source</a> <a href="#v:when" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p>Signal of predicates</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Output signal</p></td></tr></table></div><div class="doc"><p>Determines the existence of events in the (left) signal based on the (right)
 signal of boolean values (conditions). In Lustre this construct is used to generate
 other clock rates.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1   = (signal . map Prst) [1,2,3,4,5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let pred = signal [Prst False, Abst, Prst True, Prst False, Prst True]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s1 `when` pred
</code></strong>{&#10178;,&#10178;,3,&#10178;,5}
</pre></div></div><div class="top"><p class="src"><a id="v:current" class="def">current</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#current" class="link">Source</a> <a href="#v:current" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: a</td><td class="doc"><p>Value to fill with in case there was no previous value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Input</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Output</p></td></tr></table></div><div class="doc"><p>Holds the last non-absent value in a signal, like the <code>current</code> construct in
 Lustre. <strong>OBS:</strong> instead of <em>nil</em>, the first value is user-defined.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1   = signal [Abst, Abst, Prst 1, Prst 2, Abst, Prst 3]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>current 0 s1
</code></strong>{0,0,1,2,2,3}
</pre></div></div><a href="#g:2" id="g:2"><h1>Auxiliary constructs</h1></a><div class="doc"><p>These are utility process constructors used in combination with the main
 constructs.</p></div><div class="top"><p class="src"><a id="v:is" class="def">is</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#is" class="link">Source</a> <a href="#v:is" class="selflink">#</a></p><div class="doc"><p>Applies a predicate function on a signal of absent-extended events.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1   = signal $ map Prst [1,2,3,4,5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s1 `is` (&gt;3)
</code></strong>{False,False,False,True,True}
</pre><p>It is useful in combination with <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:when" title="ForSyDe.Atom.MoC.SY.Clocked">when</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = (signal . map Prst) [1,2,3,4,5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = (signal . map Prst) [11,22,33,44,55]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s2 `when` (s1 `is` (&gt;3))
</code></strong>{&#10178;,&#10178;,&#10178;,44,55}
</pre></div></div><div class="top"><p class="src"><a id="v:whenIs2" class="def">whenIs2</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2) <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#whenIs2" class="link">Source</a> <a href="#v:whenIs2" class="selflink">#</a></p><div class="doc"><p>Serializes <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:when" title="ForSyDe.Atom.MoC.SY.Clocked">when</a></code> with <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:is" title="ForSyDe.Atom.MoC.SY.Clocked">is</a></code> for up to three input signals.</p><p>Constructors <code>whenIs[1-3]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = (signal . map Prst) [1,2,3,4,5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = (signal . map Prst) [11,22,33,44,55]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>whenIs2 (&gt;3) s1 s1 s2
</code></strong>({&#10178;,&#10178;,&#10178;,4,5},{&#10178;,&#10178;,&#10178;,44,55})
</pre></div></div><div class="top"><p class="src"><a id="v:whenPres2" class="def">whenPres2</a> :: <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2) <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#whenPres2" class="link">Source</a> <a href="#v:whenPres2" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:whenIs2" title="ForSyDe.Atom.MoC.SY.Clocked">whenIs2</a></code> but triggering the output events only based on the presence of
 the first input rather than a boolean.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal $ map Prst [1,2,3,4,5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sp = signal [Prst 1, Prst 1, Abst, Prst 1, Abst]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>whenPres1 sp s1
</code></strong>{1,2,&#10178;,4,&#10178;}
</pre></div></div><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>Predicate function</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Output signal</p></td></tr></table></div><div class="doc"><p>Filters out values to <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Abst" title="ForSyDe.Atom.ExB.Absent">Abst</a></code> if they do not fulfill a predicate function,
 i.e. applies <code>whenIs1</code> on itself.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1   = (signal . map Prst) [1,2,3,4,5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>filter (&gt;3) s1
</code></strong>{&#10178;,&#10178;,&#10178;,4,5}
</pre></div></div><div class="top"><p class="src"><a id="v:fill" class="def">fill</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#fill" class="link">Source</a> <a href="#v:fill" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: a</td><td class="doc"><p>Value to fill with</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Input</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>Output</p></td></tr></table></div><div class="doc"><p>Fills absent events with a user-defined value.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1   = signal [Abst, Abst, Prst 1, Prst 2, Abst, Prst 3]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fill 0 s1
</code></strong>{0,0,1,2,0,3}
</pre></div></div><a href="#g:3" id="g:3"><h1>Regular constructors</h1></a><div class="doc"><p>These are the regular process constructors defined as patterns in the
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a> module, but adapted for the absent-extended behaviors.  </p></div><div class="top"><p class="src"><a id="v:delay" class="def">delay</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#delay" class="link">Source</a> <a href="#v:delay" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>The <code>delay</code> process &quot;delays&quot; a signal with one event. Serializes a <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:pre" title="ForSyDe.Atom.MoC.SY.Clocked">pre</a></code> and a
 <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:-45--62--45-" title="ForSyDe.Atom.MoC.SY.Clocked">-&gt;-</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = signal [Prst 1,Prst 2,Prst 3,Abst,Prst 5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay 0 s
</code></strong>{0,1,2,3,&#10178;,5}
</pre></div></div><div class="top"><p class="src"><a id="v:comb22" class="def">comb22</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#comb22" class="link">Source</a> <a href="#v:comb22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>function on values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>comb</code> processes map combinatorial functions on signals on synchronized input
 signals. It implements the <code>comb</code> pattern (see <code><a href="ForSyDe-Atom-MoC.html#v:comb22" title="ForSyDe.Atom.MoC">comb22</a></code>), and
 implicitly applies a resolution between absent-extended events (see
 <code><a href="ForSyDe-Atom-ExB.html#v:res22" title="ForSyDe.Atom.ExB">res22</a></code>)</p><p>Constructors: <code>comb[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = (signal . map Prst) [1..]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = signal [Prst 1,Prst 1,Abst,Prst 1,Prst 1]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb11 (+1) s2
</code></strong>{2,2,&#10178;,2,2}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb22 (\a b-&gt; (a+b,a-b)) s2 s2
</code></strong>({2,2,&#10178;,2,2},{0,0,&#10178;,0,0})
</pre><p>Combining two signals at different clock rates throws a runtime error:</p><pre>comb22 (\a b-&gt; (a+b,a-b)) s1 s2
({2,3,*** Exception: [ExB.Absent] Illegal occurrence of an absent and present event</pre></div></div><div class="top"><p class="src"><a id="v:stated22" class="def">stated22</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#stated22" class="link">Source</a> <a href="#v:stated22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next stated function</p></td></tr><tr><td class="src">-&gt; (b1, b2)</td><td class="doc"><p>initial stated values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>stated</code> is a state machine without an output decoder. It implements the <code>stated</code>
 pattern (see <code><a href="ForSyDe-Atom-MoC.html#v:stated22" title="ForSyDe.Atom.MoC">stated22</a></code>), and operates on
 <code><a href="ForSyDe-Atom-ExB.html#v:degen" title="ForSyDe.Atom.ExB">degen</a></code>erated absent-extended values (see
 <code><a href="ForSyDe-Atom-ExB.html#v:ignore22" title="ForSyDe.Atom.ExB">ignore22</a></code>) in order to propagate absent events properly and not
 raise absent-present resolution errors.</p><p>Constructors: <code>stated[1-3][1-3]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ones = takeS 8 $ SY.constant1 (Prst 1)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let b = (signal . map Prst) [False,True,False,False,True,True,False,True]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ones
</code></strong>{1,1,1,1,1,1,1,1}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>b
</code></strong>{False,True,False,False,True,True,False,True}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stated11 (+) 1 ones
</code></strong>{1,2,3,4,5,6,7,8}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stated11 (+) 1 (ones `when` b)
</code></strong>{&#10178;,1,&#10178;,&#10178;,2,3,&#10178;,4}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stated11 (+) 1 ones `when` b
</code></strong>{&#10178;,2,&#10178;,&#10178;,5,6,&#10178;,8}
</pre></div></div><div class="top"><p class="src"><a id="v:state22" class="def">state22</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#state22" class="link">Source</a> <a href="#v:state22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (b1, b2)</td><td class="doc"><p>initial state values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>state</code> is a state machine without an output decoder, that reacts
 instantaneously. It implements the <code>state</code> pattern (see
 <code><a href="ForSyDe-Atom-MoC.html#v:state22" title="ForSyDe.Atom.MoC">state22</a></code>), and operates on <code><a href="ForSyDe-Atom-ExB.html#v:degen" title="ForSyDe.Atom.ExB">degen</a></code>erated
 absent-extended values (see <code><a href="ForSyDe-Atom-ExB.html#v:ignore22" title="ForSyDe.Atom.ExB">ignore22</a></code>) in order to propagate
 absent events properly and not raise absent-present resolution errors.</p><p>Constructors: <code>state[1-3][1-3]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ones = takeS 8 $ SY.constant1 (Prst 1)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let b = (signal . map Prst) [False,True,False,False,True,True,False,True]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ones
</code></strong>{1,1,1,1,1,1,1,1}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>b
</code></strong>{False,True,False,False,True,True,False,True}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>state11 (+) 1 ones
</code></strong>{2,3,4,5,6,7,8,9}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>state11 (+) 1 (ones `when` b)
</code></strong>{&#10178;,2,&#10178;,&#10178;,3,4,&#10178;,5}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>state11 (+) 1 ones `when` b
</code></strong>{&#10178;,3,&#10178;,&#10178;,6,7,&#10178;,9}
</pre></div></div><div class="top"><p class="src"><a id="v:moore22" class="def">moore22</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#moore22" class="link">Source</a> <a href="#v:moore22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; (b1, b2))</td><td class="doc"><p>output decoder</p></td></tr><tr><td class="src">-&gt; st</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>moore</code> processes model Moore state machines. It implements the <code>moore</code> patterns
 (see <code><a href="ForSyDe-Atom-MoC.html#v:moore22" title="ForSyDe.Atom.MoC">moore22</a></code>), and operates on absent-extended values (see
 <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:stated22" title="ForSyDe.Atom.MoC.SY.Clocked">stated22</a></code>).</p><p>Constructors: <code>moore[1-3][1-3]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [Prst 1,Prst 2,Abst,Abst,Prst 3]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>moore11 (+) (+1) 1 s1
</code></strong>{2,3,&#10178;,&#10178;,5}
</pre></div></div><div class="top"><p class="src"><a id="v:mealy22" class="def">mealy22</a> <a href="src/ForSyDe.Atom.MoC.SY.Clocked.html#mealy22" class="link">Source</a> <a href="#v:mealy22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>outpt decoder</p></td></tr><tr><td class="src">-&gt; st</td><td class="doc"><p>initial state</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>mealy</code> processes model Mealy state machines. It implements the <code>mealy</code> pattern
 (see <code><a href="ForSyDe-Atom-MoC.html#v:mealy22" title="ForSyDe.Atom.MoC">mealy22</a></code>), and operates on absent-extended values (see
 <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:stated22" title="ForSyDe.Atom.MoC.SY.Clocked">stated22</a></code>).</p><p>Constructors: <code>mealy[1-3][1-3]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [Prst 1,Prst 2,Abst,Abst,Prst 3]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mealy11 (+) (+) 1 s1
</code></strong>{2,4,&#10178;,&#10178;,7}
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>