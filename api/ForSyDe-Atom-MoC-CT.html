<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ForSyDe.Atom.MoC.CT</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">forsyde-atom-0.3.0.0: Shallow-embedded DSL for modeling cyber-physical systems </span><ul class="links" id="page-menu"><li><a href="src/ForSyDe.Atom.MoC.CT.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li><li><a href="https://forsyde.github.io/forsyde-atom/">Back to ForSyDe Web</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu 2016-2018</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr><tr><th>Extensions</th><td>PostfixOperators</td></tr></table><p class="caption">ForSyDe.Atom.MoC.CT</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Continuous time (<code>CT</code>) event</a></li><li><a href="#g:2">Aliases &amp; utilities</a></li><li><a href="#g:3"><code>CT</code> process constuctors</a><ul><li><a href="#g:4">Simple</a></li><li><a href="#g:5">Interfaces</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <code>CT</code> library implements a DSL of atoms that operate according to a plactical
 interpretation of the continuous time model of computation, along with helpers and
 associated patterns.</p><p>This interpretation of the CT MoC is an <em>extension</em> of the <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code>
 MoC in the sense that it borrow its algebra of discrete interactions
 entirely. However, there is one major difference:</p><ul><li>in <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> signals carry values of an <span class="mathjax">\(\alpha\)</span> type, which is
   conveniently describing persistent values between two (consecutive) discrete
   events;</li><li>in <code><a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> signals instead carry functions of type <span class="mathjax">\(\tau\rightarrow\alpha\)</span> which
   evolve in time.</li></ul><p>The type <span class="mathjax">\(\tau\)</span> is an arbitrary (yet appropriate) numerical representation for
 continuous time (e.g. see the in-built <code><a href="ForSyDe-Atom-MoC-CT.html#t:Time" title="ForSyDe.Atom.MoC.CT">Time</a></code> alias). By
 abstracting the time away from signals and keeping it as an (arbitrary) argument, a
 ForSyDe-Atom CT process network is able to describe and manipulate symbolic (pure)
 continuous functions, the numerical representation becoming apparent only when the
 output is forced to be evaluated at discrete points in time, e.g. for the purpose
 of plotting. Hence this CT MoC DSL is describing &quot;an algebra of discrete
 interactions between continuous sub-signals&quot;. For more information, please consult
 <a href="ForSyDe-Atom.html#ungureanu18">[Ungureanu18]</a>.</p><p>Useful pointers:</p><ul><li><a href="ForSyDe-Atom.html">ForSyDe.Atom</a> contains general guidelines for using the API</li><li><a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a> documents details about the internals of the MoC layer, the
   atoms and the basic structure of all process constructors as MoC patterns.</li><li><a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a> contains useful utilities for sampling and plotting
   CT signals.</li><li><a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a> is the &quot;host&quot; DSL for the CT MoC, inferring the semantics
  of discrete interactions.</li><li>the <a href="ForSyDe-Atom.html#naming_conv">naming convention</a> rules on how to interpret
   the function names based on their number of inputs and outputs.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:TimeStamp">TimeStamp</a> = <a href="https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Clock.html#t:DiffTime" title="Data.Time.Clock">DiffTime</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Time">Time</a> = <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Rational" title="Prelude">Rational</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:CT">CT</a> timestamp time a <span class="keyword">where</span><ul class="subs"><li><a href="#v:CT">CT</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> time, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> timestamp, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> timestamp, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> timestamp) =&gt; {..} -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:SignalBase">SignalBase</a> timestamp time a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Signal">Signal</a> a = <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> <a href="ForSyDe-Atom-MoC-CT.html#t:TimeStamp" title="ForSyDe.Atom.MoC.CT">TimeStamp</a> <a href="ForSyDe-Atom-MoC-CT.html#t:Time" title="ForSyDe.Atom.MoC.CT">Time</a> a</li><li class="src short"><a href="#v:unit2">unit2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts) =&gt; ((ts, tm -&gt; a1), (ts, tm -&gt; a2)) -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2)</li><li class="src short"><a href="#v:infinite">infinite</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts) =&gt; (tm -&gt; a) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</li><li class="src short"><a href="#v:signal">signal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts) =&gt; [(ts, tm -&gt; a)] -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</li><li class="src short"><a href="#v:checkSignal">checkSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> timestamp, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> timestamp) =&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a)</li><li class="src short"><a href="#v:delay">delay</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; ts -&gt; (tm -&gt; a) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</li><li class="src short"><a href="#v:delay-39-">delay'</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</li><li class="src short"><a href="#v:comb22">comb22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1 -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2 -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:reconfig22">reconfig22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1 -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2 -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:constant2">constant2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (b1, b2) -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:infinite2">infinite2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (tm -&gt; b1, tm -&gt; b2) -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:generate2">generate2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (b1 -&gt; b2 -&gt; (b1, b2)) -&gt; ((ts, tm -&gt; b1), (ts, tm -&gt; b2)) -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:stated22">stated22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; ((ts, tm -&gt; b1), (ts, tm -&gt; b2)) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1 -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2 -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:state22">state22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; ((ts, tm -&gt; b1), (ts, tm -&gt; b2)) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1 -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2 -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:moore22">moore22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; (b1, b2)) -&gt; (ts, tm -&gt; st) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1 -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2 -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:mealy22">mealy22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; (ts, tm -&gt; st) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1 -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2 -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</li><li class="src short"><a href="#v:toDE1">toDE1</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts (tm -&gt; a)</li><li class="src short"><a href="#v:sampDE2">sampDE2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts t -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts a, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts b)</li><li class="src short"><a href="#v:zipx">zipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a)</li><li class="src short"><a href="#v:unzipx">unzipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a)</li><li class="src short"><a href="#v:unzipx-39-">unzipx'</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Continuous time (<code>CT</code>) event</h1></a><div class="doc"><p>According to <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>, &quot;[regarding metric time] at a
 minimum, <span class="mathjax">\(T\)</span> is an Abelian group, in addition to being totally ordered. A
 consequence is that <span class="mathjax">\(t_2-t_1\)</span> is itself a tag <span class="mathjax">\(\forall t_1,t_2 \in T\)</span>. In a
 slightly more elaborate model of computation, <span class="mathjax">\(T\)</span> has a metric. (...) A
 continuous-time system is a metric timed system <span class="mathjax">\(Q\)</span> where <span class="mathjax">\(T\)</span> is a continuum
 (a closed connected set).&quot;</p><p>The continuous time (<code>CT</code>) MoC defines the closest behavior to what we could call
 &quot;physical time&quot;, where signals cover the full span of a simulation as functions
 of time rather than values. As such, we can state:</p><dl><dt>The CT MoC</dt><dd>is describes a system where computation is performed continuously
   over a (possibly infinite) span of time.</dd></dl><p>For a detailed descrption of the ForSyDe-Atom CT execution model, refer to
 <a href="ForSyDe-Atom.html#ungureanu18">[Ungureanu18]</a>. Below is an illustration of the
 behavior in time of the input and the output signals of a CT process:</p><p><img src="fig/moc-ct-example.png" /></p><p>Our <code><a href="ForSyDe-MoC-CT.html#v:CT" title="ForSyDe.MoC.CT">CT</a></code> MoC is implemented as a generalized version of
 ForSyDe-Atom's <code><a href="ForSyDe-MoC-DE.html#v:DE" title="ForSyDe.MoC.DE">DE</a></code>, or rather the <code><a href="ForSyDe-MoC-DE.html#v:DE" title="ForSyDe.MoC.DE">DE</a></code> MoC is a
 special case of <code><a href="ForSyDe-MoC-CT.html#v:CT" title="ForSyDe.MoC.CT">CT</a></code> in the sense that:</p><ol><li>tags <span class="mathjax">\(t\)</span> represent discrete timestamps when changes in a CT signal happen,
    or rather are observed (see below).</li><li>&quot;events&quot; are represented as <em>functions</em> over a continuous span of time
    <span class="mathjax">\(f(t)\)</span> rather than, like in most simulators based on imperative programs,
    series of sampled values. The time domain is abstracted away, and may be
    represented with whatever data type the user deems appropriate or convenient.</li><li>for practical reasons, the <code><a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> event constructor has also a <em>phase</em> component
    <span class="mathjax">\(\phi\)</span>, which is taken into consideration only when evaluating a signal
    function, i.e. <span class="mathjax">\(f(t+\phi)\)</span>. This enables the modeling of &quot;phase
    dispacements&quot; of delay lines without altering the function itself,
    i.e. without increasing the complexity of the un-evaluated functions
    (redexes). The phase is reset during event synchronization.</li></ol><p><img src="fig/misc-ct-model.png" /></p><p>Based on the these particularities we can say that the <code><a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> MoC is simply a
 <code><a href="ForSyDe-Atom-DE.html#v:DE" title="ForSyDe.Atom.DE">DE</a></code> machine/observer operating on continuous subdomains, and we
 can formulate the following properties:</p><ol><li><code><a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> signals represent <em>discrete</em> changes in a continuous function over time
    (e.g. analog signal). While the functions carried by events are infinite (have
    always happened and will always happen), they are interpreted as being
    &quot;active&quot; e.g. during two consecutive discrete times. A CT signal can be
    represented by the analog circuit above, where the inputs are continuous
    signals, but the switch is discrete. Like in the <code><a href="ForSyDe-MoC-DE.html#v:DE" title="ForSyDe.MoC.DE">DE</a></code> MoC, the
    absolute time <span class="mathjax">\(0\)</span> represent the time when the system started to be observed.</li><li>events carry <em>functions</em> and not <em>values</em>. In a lazy evaluation system like
    Haskell's, functions are kept symbolic until evaluation. This means that in a
    CT system computations are propagated as function AST until a result is
    needed, e.g. a signal needs to be plotted for arbitrary time instants. The
    cost of higher plot resolution is the cost of evaluating the final
    (reduced-form) output expression only, and not more intermediate computations.</li><li>since itself the <code><a href="ForSyDe-MoC-CT.html#v:CT" title="ForSyDe.MoC.CT">CT</a></code> MoC is simply a <code><a href="ForSyDe-MoC-DE.html#v:DE" title="ForSyDe.MoC.DE">DE</a></code>
    system operating on continuous subdomains, all atom evaluation properties are
    inherited from it: feedback loops need to advance time, atoms are forbidden to
    clean signals, and the conservative approach makes it possible
    parallelize/distribute the simulation.</li><li>since <span class="mathjax">\(T\)</span> is a total order, there is no need for an
    <a href="ForSyDe-Atom-MoC.html#context">execution context</a> and we can ignore the
    formatting of functions in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, thus
    <span class="mathjax">\[ \Gamma\vdash\alpha\rightarrow\beta = \alpha\rightarrow\beta \]</span></li></ol></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:TimeStamp" class="def">TimeStamp</a> = <a href="https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Clock.html#t:DiffTime" title="Data.Time.Clock">DiffTime</a> <a href="src/ForSyDe.Atom.MoC.TimeStamp.html#TimeStamp" class="link">Source</a> <a href="#t:TimeStamp" class="selflink">#</a></p><div class="doc"><p>Alias for the type representing discrete time. It is inherently
 quantizable, the quantum being a picosecond ( <span class="mathjax">\(10^{-12}\)</span>
 seconds), thus it can be considered order-isomorphic with a set of
 integers, i.e. between any two timestamps there is a finite number
 of timestamps. Moreover, a timestamp can be easily translated into
 a rational number representing fractions of a second, so the
 conversion between timestamps (discrete time) and rationals
 (analog/continuous time) is straightforward.</p><p>This type is used in the explicit tags of the
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> MoC (and subsequently the discrete event
 evaluation engine for simulating the <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> MoC).</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Time" class="def">Time</a> = <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Rational" title="Prelude">Rational</a> <a href="src/ForSyDe.Atom.MoC.Time.html#Time" class="link">Source</a> <a href="#t:Time" class="selflink">#</a></p><div class="doc"><p>Type alias for the type to represent metric (continuous)
 time. Underneath we use <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Rational" title="Prelude">Rational</a></code> that is able to represent any
 <span class="mathjax">\(t\)</span> between <span class="mathjax">\(t_1 &lt; t_2 \in T\)</span>.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:CT" class="def">CT</a> timestamp time a <span class="keyword">where</span> <a href="src/ForSyDe.Atom.MoC.CT.Core.html#CT" class="link">Source</a> <a href="#t:CT" class="selflink">#</a></p><div class="doc"><p>The CT event. It identifies a continuous time signal. It is composed of three
 parts: a tag, a phase displacement and a continuous sub-signal as a function of
 time. The types passed to this constructor need to satisfy all of the three
 properties, as suggested by the type constraints:</p><ul><li><code>time</code> needs to be an arbitrary numerical type, member of the <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a></code> class
   (see <code><a href="ForSyDe-Atom-MoC.html#t:MoC" title="ForSyDe.Atom.MoC">MoC</a></code> instance). If possible, <code><a href="ForSyDe-Atom-MoC-CT.html#t:Time" title="ForSyDe.Atom.MoC.CT">Time</a></code>, which is an alias for <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Rational" title="Prelude">Rational</a></code> is
   preferred, as it is the closest numerical representation for continuums.</li><li><code>timestamp</code> needs to be a numerical type, to express value 0 (global start) and
   every representable number needs to have an additive inverse.</li><li><code>timestamp</code> needs to be unambiguously comparable (defines a total order).</li><li><code>timestamp</code> needs to unambiguously define an equality operation.</li></ul><p>Due to these properties not all numerical types can represent CT timestamps, see
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:CT" class="def">CT</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> time, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> timestamp, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> timestamp, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> timestamp)</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src">=&gt; { <a id="v:tag" class="def">tag</a> :: timestamp</dfn><div class="doc"><p>start time of event</p></div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;, <a id="v:phase" class="def">phase</a> :: time</dfn><div class="doc"><p>phase. Models function delays</p></div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;, <a id="v:func" class="def">func</a> :: time -&gt; a</dfn><div class="doc"><p>function of time</p></div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;} -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:CT">Instances</h4><details id="i:CT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CT:Plot:1"></span> <a href="ForSyDe-Atom-Utility-Plot.html#t:Plottable" title="ForSyDe.Atom.Utility.Plot">Plottable</a> a =&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Plot" title="ForSyDe.Atom.Utility.Plot">Plot</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:Signal" title="ForSyDe.Atom.MoC.CT">Signal</a> a)</span> <a href="src/ForSyDe.Atom.Utility.Plot.html#line-283" class="link">Source</a> <a href="#t:Plot" class="selflink">#</a></td><td class="doc"><p>For plotting <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> signals.</p></td></tr><tr><td colspan="2"><details id="i:id:CT:Plot:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:sample">sample</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:Signal" title="ForSyDe.Atom.MoC.CT">Signal</a> a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Samples" title="ForSyDe.Atom.Utility.Plot">Samples</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#sample" class="link">Source</a> <a href="#v:sample" class="selflink">#</a></p><p class="src"><a href="#v:sample-39-">sample'</a> :: <a href="ForSyDe-Atom-MoC-CT.html#t:Signal" title="ForSyDe.Atom.MoC.CT">Signal</a> a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Samples" title="ForSyDe.Atom.Utility.Plot">Samples</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#sample%27" class="link">Source</a> <a href="#v:sample-39-" class="selflink">#</a></p><p class="src"><a href="#v:takeUntil">takeUntil</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:Signal" title="ForSyDe.Atom.MoC.CT">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:Signal" title="ForSyDe.Atom.MoC.CT">Signal</a> a <a href="src/ForSyDe.Atom.Utility.Plot.html#takeUntil" class="link">Source</a> <a href="#v:takeUntil" class="selflink">#</a></p><p class="src"><a href="#v:getInfo">getInfo</a> :: <a href="ForSyDe-Atom-MoC-CT.html#t:Signal" title="ForSyDe.Atom.MoC.CT">Signal</a> a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:PInfo" title="ForSyDe.Atom.Utility.Plot">PInfo</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#getInfo" class="link">Source</a> <a href="#v:getInfo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CT:Functor:2"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts)</span> <a href="src/ForSyDe.Atom.MoC.CT.Core.html#line-97" class="link">Source</a> <a href="#t:CT" class="selflink">#</a></td><td class="doc"><p>Allows for mapping of functions on a CT event.</p></td></tr><tr><td colspan="2"><details id="i:id:CT:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-CT-Core.html">ForSyDe.Atom.MoC.CT.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts b -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CT:Applicative:3"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts)</span> <a href="src/ForSyDe.Atom.MoC.CT.Core.html#line-101" class="link">Source</a> <a href="#t:CT" class="selflink">#</a></td><td class="doc"><p>Allows for lifting functions on a pair of CT events.</p></td></tr><tr><td colspan="2"><details id="i:id:CT:Applicative:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-CT-Core.html">ForSyDe.Atom.MoC.CT.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts (a -&gt; b) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts b -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts b -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts b -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> tm ts a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CT:MoC:4"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts) =&gt; <a href="ForSyDe-Atom-MoC.html#t:MoC" title="ForSyDe.Atom.MoC">MoC</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm)</span> <a href="src/ForSyDe.Atom.MoC.CT.Core.html#line-67" class="link">Source</a> <a href="#t:CT" class="selflink">#</a></td><td class="doc"><p>Implenents the execution semantics for the CT MoC atoms.</p></td></tr><tr><td colspan="2"><details id="i:id:CT:MoC:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-CT-Core.html">ForSyDe.Atom.MoC.CT.Core</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) a b <a href="src/ForSyDe.Atom.MoC.html#Fun" class="link">Source</a> <a href="#t:Fun" class="selflink">#</a></p><p class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) b <a href="src/ForSyDe.Atom.MoC.html#Ret" class="link">Source</a> <a href="#t:Ret" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-45-.-45-">(-.-)</a> :: <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) a b -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm b) <a href="src/ForSyDe.Atom.MoC.html#-.-" class="link">Source</a> <a href="#v:-45-.-45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--42--45-">(-*-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm (<a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) a b)) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm b) <a href="src/ForSyDe.Atom.MoC.html#-%2A-" class="link">Source</a> <a href="#v:-45--42--45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--42-">(-*)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm (<a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) b)) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm b) <a href="src/ForSyDe.Atom.MoC.html#-%2A" class="link">Source</a> <a href="#v:-45--42-" class="selflink">#</a></p><p class="src"><a href="#v:-45--60--45-">(-&lt;-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) <a href="src/ForSyDe.Atom.MoC.html#-%3C-" class="link">Source</a> <a href="#v:-45--60--45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--38--45-">(-&amp;-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a) <a href="src/ForSyDe.Atom.MoC.html#-%26-" class="link">Source</a> <a href="#v:-45--38--45-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CT:Show:5"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a)</span> <a href="src/ForSyDe.Atom.MoC.CT.Core.html#line-107" class="link">Source</a> <a href="#t:CT" class="selflink">#</a></td><td class="doc"><p><strong>FOR DEBUG ONLY!</strong> It evaluates <em>only</em> the signal at
 the start time.</p></td></tr><tr><td colspan="2"><details id="i:id:CT:Show:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-CT-Core.html">ForSyDe.Atom.MoC.CT.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm a] -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CT:Ret:6"></span> <span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) b</span> <a href="src/ForSyDe.Atom.MoC.CT.Core.html#line-71" class="link">Source</a> <a href="#t:CT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:CT:Ret:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-CT-Core.html">ForSyDe.Atom.MoC.CT.Core</a></p> <div class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) b = b</div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:CT:Fun:7"></span> <span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) a b</span> <a href="src/ForSyDe.Atom.MoC.CT.Core.html#line-70" class="link">Source</a> <a href="#t:CT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:CT:Fun:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-CT-Core.html">ForSyDe.Atom.MoC.CT.Core</a></p> <div class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> ts tm) a b = a -&gt; b</div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Aliases &amp; utilities</h1></a><div class="doc"><p>A set of type synonyms and utilities are provided for convenience. The API type
 signatures will feature these aliases to hide the cumbersome construction of
 atoms and patters as seen in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SignalBase" class="def">SignalBase</a> timestamp time a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a) <a href="src/ForSyDe.Atom.MoC.CT.Core.html#SignalBase" class="link">Source</a> <a href="#t:SignalBase" class="selflink">#</a></p><div class="doc"><p>Type synonym for a base DE signal as a stream of <code>DE</code> events, where the type of
 tags has not been determined yet. In designs, it is advised to define a type alias
 for signals, using an appropriate numerical type for tags, e.g.</p><pre>import ForSyDe.Atom.MoC.CT

type MyCtSignal a = SignalBase Int Float a</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Signal" class="def">Signal</a> a = <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> <a href="ForSyDe-Atom-MoC-CT.html#t:TimeStamp" title="ForSyDe.Atom.MoC.CT">TimeStamp</a> <a href="ForSyDe-Atom-MoC-CT.html#t:Time" title="ForSyDe.Atom.MoC.CT">Time</a> a <a href="src/ForSyDe.Atom.MoC.CT.Core.html#Signal" class="link">Source</a> <a href="#t:Signal" class="selflink">#</a></p><div class="doc"><p>Convenience alias for a CT signal, where tags are represented using our
 <code><a href="ForSyDe-Atom-MoC-CT.html#t:TimeStamp" title="ForSyDe.Atom.MoC.CT">TimeStamp</a></code> alias and time is represented usign our <code><a href="ForSyDe-Atom-MoC-CT.html#t:Time" title="ForSyDe.Atom.MoC.CT">Time</a></code> alias.</p></div></div><div class="top"><p class="src"><a id="v:unit2" class="def">unit2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts) =&gt; ((ts, tm -&gt; a1), (ts, tm -&gt; a2)) -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2) <a href="src/ForSyDe.Atom.MoC.CT.Core.html#unit2" class="link">Source</a> <a href="#v:unit2" class="selflink">#</a></p><div class="doc"><p>Wraps a (tuple of) pair(s) <code>(time, function)</code> into the equivalent
 unit signal(s), i.e. signal(s) with one event with the period
 <code>time</code> carrying <code>function</code>.</p><p>Helpers: <code>unit</code> and <code>unit[2-4]</code>.</p></div></div><div class="top"><p class="src"><a id="v:infinite" class="def">infinite</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts) =&gt; (tm -&gt; a) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a <a href="src/ForSyDe.Atom.MoC.CT.Core.html#infinite" class="link">Source</a> <a href="#v:infinite" class="selflink">#</a></p><div class="doc"><p>Creates an infinite signal.</p></div></div><div class="top"><p class="src"><a id="v:signal" class="def">signal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts) =&gt; [(ts, tm -&gt; a)] -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a <a href="src/ForSyDe.Atom.MoC.CT.Core.html#signal" class="link">Source</a> <a href="#v:signal" class="selflink">#</a></p><div class="doc"><p>Transforms a list of tuples such as the ones taken by <code>event</code>
 into a CT signal</p></div></div><div class="top"><p class="src"><a id="v:checkSignal" class="def">checkSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> timestamp, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> timestamp) =&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:CT" title="ForSyDe.Atom.MoC.CT">CT</a> timestamp time a) <a href="src/ForSyDe.Atom.MoC.CT.Core.html#checkSignal" class="link">Source</a> <a href="#v:checkSignal" class="selflink">#</a></p><div class="doc"><p>Checks if a signal is well-formed or not, according to the CT MoC
 interpretation in <code>ForSyDe-Atom</code>.</p></div></div><a href="#g:3" id="g:3"><h1><code>CT</code> process constuctors</h1></a><div class="doc"><p>The CT process constructors are specific instantiations of patterns defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>.</p><p>In the examples below, we use our <code><a href="ForSyDe-Atom-MoC-CT.html#t:Signal" title="ForSyDe.Atom.MoC.CT">Signal</a></code> type, i.e. a <code><a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a></code> with
 <a href="ForSyDe-Atom-MoC-TimeStamp.html">ForSyDe.Atom.MoC.TimeStamp</a> for tag type and <a href="ForSyDe-Atom-MoC-Time.html">ForSyDe.Atom.MoC.Time</a> for time
 type. Consequently we use functions such as <code>e'</code> <code>pi'</code>, <code>sin'</code> and <code>cos'</code> from
 their respective collection of utilities. Also, for the sake of documentation the
 interactive examples are only dumping the CT signals in data files using the
 <code>dumpDat</code> utility defined in <a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a>, according to the custom
 <code>cfg</code> structure. These files can be further plotted by any tool of choice, or
 using the plotting utilities provided in the <a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a> module.</p><pre>import ForSyDe.Atom.Utility.Plot
import ForSyDe.Atom.MoC.Time as Time
import ForSyDe.Atom.MoC.TimeStamp as TimeStamp
let pi'  = TimeStamp.pi
let exp' = Time.exp
let sin' = Time.sin
let cos' = Time.cos
let cfg  = defaultCfg {xmax=10, rate=0.1}</pre></div><a href="#g:4" id="g:4"><h2>Simple</h2></a><div class="doc"><p>These are mainly direct instantiations of patterns defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, using CT-specific utilities.</p></div><div class="top"><p class="src"><a id="v:delay" class="def">delay</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#delay" class="link">Source</a> <a href="#v:delay" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ts</td><td class="doc"><p>time delay</p></td></tr><tr><td class="src">-&gt; (tm -&gt; a)</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>The <code>delay</code> process &quot;delays&quot; a signal with one
 event. Instantiates the <code><a href="ForSyDe-Atom-MoC.html#v:delay" title="ForSyDe.Atom.MoC">delay</a></code> pattern. In the CT
 MoC, this process can be interpreted as an ideal &quot;delay line&quot;.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s  = infinite (sin') :: Signal Time
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s' = delay 2 (\_ -&gt; 0) s
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;delay&quot;]} $ s'
</code></strong>Dumped delay in ./fig
[&quot;./fig/delay.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-delay.png" /></p></div></div><div class="top"><p class="src"><a id="v:delay-39-" class="def">delay'</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#delay%27" class="link">Source</a> <a href="#v:delay-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</td><td class="doc"><p>signal &quot;borrowing&quot; the initial event</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>Similar to the previous, but this is the raw instantiation of the
 <code><a href="ForSyDe-Atom-MoC.html#v:delay" title="ForSyDe.Atom.MoC">delay</a></code> pattern. It &quot;borrows&quot; the first event from
 one signal and appends it at the head of another signal.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s  = infinite (sin') :: Signal Time
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s' = signal [(0, \_ -&gt; 0), (2, \_ -&gt; 1)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;delayp&quot;]} $ delay' s' s
</code></strong>Dumped delayp in ./fig
[&quot;./fig/delayp.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-delayp.png" /></p></div></div><div class="top"><p class="src"><a id="v:comb22" class="def">comb22</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#comb22" class="link">Source</a> <a href="#v:comb22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>function on values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>comb</code> processes map combinatorial functions on signals and take
 care of synchronization between input signals. It instantiates the
 <code>comb</code> pattern (see <code><a href="ForSyDe-Atom-MoC.html#v:comb22" title="ForSyDe.Atom.MoC">comb22</a></code>).</p><p>Constructors: <code>comb[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = infinite (sin') :: Signal Time
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = signal [(0,\_-&gt;0),(pi',\_-&gt;1),(2*pi',\_-&gt;0),(3*pi',\_-&gt;1)] :: Signal Time
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let o1 = comb11 (+1) s2
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (o2_1, o2_2) = comb22 (\a b-&gt; (a+b,a*b)) s1 s2
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;comb11&quot;]} o1
</code></strong>Dumped comb11 in ./fig
[&quot;./fig/comb11.dat&quot;]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepareL cfg {labels=[&quot;comb22-1&quot;,&quot;comb22-2&quot;]} [o2_1, o2_2]
</code></strong>Dumped comb22-1, comb22-2 in ./fig
[&quot;./fig/comb22-1.dat&quot;,&quot;./fig/comb22-2.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-comb.png" /></p></div></div><div class="top"><p class="src"><a id="v:reconfig22" class="def">reconfig22</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#reconfig22" class="link">Source</a> <a href="#v:reconfig22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>signal carrying functions</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1</td><td class="doc"><p>first input signal carrying arguments</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2</td><td class="doc"><p>second input signal carrying arguments</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>reconfig</code> creates a CT adaptive process where the first signal
 carries functions and the other carry the arguments. It
 instantiates the <code>reconfig</code> atom pattern (see
 <code><a href="ForSyDe-Atom-MoC.html#v:reconfig22" title="ForSyDe.Atom.MoC">reconfig22</a></code>).</p><p>Constructors: <code>reconfig[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = infinite (sin') :: Signal Time
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sf = signal [(0,\_-&gt;(*0)),(pi',\_-&gt;(+1)),(2*pi',\_-&gt;(*0)),(3*pi',\_-&gt;(+1))]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;reconfig&quot;]} $ reconfig11 sf s1
</code></strong>Dumped reconfig in ./fig
[&quot;./fig/reconfig.dat&quot;]
</pre></div></div><div class="top"><p class="src"><a id="v:constant2" class="def">constant2</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#constant2" class="link">Source</a> <a href="#v:constant2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1, b2)</td><td class="doc"><p>values to be repeated</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A generator for a constant signal. As compared with the
 <code><a href="ForSyDe-Atom-MoC-SY.html#v:constant2" title="ForSyDe.Atom.MoC.SY">constant2</a></code>, it just constructs an infinite
 signal with constant value (i.e. a signal with one event starting
 from time 0).</p><p>Constructors: <code>constant[1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ctsig = constant1 2 :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;constant&quot;]} ctsig
</code></strong>Dumped constant in ./fig
[&quot;./fig/constant.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-constant.png" /></p></div></div><div class="top"><p class="src"><a id="v:infinite2" class="def">infinite2</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#infinite2" class="link">Source</a> <a href="#v:infinite2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (tm -&gt; b1, tm -&gt; b2)</td><td class="doc"><p>values to be repeated</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A generator for an infinite signal. Similar to <code><a href="ForSyDe-Atom-MoC-CT.html#v:constant2" title="ForSyDe.Atom.MoC.CT">constant2</a></code>.</p><p>Constructors: <code>infinite[1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (inf1, inf2) = infinite2 (sin', cos') :: (Signal Time, Signal Time)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepareL cfg {labels=[&quot;infinite2-1&quot;, &quot;infinite2-2&quot;]} [inf1, inf2]
</code></strong>Dumped infinite2-1, infinite2-2 in ./fig
[&quot;./fig/infinite2-1.dat&quot;,&quot;./fig/infinite2-2.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-infinite.png" /></p></div></div><div class="top"><p class="src"><a id="v:generate2" class="def">generate2</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#generate2" class="link">Source</a> <a href="#v:generate2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; (b1, b2))</td><td class="doc"><p>function to generate next value</p></td></tr><tr><td class="src">-&gt; ((ts, tm -&gt; b1), (ts, tm -&gt; b2))</td><td class="doc"><p>kernel values tupled with their generation rate.</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A signal generator based on a function and a kernel value. It
 is actually an instantiation of the <code>stated0X</code> constructor
 (check <code><a href="ForSyDe-Atom-MoC.html#v:stated22" title="ForSyDe.Atom.MoC">stated22</a></code>).</p><p>Constructors: <code>generate[1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { osc 0 = 1 ; osc 1 = 0 }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sg = generate1 osc (pi', \_-&gt;0) :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;generate&quot;]} sg
</code></strong>Dumped generate in ./fig
[&quot;./fig/generate.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-generate.png" /></p><p>Another example simulating an RC oscillator:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let vs = 2                                -- Vs : supply voltage
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let r  = 100                              -- R : resistance
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let c  = 0.0005                           -- C : capacitance
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let vc t = vs * (1 - exp' (-t / (r * c))) -- Vc(t) : voltage charging through capacitor
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ns v = vs + (-1 * v)                  -- next state : charging / discharging
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let rcOsc = generate1 ns (milisec 500, vc)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;rcosc&quot;]} $ rcOsc
</code></strong>Dumped rcosc in ./fig
[&quot;./fig/rcosc.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-generate1.png" /></p></div></div><div class="top"><p class="src"><a id="v:stated22" class="def">stated22</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#stated22" class="link">Source</a> <a href="#v:stated22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; ((ts, tm -&gt; b1), (ts, tm -&gt; b2))</td><td class="doc"><p>initial state values tupled with their initial delay</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>stated</code> is a state machine without an output decoder. It is an
 instantiation of the <code>state</code> MoC constructor (see
 <code><a href="ForSyDe-Atom-MoC.html#v:stated22" title="ForSyDe.Atom.MoC">stated22</a></code>).</p><p>Constructors: <code>stated[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { osc 0 a = a; osc _ a = 0 }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [(0,\_-&gt;1), (6,\_-&gt;0)] :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;stated&quot;]} $ stated11 osc (1,\_-&gt;0) s1
</code></strong>Dumped stated in ./fig
[&quot;./fig/stated.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-stated.png" /></p></div></div><div class="top"><p class="src"><a id="v:state22" class="def">state22</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#state22" class="link">Source</a> <a href="#v:state22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; ((ts, tm -&gt; b1), (ts, tm -&gt; b2))</td><td class="doc"><p>initial state values tupled with their initial delay</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>state</code> is a state machine without an output decoder, and the
 state non-transparent. It is an instantiation of the <code>state</code> MoC
 constructor (see <code><a href="ForSyDe-Atom-MoC.html#v:state22" title="ForSyDe.Atom.MoC">state22</a></code>).</p><p>Constructors: <code>state[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { osc 0 a = a; osc _ a = 0 }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [(0,\_-&gt;1), (6,\_-&gt;0)] :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;state&quot;]} $ state11 osc (1,\_-&gt;0) s1
</code></strong>Dumped state in ./fig
[&quot;./fig/state.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-state.png" />                   </p></div></div><div class="top"><p class="src"><a id="v:moore22" class="def">moore22</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#moore22" class="link">Source</a> <a href="#v:moore22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; (b1, b2))</td><td class="doc"><p>output decoder</p></td></tr><tr><td class="src">-&gt; (ts, tm -&gt; st)</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>moore</code> processes model Moore state machines. It is an
 instantiation of the <code>moore</code> MoC constructor (see
 <code><a href="ForSyDe-Atom-MoC.html#v:moore22" title="ForSyDe.Atom.MoC">moore22</a></code>).</p><p>Constructors: <code>moore[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { osc 0 a = a; osc _ a = 0 }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [(0,\_-&gt;1), (6,\_-&gt;0)] :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;moore&quot;]} $ moore11 osc (*3) (1,\_-&gt;0) s1
</code></strong>Dumped moore in ./fig
[&quot;./fig/moore.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-moore.png" />          </p></div></div><div class="top"><p class="src"><a id="v:mealy22" class="def">mealy22</a> <a href="src/ForSyDe.Atom.MoC.CT.Lib.html#mealy22" class="link">Source</a> <a href="#v:mealy22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>outpt decoder</p></td></tr><tr><td class="src">-&gt; (ts, tm -&gt; st)</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b1, <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>mealy</code> processes model Mealy state machines. It is an
 instantiation of the <code>mealy</code> MoC constructor
 (see <code><a href="ForSyDe-Atom-MoC.html#v:mealy22" title="ForSyDe.Atom.MoC">mealy22</a></code>).</p><p>Constructors: <code>mealy[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { osc (-1) _ = 1; osc 1 _ = (-1) }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = infinite sin'
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>dumpDat $ prepare cfg {labels=[&quot;mealy&quot;]} $ mealy11 osc (*) (pi',\_-&gt;1) s1
</code></strong>Dumped mealy in ./fig
[&quot;./fig/mealy.dat&quot;]
</pre><p><img src="fig/moc-ct-pattern-mealy.png" /></p></div></div><a href="#g:5" id="g:5"><h2>Interfaces</h2></a><div class="top"><p class="src"><a id="v:toDE1" class="def">toDE1</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts (tm -&gt; a) <a href="src/ForSyDe.Atom.MoC.CT.Interface.html#toDE1" class="link">Source</a> <a href="#v:toDE1" class="selflink">#</a></p><div class="doc"><p>Translates a (set of) <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> signal(s) into
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> semantics without loss of information. In
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code>, the abstract function of time inferred by
 the <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> event loses its abstraction and it is
 &quot;dropped&quot; to explicit form, under a lower layer. In other words the
 implicit time semantics are lost, the carried value simply becoming
 an ordinary function.</p><p>Constructors: <code>toDE[1-4]</code>.</p><p><img src="fig/moc-ct-tode.png" /></p></div></div><div class="top"><p class="src"><a id="v:sampDE2" class="def">sampDE2</a> <a href="src/ForSyDe.Atom.MoC.CT.Interface.html#sampDE2" class="link">Source</a> <a href="#v:sampDE2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts t</td><td class="doc"><p><code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> timestamp carrier </p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a</td><td class="doc"><p><code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> input</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm b</td><td class="doc"><p><code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> input</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts a, <a href="ForSyDe-Atom-MoC-DE.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE">SignalBase</a> ts b)</td><td class="doc"><p><code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> outputs</p></td></tr></table></div><div class="doc"><p>Synchronizes a (set of) <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT" title="ForSyDe.Atom.MoC.CT">CT</a></code> signal(s) with a
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> carrier which holds the timestamps at
 which the CT signal must be sampled, and outputs the respective
 (set of) <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> signal(s).</p><p>Constructors: <code>sampDE[1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = CT.infinite (fromRational . sin')
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let c = DE.generate1 id (pi'/2, 1)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 6 $ sampDE1 c s
</code></strong>{0.0@0.0,1.0@1.5707963267948966,1.2246489323228883e-16@3.141592653589793,-1.0@4.71238898038469,0.0@6.283185307179586,1.0@7.853981633974483}
</pre></div></div><div class="top"><p class="src"><a id="v:zipx" class="def">zipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a) -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) <a href="src/ForSyDe.Atom.MoC.CT.Interface.html#zipx" class="link">Source</a> <a href="#v:zipx" class="selflink">#</a></p><div class="doc"><p>Synchronizes all the signals contained by a vector and zips them
 into one signal of vectors. It instantiates the
 <code><a href="ForSyDe-Atom-Skel-Vector.html#v:zipx" title="ForSyDe.Atom.Skel.Vector">zipx</a></code> skeleton.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = CT.signal [(0,const 1), (2,const 2), (6,const 3)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = CT.signal [(0,const 1), (2,const 2), (4,const 3)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [s1,s1,s2,s2]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>zipx v1
</code></strong>{&lt;1,1,1,1&gt;@0,&lt;2,2,2,2&gt;@2,&lt;2,2,3,3&gt;@4,&lt;3,3,3,3&gt;@6}
</pre><p>See <code><a href="ForSyDe-Atom-MoC-DE.html#v:zipx" title="ForSyDe.Atom.MoC.DE">zipx</a></code> from the <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a>
 library for a comprehensive visual example.</p></div></div><div class="top"><p class="src"><a id="v:unzipx" class="def">unzipx</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a) <a href="src/ForSyDe.Atom.MoC.CT.Interface.html#unzipx" class="link">Source</a> <a href="#v:unzipx" class="selflink">#</a></p><div class="doc"><p>Unzips the vectors carried by a signal into a vector of
 signals. It instantiates the <code><a href="ForSyCt-Atom-Skel-Vector.html#v:unzipx" title="ForSyCt.Atom.Skel.Vector">unzipx</a></code>
 skeleton. To avoid infinite recurrence, the user needs to provict
 the length of the output vector.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [1,2,3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = CT.signal [(0,const v1),(2,const v1),(6,const v1)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unzipx 4 s1
</code></strong>&lt;{4@0,4@2,4@6},{3@0,3@2,3@6},{2@0,2@2,2@6},{1@0,1@2,1@6}&gt;
</pre><p>See <code><a href="ForSyDe-Atom-MoC-DE.html#v:unzipx" title="ForSyDe.Atom.MoC.DE">unzipx</a></code> from the <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a>
 library for a comprehensive visual example.</p></div></div><div class="top"><p class="src"><a id="v:unzipx-39-" class="def">unzipx'</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> ts, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> tm, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> tm) =&gt; <a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm (<a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skel-Vector.html#t:Vector" title="ForSyDe.Atom.Skel.Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-CT.html#t:SignalBase" title="ForSyDe.Atom.MoC.CT">SignalBase</a> ts tm a) <a href="src/ForSyDe.Atom.MoC.CT.Interface.html#unzipx%27" class="link">Source</a> <a href="#v:unzipx-39-" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="ForSyDe-Atom-MoC-CT.html#v:unzipx" title="ForSyDe.Atom.MoC.CT">unzipx</a></code>, but &quot;sniffs&quot; the first event to determine the
 length of the output vector. Has unsafe behavior!</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [1,2,3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = CT.signal [(0,const v1),(2,const v1),(6,const v1)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unzipx' s1
</code></strong>&lt;{4@0,4@2,4@6},{3@0,3@2,3@6},{2@0,2@2,2@6},{1@0,1@2,1@6}&gt;
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>