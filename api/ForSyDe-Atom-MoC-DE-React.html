<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ForSyDe.Atom.MoC.DE.React</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">forsyde-atom-0.3.0.0: Shallow-embedded DSL for modeling cyber-physical systems </span><ul class="links" id="page-menu"><li><a href="src/ForSyDe.Atom.MoC.DE.React.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li><li><a href="https://forsyde.github.io/forsyde-atom/">Back to ForSyDe Web</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu 2020</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr><tr><th>Extensions</th><td>PostfixOperators</td></tr></table><p class="caption">ForSyDe.Atom.MoC.DE.React</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Aliases &amp; utilities</a></li><li><a href="#g:2">Process Constuctors</a><ul><li><a href="#g:3">Simple</a></li><li><a href="#g:4">Interfaces</a></li></ul></li><li><a href="#g:5">Lingua Franca constructs</a><ul><li><a href="#g:6">Clock Generators</a></li><li><a href="#g:7">Delayed Actions</a></li><li><a href="#g:8">Reactions</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This is an experimental library implementing the atoms and a set of specific
 patterns for representing the discrete event model of computation
 <a href="ForSyDe-Atom.html#cassandras09">[Cassandras09]</a>. One main source of inspiration for
 this MoC execution model is the <em>reactor model</em>
 <a href="ForSyDe-Atom.html#lohstroh19">[Lohstroh19]</a>, hence the abbreviation <code><a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a></code>.</p><p><a id="detector"></a> This module exports a more liberal interpretation of DE than
 <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a>, where events are considered non-persistent,
 i.e. &quot;instantaneous&quot;. Unambiguous behaviors for processes can be achieved by virtue
 of pattern-matching agains the presence/absence of events at different input ports
 at specific time instants (see API examples). This type of behavior implies a
 dynamic/adaptive rate of consuming and producing events in streams, hence
 internally each <code><a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a></code> process is a <em>detector</em>-<em>kernel</em> pair along the lines of
 <a href="ForSyDe-Atom-MoC-SDF-SADF.html">ForSyDe.Atom.MoC.SDF.SADF</a>, as shown in the picture below. In this representation
 the detector monitors the tags of each incoming event and for each &quot;earliest event&quot;
 it sets the execution context <span class="mathjax">\(\Gamma\)</span> dictating the event consumption rate of
 the kernel, here implemented using <code><a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a></code> atoms.</p><p><img src="fig/moc-re-principle.png" /></p><p>Useful pointers:</p><ul><li><a href="ForSyDe-Atom.html">ForSyDe.Atom</a> contains general guidelines for using the API</li><li><a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a> documents details about the internals of the MoC layer, the
   atoms and the basic structure of all process constructors as MoC patterns.</li><li><a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a> contains a conservative DE language where events are
   treated as persistent, each new event is triggering a new action seen on all
   outputs.</li><li>the <a href="ForSyDe-Atom.html#naming_conv">naming convention</a> rules on how to interpret
   the function names based on their number of inputs and outputs.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:RE">RE</a> t a <span class="keyword">where</span><ul class="subs"><li><a href="#v:RE">RE</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; {..} -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Signal">Signal</a> a = <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a> a</li><li class="src short"><span class="keyword">type</span> <a href="#t:SignalBase">SignalBase</a> t a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a)</li><li class="src short"><a href="#v:unit2">unit2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; ((t, a1), (t, a2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2)</li><li class="src short"><a href="#v:instant">instant</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</li><li class="src short"><a href="#v:until">until</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; t -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</li><li class="src short"><a href="#v:signal">signal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; [(t, a)] -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</li><li class="src short"><a href="#v:checkSignal">checkSignal</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t =&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a)</li><li class="src short"><a href="#v:readSignal">readSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</li><li class="src short"><a href="#v:delay">delay</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; t -&gt; a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</li><li class="src short"><a href="#v:delay-39-">delay'</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</li><li class="src short"><a href="#v:unsafeDelay">unsafeDelay</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; t -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</li><li class="src short"><a href="#v:comb22">comb22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; ([a1] -&gt; [a2] -&gt; ([b1], [b2])) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:generate2">generate2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; ([b1] -&gt; [b2] -&gt; ([b1], [b2])) -&gt; ((t, b1), (t, b2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:state22">state22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (b1 -&gt; b2 -&gt; [a1] -&gt; [a2] -&gt; (b1, b2)) -&gt; (b1, b2) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:stated22">stated22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (b1 -&gt; b2 -&gt; [a1] -&gt; [a2] -&gt; (b1, b2)) -&gt; (b1, b2) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:moore22">moore22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (st -&gt; [a1] -&gt; [a2] -&gt; st) -&gt; (st -&gt; ([b1], [b2])) -&gt; st -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:mealy22">mealy22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (st -&gt; [a1] -&gt; [a2] -&gt; st) -&gt; (st -&gt; [a1] -&gt; [a2] -&gt; ([b1], [b2])) -&gt; st -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:syncAndHold2">syncAndHold2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (b1, b2) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:syncAndFill2">syncAndFill2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (b1, b2) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:syncAndObs11">syncAndObs11</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; b2 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:toDE2">toDE2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f1, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f2) =&gt; f1 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t1 a1) -&gt; f2 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t2 a2) -&gt; (f1 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t1 a1), f2 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t2 a2))</li><li class="src short"><a href="#v:fromDE2">fromDE2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f1, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f2) =&gt; f1 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t1 a1) -&gt; f2 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t2 a2) -&gt; (f1 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t1 a1), f2 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t2 a2))</li><li class="src short"><a href="#v:toSYC2">toSYC2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b -&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> t, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b)</li><li class="src short"><a href="#v:fromSYC2">fromSYC2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> t -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b)</li><li class="src short"><a href="#v:embedSY22">embedSY22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li><li class="src short"><a href="#v:timer0">timer0</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> ()</li><li class="src short"><a href="#v:timer">timer</a> :: <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> ()</li><li class="src short"><a href="#v:timer-39-">timer'</a> :: <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a> -&gt; <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> ()</li><li class="src short"><a href="#v:actionD">actionD</a> :: <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> a</li><li class="src short"><a href="#v:states2inputs2">states2inputs2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (b3, b4) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b3 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b4 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b3, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b4)</li><li class="src short"><a href="#v:reaction22">reaction22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; ([a1] -&gt; [a2] -&gt; ([b1], [b2])) -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2) -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="doc"><p>The definitions of the DE MoC are the same as the ones presented in the
 <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a> module, however this library implements a non-conservative
 interpretation of this MoC, more appropriate to model timed computing
 applicatios. In this sense signals are carrying &quot;instant&quot;, non-persistent
 events. The user is then responsible to define how the process should react in
 case new events exist or not at any of the input ports, respectively if the
 process reacts at all. This is done by pattern-matching the functions passed as
 arguments: at any evaluation instant, a process passes to its function either
 singleton lists <code>[x]</code> if new events exist at a particular input port for a
 particular timestamp, respectively empty lists <code>[]</code> if no event has triggered the
 respective port. This modeling style gives rise to two new very important
 notions. For any process <span class="mathjax">\(p(si^m)=so^n\)</span> we say that:</p><ul><li>an input signal <span class="mathjax">\(si_i\)</span> is associated with a <em>triggering port</em> with respect to
   an output signal <span class="mathjax">\(so_j\)</span> if <span class="mathjax">\(\forall e_i\in si_i, \exists e_o\in so_j\)</span>,
   i.e. every event observed on the input port associated with <span class="mathjax">\(si_i\)</span> triggers a
   reaction observed in <span class="mathjax">\(so_j\)</span>. Using the <a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a> API we can
   model this along the lines of:</li></ul><pre>(...,so_j,...) = p f ... si_i ...
  where f ... [a_i] ... = (...,[b_j],...)</pre><ul><li>an input signal <span class="mathjax">\(si_i\)</span> is associated with a <em>non-triggering</em> or <em>observing</em>
   <em>port</em> with respect to an output signal <span class="mathjax">\(so_j\)</span> if (forall e_iin si_i,
   nexists e_oin so_j), i.e. there exist events observed on the input port
   associated with <span class="mathjax">\(si_i\)</span> which do not trigger a reaction observable in 
   <span class="mathjax">\(so_j\)</span>. Using the <a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a> API we can model this along the
   lines of:</li></ul><pre>(...,so_j,...) = p f ... si_i ...
  where f ... [a_i] ... = (...,[],...)</pre><p>The non-triggering behavior has deep implications and needs to be treated with
 care especially when considering feedback loops, as it violates the
 &quot;non-cleaning&quot; rule imposed by the host <code><a href="ForSyDe-Atom-MoC.html#v:Stream" title="ForSyDe.Atom.MoC">Stream</a></code>. In the picture
 below you see an example behavior of a <code><a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a></code> process where both inputs are
 triggering, and function <span class="mathjax">\(\Sigma\)</span> <code>a b = [sum a + sum b]</code>.</p><p><img src="fig/moc-re-example.png" /></p><p>In this example, if only the first signal is triggering, i.e.</p><pre>f [a] b = [a + sum b]
f _   _ = []</pre><p>then</p><p><img src="fig/moc-re-example2.png" /></p><p>A conservative variant of the DE MoC is in <a href="ForSyDe-Atom-MoC-DE-React.html">ForSyDe.Atom.MoC.DE.React</a>. Below are
 stated a few particularities of this DE MoC implementation:</p><ol><li>As compared to <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a> this MoC is also one-sided, but time
    <span class="mathjax">\(0\)</span> is not necessarily the global start any longer, because there exists the
    notion of &quot;absent&quot; event. Tags in a signal still need to be strictly
    incremental, but a signal can start at any timestamp, including negative ones.</li><li>since events are non-persistent, they are considered to be &quot;lost&quot;, or
    discarded after they happen, and a process is not allowed to &quot;go back in time&quot;
    to retrieve them. Persistent behaviors can be modeled in this MoC with
    e.g. buffer patterns, see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:syncAndHold2" title="ForSyDe.Atom.MoC.DE.React">syncAndHold2</a></code>.</li><li>a safe <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:delay" title="ForSyDe.Atom.MoC.DE.React">delay</a></code> is still considered one which both prepends
    <code><a href="ForSyDe-Atom-MoC.html#v:-45--60--45-" title="ForSyDe.Atom.MoC">-&lt;-</a></code> (i.e. generating a new value) and a phase shifts
    <code><a href="ForSyDe-Atom-MoC.html#v:-45--38--45-" title="ForSyDe.Atom.MoC">-&amp;-</a></code> (i.e. advancing time with a positive integer). However,
    since we are not restricted to start from global <span class="mathjax">\(0\)</span> any longer, we can also
    use an <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:unsafeDelay" title="ForSyDe.Atom.MoC.DE.React">unsafeDelay</a></code> variant. This process is named so because it does not
    have a prepend behavior, which means that is <em>never</em> allowed to be part of any
    feedback datapath, otherwise it causes a simulation deadlock.</li><li>also because events are non-persistent, <em>as a design choice, stateful</em>
    <em>processes that involve feedback pattern (see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:state22" title="ForSyDe.Atom.MoC.DE.React">state22</a></code>, <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:stated22" title="ForSyDe.Atom.MoC.DE.React">stated22</a></code>,</em>
    <em><code><a href="ForSyDe-Atom-MoC-DE-React.html#v:moore22" title="ForSyDe.Atom.MoC.DE.React">moore22</a></code>, <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:mealy22" title="ForSyDe.Atom.MoC.DE.React">mealy22</a></code>) do not expose oscillating behavior</em>, but rather an
    instantaneous one (i.e. they embed a <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> behavior).</li><li>since signal cleaning behavior is possible, it might cause unexpected
    deadlocks, and should be avoided altogether. However, if this situation cannot
    be avoided, the designer should take <em>special care</em> to enforce the following
    rule: <em>all ports involved in a feedback loop's datapath need to be</em>
    <em>triggering, and pass through at lease one safe <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:delay" title="ForSyDe.Atom.MoC.DE.React">delay</a></code></em>.</li><li>any signal from outside needs to be sane ( <span class="mathjax">\(T\)</span> must be a total order) before
    being injected into a ForSyDe process network. Helper functions are equipped
    with sanity checkers. Inside a ForSyDe process network, transformations are
    monotonic, thus output signals are guaranteed to be sane.</li><li>Since the execution of a process is dictated by the arrival of events, then
    the <code><a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a></code> atoms require the triggering information as a set of Booleans passed
    through the <a href="ForSyDe-Atom-MoC.html#context">execution context</a>: <span class="mathjax">\[
    \Gamma\vdash\alpha\rightarrow\beta =
    [\mathtt{Bool}]\times([\alpha]\rightarrow[\beta]) \]</span> This context however does
    not need to be touched by the user of this API, but rather is taken care of by
    the <a href="#detector">detector pattern</a>.</li></ol></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:RE" class="def">RE</a> t a <span class="keyword">where</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#RE" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></p><div class="doc"><p>The reactor-like DE event, defined exactly like its <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code>
 predecessor, and identifying a discrete event signal. The type of the tag system
 needs to satisfy all of the three properties, as suggested by the type constraints
 imposed on it:</p><ul><li>it needs to be a numerical type and every representable number needs to have an
   additive inverse.</li><li>it needs to be unambiguously comparable (defines a total order).</li><li>it needs to unambiguously define an equality operation.</li></ul><p>Due to these properties not all numerical types can represent DE tags. A typical
 example of inappropriate representation is <code><a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:RE" class="def">RE</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t)</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src">=&gt; { <a id="v:tag" class="def">tag</a> :: t</dfn><div class="doc"><p>timestamp</p></div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;, <a id="v:val" class="def">val</a> :: a</dfn><div class="doc"><p>the value</p></div></li><li><dfn class="src">&nbsp;&nbsp;&nbsp;} -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:RE">Instances</h4><details id="i:RE" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Functor:1"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t)</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-79" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc"><p>Allows for mapping of functions on a RE event.</p></td></tr><tr><td colspan="2"><details id="i:id:RE:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Applicative:2"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t)</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-83" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc"><p>Allows for lifting functions on a pair of RE events.</p></td></tr><tr><td colspan="2"><details id="i:id:RE:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t (a -&gt; b) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:MoC:3"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-MoC.html#t:MoC" title="ForSyDe.Atom.MoC">MoC</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t)</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-47" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:RE:MoC:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) a b <a href="src/ForSyDe.Atom.MoC.html#Fun" class="link">Source</a> <a href="#t:Fun" class="selflink">#</a></p><p class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) b <a href="src/ForSyDe.Atom.MoC.html#Ret" class="link">Source</a> <a href="#t:Ret" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-45-.-45-">(-.-)</a> :: <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) a b -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b) <a href="src/ForSyDe.Atom.MoC.html#-.-" class="link">Source</a> <a href="#v:-45-.-45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--42--45-">(-*-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t (<a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) a b)) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b) <a href="src/ForSyDe.Atom.MoC.html#-%2A-" class="link">Source</a> <a href="#v:-45--42--45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--42-">(-*)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t (<a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) b)) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t b) <a href="src/ForSyDe.Atom.MoC.html#-%2A" class="link">Source</a> <a href="#v:-45--42-" class="selflink">#</a></p><p class="src"><a href="#v:-45--60--45-">(-&lt;-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) <a href="src/ForSyDe.Atom.MoC.html#-%3C-" class="link">Source</a> <a href="#v:-45--60--45-" class="selflink">#</a></p><p class="src"><a href="#v:-45--38--45-">(-&amp;-)</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) <a href="src/ForSyDe.Atom.MoC.html#-%26-" class="link">Source</a> <a href="#v:-45--38--45-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Eq:4"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a)</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-45" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:RE:Eq:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Read:5"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a)</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-73" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc"><p>Reads the string of type <code>v@t</code> as an event <code>RE t v</code>.</p></td></tr><tr><td colspan="2"><details id="i:id:RE:Read:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) <a href="#v:readsPrec" class="selflink">#</a></p><p class="src"><a href="#v:readList">readList</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> [<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a] <a href="#v:readList" class="selflink">#</a></p><p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) <a href="#v:readPrec" class="selflink">#</a></p><p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a] <a href="#v:readListPrec" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Show:6"></span> (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a)</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-69" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc"><p>Shows the event with tag <code>t</code> and value <code>v</code> as <code>v@t</code>.</p></td></tr><tr><td colspan="2"><details id="i:id:RE:Show:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a] -&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Plot:7"></span> (<a href="ForSyDe-Atom-Utility-Plot.html#t:Plottable" title="ForSyDe.Atom.Utility.Plot">Plottable</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Real" title="Prelude">Real</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> t) =&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Plot" title="ForSyDe.Atom.Utility.Plot">Plot</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a)</span> <a href="src/ForSyDe.Atom.Utility.Plot.html#line-255" class="link">Source</a> <a href="#t:Plot" class="selflink">#</a></td><td class="doc"><p>For plotting <code><a href="ForSyDe-Atom-MoC-RE-React.html#v:RE" title="ForSyDe.Atom.MoC.RE.React">RE</a></code> signals.</p></td></tr><tr><td colspan="2"><details id="i:id:RE:Plot:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:sample">sample</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Samples" title="ForSyDe.Atom.Utility.Plot">Samples</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#sample" class="link">Source</a> <a href="#v:sample" class="selflink">#</a></p><p class="src"><a href="#v:sample-39-">sample'</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:Samples" title="ForSyDe.Atom.Utility.Plot">Samples</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#sample%27" class="link">Source</a> <a href="#v:sample-39-" class="selflink">#</a></p><p class="src"><a href="#v:takeUntil">takeUntil</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a <a href="src/ForSyDe.Atom.Utility.Plot.html#takeUntil" class="link">Source</a> <a href="#v:takeUntil" class="selflink">#</a></p><p class="src"><a href="#v:getInfo">getInfo</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-Utility-Plot.html#t:PInfo" title="ForSyDe.Atom.Utility.Plot">PInfo</a> <a href="src/ForSyDe.Atom.Utility.Plot.html#getInfo" class="link">Source</a> <a href="#v:getInfo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Ret:8"></span> <span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) b</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-49" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:RE:Ret:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret" title="ForSyDe.Atom.MoC">Ret</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) b = ((), [b])</div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:RE:Fun:9"></span> <span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) a b</span> <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#line-48" class="link">Source</a> <a href="#t:RE" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:RE:Fun:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="ForSyDe-Atom-MoC-DE-React-Core.html">ForSyDe.Atom.MoC.DE.React.Core</a></p> <div class="src"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun" title="ForSyDe.Atom.MoC">Fun</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t) a b = (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>, [a] -&gt; b)</div></details></td></tr></table></details></div></div><a href="#g:1" id="g:1"><h1>Aliases &amp; utilities</h1></a><div class="doc"><p>These are type synonyms and utilities provided for user convenience. They
 mainly concern the construction and usage of signals.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Signal" class="def">Signal</a> a = <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a> a <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#Signal" class="link">Source</a> <a href="#t:Signal" class="selflink">#</a></p><div class="doc"><p>Convenience alias for a DE signal, where tags are represented using our exported
 <code><a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a></code> type.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SignalBase" class="def">SignalBase</a> t a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#SignalBase" class="link">Source</a> <a href="#t:SignalBase" class="selflink">#</a></p><div class="doc"><p>Type synonym for a base DE signal as a stream of <code>DE</code> events, where the type of
 tags has not been determined yet. In designs, it is advised to define a type alias
 for signals, using an appropriate numerical type for tags, e.g.</p><pre>import ForSyDe.Atom.MoC.DE.React hiding (Signal) -- hide provided alias, to use your own

type Signal a = SignalBase Int a</pre></div></div><div class="top"><p class="src"><a id="v:unit2" class="def">unit2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; ((t, a1), (t, a2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2) <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#unit2" class="link">Source</a> <a href="#v:unit2" class="selflink">#</a></p><div class="doc"><p>Wraps a (tuple of) pair(s) <code>(tag, value)</code> into the equivalent unit signal(s). A
 unit signal is a signal with one event with the period <code>tag</code> carrying <code>value</code>,
 starting at tag 0.</p><p>Helpers: <code>unit</code> and <code>unit[2-4]</code>.</p></div></div><div class="top"><p class="src"><a id="v:instant" class="def">instant</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#instant" class="link">Source</a> <a href="#v:instant" class="selflink">#</a></p><div class="doc"><p>Creates a signal with an instant event at time 0.</p></div></div><div class="top"><p class="src"><a id="v:until" class="def">until</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; t -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#until" class="link">Source</a> <a href="#v:until" class="selflink">#</a></p><div class="doc"><p>Takes the first part of the signal util a given timestamp. The last event of the
 resulting signal is at the given timestamp and carries the previous value. This
 utility is useful when plotting a signal, to specify the interval of plotting.</p></div></div><div class="top"><p class="src"><a id="v:signal" class="def">signal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; [(t, a)] -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#signal" class="link">Source</a> <a href="#v:signal" class="selflink">#</a></p><div class="doc"><p>Transforms a list of tuples <code>(tag, value)</code> into a RE signal. Checks if it is
 well-formed.</p></div></div><div class="top"><p class="src"><a id="v:checkSignal" class="def">checkSignal</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t =&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t a) <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#checkSignal" class="link">Source</a> <a href="#v:checkSignal" class="selflink">#</a></p><div class="doc"><p>Checks if a signal is well-formed or not, according to the RE MoC
 interpretation in ForSyDe-Atom.</p></div></div><div class="top"><p class="src"><a id="v:readSignal" class="def">readSignal</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a <a href="src/ForSyDe.Atom.MoC.DE.React.Core.html#readSignal" class="link">Source</a> <a href="#v:readSignal" class="selflink">#</a></p><div class="doc"><p>Reads a signal from a string and checks if it is well-formed.  Like with the
 <code>read</code> function from <code>Prelude</code>, you must specify the type of the signal.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>readSignal &quot;{ 1@0, 2@2, 3@5, 4@7, 5@10 }&quot; :: Signal Int
</code></strong>{1@0s,2@2s,3@5s,4@7s,5@10s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>readSignal &quot;{ 1@1, 2@2, 3@5, 4@7, 5@10 }&quot; :: Signal Int
</code></strong>{1@1s,2@2s,3@5s,4@7s,5@10s}
</pre><p>Incorrect usage (not covered by <code>doctest</code>):</p><pre>&#955;&gt; readSignal &quot;{ 1@0, 2@2, 3@5, 4@10, 5@7 }&quot; :: Signal Int
{1@0s,2@2s,3@5s*** Exception: [MoC.RE] malformed signal</pre></div></div><a href="#g:2" id="g:2"><h1>Process Constuctors</h1></a><div class="doc"><p>These process constructors are re-interpretations of the atom patterns defined
 in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, using the <em>reactor</em> <code>comb</code> (see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:comb22" title="ForSyDe.Atom.MoC.DE.React">comb22</a></code>) presented
 <a href="#detector#">above</a>.</p></div><a href="#g:3" id="g:3"><h2>Simple</h2></a><div class="top"><p class="src"><a id="v:delay" class="def">delay</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#delay" class="link">Source</a> <a href="#v:delay" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; t</td><td class="doc"><p>time delay</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>The <code>delay</code> process &quot;delays&quot; a signal with one event, (see the
 <code><a href="ForSyDe-Atom-MoC.html#v:delay" title="ForSyDe.Atom.MoC">delay</a></code> pattern). Any delayed signal starts from global 0.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@2, 2@3, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay 3 0 s
</code></strong>{0@0s,1@5s,2@6s,3@9s,4@11s,5@12s}
</pre><p><img src="fig/moc-re-pattern-delay.png" /></p></div></div><div class="top"><p class="src"><a id="v:delay-39-" class="def">delay'</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#delay%27" class="link">Source</a> <a href="#v:delay-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>signal &quot;borrowing&quot; the initial event</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>Similar to the previous, but this is the raw instantiation of the
 <code><a href="ForSyDe-Atom-MoC.html#v:delay" title="ForSyDe.Atom.MoC">delay</a></code> pattern from <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>. It &quot;borrows&quot; the first
 event from one signal and appends it at the head of another signal.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@(-1), 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{3@2, 4@4, 5@5, 6@8, 7@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay' s1 s2
</code></strong>{1@-1s,3@5s,4@7s,5@8s,6@11s,7@12s}
</pre><p><img src="fig/moc-re-pattern-delayp.png" /></p></div></div><div class="top"><p class="src"><a id="v:unsafeDelay" class="def">unsafeDelay</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#unsafeDelay" class="link">Source</a> <a href="#v:unsafeDelay" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; t</td><td class="doc"><p>time delay</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>This process &quot;delays&quot; only the tags of a signal. The &quot;usafe&quot; prefix is a warning
 that it does not express prefix behavior (<code><a href="ForSyDe-Atom-MoC.html#v:-45--62--45-" title="ForSyDe.Atom.MoC">-&gt;-</a></code>), which means that
 in a feedback loop it will cause deadlock.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@(-1), 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unsafeDelay 3 s
</code></strong>{1@2s,2@5s,3@9s,4@11s,5@12s}
</pre><p><img src="fig/moc-re-pattern-udelay.png" /></p></div></div><div class="top"><p class="src"><a id="v:comb22" class="def">comb22</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#comb22" class="link">Source</a> <a href="#v:comb22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ([a1] -&gt; [a2] -&gt; ([b1], [b2]))</td><td class="doc"><p>function on values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>comb</code> processes map a trigger-aware combinational function on signals and take
 care of synchronization between input signals. </p><p>Constructors: <code>comb[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = instant 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: RE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb11 (map (+1)) s2
</code></strong>{2@0s,3@2s,4@6s,5@8s,6@9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let {f [a] [b] = ([a+b],[a-b]); f [a] []  = ([a],[a]); f [] [b]  = ([],[b]); f [] []  = ([],[])}
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb22 f s1 s2
</code></strong>({2@0s},{0@0s,2@2s,3@6s,4@8s,5@9s})
</pre><p><img src="fig/moc-re-pattern-comb.png" /></p></div></div><div class="top"><p class="src"><a id="v:generate2" class="def">generate2</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#generate2" class="link">Source</a> <a href="#v:generate2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ([b1] -&gt; [b2] -&gt; ([b1], [b2]))</td><td class="doc"><p>function to generate next value</p></td></tr><tr><td class="src">-&gt; ((t, b1), (t, b2))</td><td class="doc"><p>kernel values tupled with their generation rate.</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A signal generator based on a function and a kernel value. </p><p>Constructors: <code>generate[1-3]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ns a b = (map (+1) a,map (+2) b)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (s1,s2) = generate2 ns ((3,1),(1,2))
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 5 s1
</code></strong>{1@0,2@3,3@6,4@9,5@12}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 s2
</code></strong>{2@0,4@1,6@2,8@3,10@4,12@5,14@6}
</pre><p><img src="fig/moc-re-pattern-generate.png" /></p></div></div><div class="top"><p class="src"><a id="v:state22" class="def">state22</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#state22" class="link">Source</a> <a href="#v:state22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; [a1] -&gt; [a2] -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (b1, b2)</td><td class="doc"><p>initial state values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>state</code> is a state machine without an output decoder, which exports the next
 state. It reacts &quot;instantaneously&quot; with every triggering event, and has no
 oscillation behavior. Internally it embeds a clocked SY process (see
 <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:state22" title="ForSyDe.Atom.MoC.SY.Clocked">state22</a></code>).</p><p>Constructors: <code>state[1-3][1-3]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>state11 (\s [a] -&gt; s + a) 1 s
</code></strong>{2@1s,4@2s,7@6s,11@8s,16@9s}
</pre><p><img src="fig/moc-re-pattern-state.png" /></p></div></div><div class="top"><p class="src"><a id="v:stated22" class="def">stated22</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#stated22" class="link">Source</a> <a href="#v:stated22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1 -&gt; b2 -&gt; [a1] -&gt; [a2] -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (b1, b2)</td><td class="doc"><p>initial state values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>state</code> is a state machine without an output decoder, which exports the current
 state. It reacts &quot;instantaneously&quot; with every triggering event, and has no
 oscillation behavior. Internally it embeds a clocked SY process (see
 <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:stated22" title="ForSyDe.Atom.MoC.SY.Clocked">stated22</a></code>).</p><p>Constructors: <code>stated[1-3][1-3]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stated11 (\s [a] -&gt; s + a) 1 s
</code></strong>{1@1s,2@2s,4@6s,7@8s,11@9s}
</pre><p><img src="fig/moc-re-pattern-state.png" /></p></div></div><div class="top"><p class="src"><a id="v:moore22" class="def">moore22</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#moore22" class="link">Source</a> <a href="#v:moore22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (st -&gt; [a1] -&gt; [a2] -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; ([b1], [b2]))</td><td class="doc"><p>output decoder</p></td></tr><tr><td class="src">-&gt; st</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>moore</code> processes model Moore state machines. It reacts &quot;instantaneously&quot; with
 every triggering event, and has no oscillation behavior. Internally it embeds a
 clocked SY process (see <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:moore22" title="ForSyDe.Atom.MoC.SY.Clocked">moore22</a></code>).</p><p>Constructors: <code>moore[1-3][1-3]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { ns s [a] [b] = s+a+b; ns s [] [b] = s; ns _ _ _ = 0 }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let od s = [s + 1]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@2, 1@3, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>moore21 ns od 1 s1 s2
</code></strong>{2@1s,1@2s,4@3s,4@6s,10@8s,18@9s}
</pre><p><img src="fig/moc-re-pattern-moore.png" />          </p></div></div><div class="top"><p class="src"><a id="v:mealy22" class="def">mealy22</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#mealy22" class="link">Source</a> <a href="#v:mealy22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (st -&gt; [a1] -&gt; [a2] -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; [a1] -&gt; [a2] -&gt; ([b1], [b2]))</td><td class="doc"><p>outpt decoder</p></td></tr><tr><td class="src">-&gt; st</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>mealy</code> processes model Mealy state machines. It reacts &quot;instantaneously&quot; with
 every triggering event, and has no oscillation behavior. Internally it embeds a
 clocked SY process (see <code><a href="ForSyDe-Atom-MoC-SY-Clocked.html#v:mealy22" title="ForSyDe.Atom.MoC.SY.Clocked">mealy22</a></code>).</p><p>Constructors: <code>mealy[1-4][1-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { ns s [a] [b] = s+a+b; ns s [] [b] = s; ns _ _ _ = 0 }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let { od s [a] [b] = [s+a-b]; od s _ _ = [s] }
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@2, 1@3, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mealy21 ns od 1 s1 s2
</code></strong>{1@1s,1@2s,3@3s,3@6s,9@8s,17@9s}
</pre><p><img src="fig/moc-re-pattern-mealy.png" /></p></div></div><div class="top"><p class="src"><a id="v:syncAndHold2" class="def">syncAndHold2</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#syncAndHold2" class="link">Source</a> <a href="#v:syncAndHold2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1, b2)</td><td class="doc"><p>initial value(s), if no previous present event exists.</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Synchronizes <em>n</em> signals and for each absent event at a synchronization point, it
 holds the previous non-absent one.</p><p>Constructors: <code>syncAndHold[2-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{3@2, 4@4, 5@5, 6@8, 7@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (o1,o2) = syncAndHold2 (0,0) s1 s2
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>o1
</code></strong>{1@1s,2@2s,2@4s,2@5s,3@6s,4@8s,5@9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>o2
</code></strong>{0@1s,3@2s,4@4s,5@5s,5@6s,6@8s,7@9s}
</pre><p><img src="fig/moc-re-pattern-syncandhold.png" /></p></div></div><div class="top"><p class="src"><a id="v:syncAndFill2" class="def">syncAndFill2</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#syncAndFill2" class="link">Source</a> <a href="#v:syncAndFill2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (b1, b2)</td><td class="doc"><p>initial value(s), if no previous present event exists.</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Synchronizes <em>n</em> signals and for each absent event at a synchronization point, it
 replaces it with an arbitrary user-defined value.</p><p>Constructors: <code>syncAndFill[2-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{3@2, 4@4, 5@5, 6@8, 7@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (o1,o2) = syncAndFill2 (0,0) s1 s2
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>o1
</code></strong>{1@1s,2@2s,0@4s,0@5s,3@6s,4@8s,5@9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>o2
</code></strong>{0@1s,3@2s,4@4s,5@5s,0@6s,6@8s,7@9s}
</pre><p><img src="fig/moc-re-pattern-syncandfill.png" /></p></div></div><div class="top"><p class="src"><a id="v:syncAndObs11" class="def">syncAndObs11</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#syncAndObs11" class="link">Source</a> <a href="#v:syncAndObs11" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; b2</td><td class="doc"><p>initial value(s), if no previous present event exists.</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>syncAndObs</code><span class="mathjax">\(mn\)</span> synchronizes <span class="mathjax">\(m + n\)</span> signals where the first <span class="mathjax">\(m\)</span> are
 <em>triggering</em> signals and the last <span class="mathjax">\(n\)</span> <em>non-triggering</em> (observed) signals.</p><p>Constructors: <code>syncAndObs11</code>, <code>syncAndObs21</code>, <code>syncAndObs31</code>, <code>syncAndObs12</code>, <code>syncAndObs22</code>, <code>syncAndObs13</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{3@2, 4@4, 5@5, 6@8, 7@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (o1,o2) = syncAndObs11 0 s1 s2
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>o1
</code></strong>{1@1s,2@2s,3@6s,4@8s,5@9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>o2
</code></strong>{0@1s,3@2s,4@4s,5@5s,5@6s,6@8s,7@9s}
</pre><p><img src="fig/moc-re-pattern-syncandobs.png" /></p></div></div><a href="#g:4" id="g:4"><h2>Interfaces</h2></a><div class="top"><p class="src"><a id="v:toDE2" class="def">toDE2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f1, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f2) =&gt; f1 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t1 a1) -&gt; f2 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t2 a2) -&gt; (f1 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t1 a1), f2 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t2 a2)) <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#toDE2" class="link">Source</a> <a href="#v:toDE2" class="selflink">#</a></p><div class="doc"><p>Syntax-preserving transformation to the original conservative
 <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a> MoC. It is <strong>not</strong> semantics-preserving because &quot;instant&quot;
 events are re-interpreted as &quot;persistent&quot;.</p><p><strong>OBS:</strong> all input signals need to start from global time 0.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = RE.readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: RE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = RE.readSignal &quot;{1@0, 2@3, 3@4, 4@8, 5@10}&quot; :: RE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toDE2 s1 s2
</code></strong>({1@0s,2@2s,3@6s,4@8s,5@9s},{1@0s,2@3s,3@4s,4@8s,5@10s})
</pre><p><img src="fig/moc-re-pattern-tode.png" /></p></div></div><div class="top"><p class="src"><a id="v:fromDE2" class="def">fromDE2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f1, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f2) =&gt; f1 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t1 a1) -&gt; f2 (<a href="ForSyDe-Atom-MoC-DE.html#t:DE" title="ForSyDe.Atom.MoC.DE">DE</a> t2 a2) -&gt; (f1 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t1 a1), f2 (<a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a> t2 a2)) <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#fromDE2" class="link">Source</a> <a href="#v:fromDE2" class="selflink">#</a></p><div class="doc"><p>Syntax-preserving transformation from the original conservative
 <a href="ForSyDe-Atom-MoC-DE.html">ForSyDe.Atom.MoC.DE</a> MoC. It is <strong>not</strong> semantics-preserving because &quot;persistent&quot;
 events are re-interpreted as &quot;instant&quot;.</p><p><strong>OBS:</strong> all input signals will start at global time 0.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = DE.readSignal &quot;{1@0, 2@3, 3@4, 4@8, 5@10}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromDE2 s1 s2
</code></strong>({1@0s,2@2s,3@6s,4@8s,5@9s},{1@0s,2@3s,3@4s,4@8s,5@10s})
</pre><p><img src="fig/moc-re-pattern-fromde.png" /></p></div></div><div class="top"><p class="src"><a id="v:toSYC2" class="def">toSYC2</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#toSYC2" class="link">Source</a> <a href="#v:toSYC2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b</td><td class="doc"><p>second input DE signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> t, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b)</td><td class="doc"><p>signal carrying timestamps tupled with the two output
 <code><a href="ForSyDe-Atom-MoC-SYC.html#v:SY" title="ForSyDe.Atom.MoC.SYC">SY</a></code> signals</p></td></tr></table></div><div class="doc"><p>Semantics-preserving translation to <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> signals. At any
 synchronization instant, triggering events are wrapped into a
 <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Prst" title="ForSyDe.Atom.ExB.Absent">Prst</a></code> behavior, whereas absent ones are represented as
 <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Abst" title="ForSyDe.Atom.ExB.Absent">Abst</a></code>. The output signals are tupled with a (pure)
 <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> signal carrying the timestamps of the synchronization
 points.</p><p><strong>OBS:</strong> check the documentation of <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> for legal
 multi-clock rate interactions.</p><p>Constructors: <code>toSY[1-4]</code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = RE.instant 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = RE.readSignal &quot;{1@1, 2@2, 3@6, 4@8, 5@9}&quot; :: RE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toSYC2 s1 s2
</code></strong>({0s,1s,2s,6s,8s,9s},{1,&#10178;,&#10178;,&#10178;,&#10178;,&#10178;},{&#10178;,1,2,3,4,5})
</pre><p><img src="fig/moc-re-pattern-tosyc.png" /></p></div></div><div class="top"><p class="src"><a id="v:fromSYC2" class="def">fromSYC2</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#fromSYC2" class="link">Source</a> <a href="#v:fromSYC2" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="ForSyDe-Atom-MoC-SY.html#t:Signal" title="ForSyDe.Atom.MoC.SY">Signal</a> t</td><td class="doc"><p>SY signal carrying <code><a href="ForSyDe-Atom-MoC-RE.html#v:RE" title="ForSyDe.Atom.MoC.RE">RE</a></code> timestamps</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a</td><td class="doc"><p>first input SYC signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b</td><td class="doc"><p>second input SYC signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b)</td><td class="doc"><p>two output <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> signals</p></td></tr></table></div><div class="doc"><p>Semantics-preserving translation from <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> signals.
 <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Prst" title="ForSyDe.Atom.ExB.Absent">Prst</a></code> events are propagated, whereas
 <code><a href="ForSyDe-Atom-ExB-Absent.html#v:Abst" title="ForSyDe.Atom.ExB.Absent">Abst</a></code> ones are cleaned from the output. The first signal
 needs to be a (pure) <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> signal describing the timestamps of
 the synchronization points.</p><p><strong>OBS:</strong> This process has cleaning behavior. It needs to be avoided from the
 datapath of any feedback loop!</p><p>Constructors: <code>fromSY</code>, <code>fromSY2</code>, <code>fromSY3</code>, <code>fromSY4</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = SY.signal [0,3,4,6,9] :: SY.Signal DE.TimeStamp
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = SY.signal [Prst 1,Prst 2,Abst,Prst 4,Prst 5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromSYC1 s1 s2
</code></strong>{1@0s,2@3s,4@6s,5@9s}
</pre><p><img src="fig/moc-re-pattern-fromsyc.png" /></p></div></div><div class="top"><p class="src"><a id="v:embedSY22" class="def">embedSY22</a> <a href="src/ForSyDe.Atom.MoC.DE.React.Lib.html#embedSY22" class="link">Source</a> <a href="#v:embedSY22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY-Clocked.html#t:Signal" title="ForSyDe.Atom.MoC.SY.Clocked">Signal</a> b2))</td><td class="doc"><p><code><a href="ForSyDe-Atom-MoC-SY.html#v:SY" title="ForSyDe.Atom.MoC.SY">SY</a></code> process</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2</td><td class="doc"><p>second input DE signal </p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2)</td><td class="doc"><p>two output <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE" title="ForSyDe.Atom.MoC.DE">DE</a></code> signals</p></td></tr></table></div><div class="doc"><p>Embeds a <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> process inside a <code><a href="ForSyDe-Atom-MoC-RE.html#v:RE" title="ForSyDe.Atom.MoC.RE">RE</a></code>
 environment. Internally, it synchronizes the input signals, translates them to
 clocked SY (see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:toSYC2" title="ForSyDe.Atom.MoC.DE.React">toSYC2</a></code>), feeds them to a SY process and translates the result
 back to <code><a href="ForSyDe-Atom-MoC-RE.html#v:RE" title="ForSyDe.Atom.MoC.RE">RE</a></code> (see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:fromSYC2" title="ForSyDe.Atom.MoC.DE.React">fromSYC2</a></code>) using the same input tags. Seen
 from outside, this process behaves like a RE process with &quot;instantaneous response&quot;.</p><p>Constructors: <code>embedSY[1-4][1-4]</code>.</p><p>For the following example, see the difference between its output
 and the one of <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:stated22" title="ForSyDe.Atom.MoC.DE.React">stated22</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: RE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: RE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embedSY21 (SYC.stated21 (\s a b -&gt; a + b - s) 1) s1 s2
</code></strong>{1@0s,1@2s,3@6s,3@8s,5@9s}
</pre><p><img src="fig/moc-re-pattern-embedsy.png" /></p><p><strong>OBS:</strong> according to the <a href="ForSyDe-Atom-MoC-SY-Clocked.html">ForSyDe.Atom.MoC.SY.Clocked</a> MoC all inputs signals need
 to be sichronized (i.e. have the same clock rate), otherwise their interaction is
 illegal.</p><pre>&gt; let s1 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: RE.Signal Int
&gt; let s2 = readSignal &quot;{1@0, 2@2, 3@7, 4@8, 5@9}&quot; :: RE.Signal Int
&gt; embedSY21 (SYC.stated21 (\s a b -&gt; a + b - s) 1) s1 s2
 {1@0s,1@2s,3@6s,*** Exception: [ExB.Absent] Illegal occurrence of an absent and present event</pre></div></div><a href="#g:5" id="g:5"><h1>Lingua Franca constructs</h1></a><div class="doc"><p>This library also exports functions and helpers to re-create reactor networks
 from <a href="https://github.com/icyphy/lingua-franca">Lingua Franca</a> (LF) language
 <a href="ForSyDe-Atom.html#lohstroh19">[Lohstroh19]</a>, as ForSyDe process
 networks. Basically each expression in the LF language is given an equivalent
 ForSyDe <code><a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a></code> construct. Due to fundamental differences between the two languages
 (LF being a parsed language and ForSyDe an EDSL hosted on the strictly-typed pure
 functional programming language Haskell) the syntax and user experience in
 general is quite different between the two languages. The scope of this library
 is merely to provide an (executable) behavioral model of LF reactors for study
 purposes rather than imitate/replace LF. In particular each construct in the LF
 language is associated with a ForSyDe process constructor, and thus <code>reactor</code>
 definitions in LF are built as specific composite processes in ForSyDe.</p><p>According to  the <a href="https://github.com/icyphy/lingua-franca/wiki/Language-Specification">Language Reference wiki</a>
 this is how a <code>reactor</code> is defined in LF:</p><pre>reactor name (parameters) {
  state declarations
  input declarations
  output declarations
  timer declarations
  action declarations
  reaction declarations
   ...
}</pre><p>Here is how a reactor would be defined as a process network/composite process
 using this library, along the lines of:</p><pre>reactorName :: ParamTypes -&gt; InputSignalTypes ... -&gt; OutputSignalTypes ...
reactorName param inputS ... = (outputS, ...)
  where
    stateS      = stateP nextStateF initV {inputS|timerS|actionS} ...
    timerS      = clockP
    actionS     = actionP {reactionS|other_actionS} ... 
    reactionS   = reactionP reactF reactInS
      where syncS = statesXinputsY initV stateS ... {inputS|timerS|actionS} ...</pre><p>The pseudo-code above suggests the syntax and what kind of constructs a designer
 would use, to make a rough association between the ForSyDe-Reactors style and the
 LF-Reactors style. As with every functional program, the ForSyDe-Reactors
 processes are defined in an &quot;equational&quot; style. The elements in the pseudo-code
 denote:</p><ul><li>words between <code>{...|...}</code> represents what different choices of
 input/output arguments;</li><li>words with the <code>S</code> suffix suggest that these identifiers are signals; words
 with <code>P</code> suffix suggest that these identifiers are processes or process
 constructors; words with <code>F</code> suffix suggest that these are functions, and <code>V</code>
 values respectively;</li><li><code>stateP</code> are state modifiers, and should be stateful process constructors, see
 <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:state22" title="ForSyDe.Atom.MoC.DE.React">state22</a></code>, <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:stated22" title="ForSyDe.Atom.MoC.DE.React">stated22</a></code> <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:moore22" title="ForSyDe.Atom.MoC.DE.React">moore22</a></code>, <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:mealy22" title="ForSyDe.Atom.MoC.DE.React">mealy22</a></code>;</li><li><code>clockP</code> is a clock generator process, see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:timer0" title="ForSyDe.Atom.MoC.DE.React">timer0</a></code>, <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:timer" title="ForSyDe.Atom.MoC.DE.React">timer</a></code>, <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:timer-39-" title="ForSyDe.Atom.MoC.DE.React">timer'</a></code>;</li><li><code>actionP</code> might be an action &quot;delayer&quot; if the action is to be delayed, or
 simply a name binding if it is not to be delayed;</li><li><code>reactionP</code> is a combinational process constructor (see the <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:reaction22" title="ForSyDe.Atom.MoC.DE.React">reaction22</a></code>
 aliases), which operates on a set of <em>synchronized</em> signals, using the
 <code>statesXinputsY</code> utility (see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:states2inputs2" title="ForSyDe.Atom.MoC.DE.React">states2inputs2</a></code>). This utility manipulates the
 different signals inside a reactor as to denote which originate from internal
 state processes (i.e. values are persistent until the next state modifier action
 occurs) and other/input actions (i.e. events are instant, and values are lost
 after the event is consumed).</li></ul><p>Here is a simple example of how a LF reactor can be translated using this 
 library. Consider this LF code:</p><pre>reactor reactor1 (period:time) {
  input x:int;
  output y:int;
  timer t(period);
  state count:int(0);
  action a:int;
  reaction(t) -&gt; a {=
    (self-&gt;count)++;
    schedule(a, MSEC(200), self-&gt;count)
  =}
  reaction(a,x) -&gt; y {=
    set(y, a + x)
  =}
}</pre><p>The ForSyDe equivalent model for <code>reactor1</code> would be:</p><pre>reactor1 :: TimeStamp -&gt; Signal Int -&gt; Signal Int
reactor1 period x = y
  where
    t       = timer period
    count   = state11 (\s _ -&gt; s + 1) 0 t
    a       = actionD (milisec 200) count
    y       = reaction21 (\i1 i2 -&gt; [sum i1 + sum i2])
              $ states1inputs1 0 a x</pre><p>Executing the above reactor with a test input signal in the <code>ghci</code> interpreter
 gives you the output:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = read &quot;{1@0,2@3,3@6,4@10,5@13}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>simulate 11.2 $ reactor1 1 s2
</code></strong>0s	1
0.2s	1
1.2s	2
2.2s	3
3s	5
3.2s	4
4.2s	5
5.2s	6
6s	9
6.2s	7
7.2s	8
8.2s	9
9.2s	10
10s	14
10.2s	11
11.2s	12
</pre></div><a href="#g:6" id="g:6"><h2>Clock Generators</h2></a><div class="top"><p class="src"><a id="v:timer0" class="def">timer0</a> :: <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> () <a href="src/ForSyDe.Atom.MoC.DE.React.LF.html#timer0" class="link">Source</a> <a href="#v:timer0" class="selflink">#</a></p><div class="doc"><p>The equivalent of a timer set to period <code>0</code> in LF. It triggers once at the
 beginning of the execution and then it never triggers again.</p></div></div><div class="top"><p class="src"><a id="v:timer" class="def">timer</a> <a href="src/ForSyDe.Atom.MoC.DE.React.LF.html#timer" class="link">Source</a> <a href="#v:timer" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a></td><td class="doc"><p>period</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> ()</td><td class="doc"><p>timer signal</p></td></tr></table></div><div class="doc"><p>A timer signal generator</p></div></div><div class="top"><p class="src"><a id="v:timer-39-" class="def">timer'</a> <a href="src/ForSyDe.Atom.MoC.DE.React.LF.html#timer%27" class="link">Source</a> <a href="#v:timer-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a></td><td class="doc"><p>phase</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a></td><td class="doc"><p>period</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> ()</td><td class="doc"><p>timer signal</p></td></tr></table></div><div class="doc"><p>Like <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:timer" title="ForSyDe.Atom.MoC.DE.React">timer</a></code>, but you can specify an initial phase.</p></div></div><a href="#g:7" id="g:7"><h2>Delayed Actions</h2></a><div class="doc"><p>Non-delayed actions are not provided, because, as seen in the example above,
 they are simply (name bindings to) signals. Consequently delayed/scheduled
 actions are delayed signals in ForSyDe.</p></div><div class="top"><p class="src"><a id="v:actionD" class="def">actionD</a> :: <a href="ForSyDe-Atom-MoC-TimeStamp.html#t:TimeStamp" title="ForSyDe.Atom.MoC.TimeStamp">TimeStamp</a> -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:Signal" title="ForSyDe.Atom.MoC.DE.React">Signal</a> a <a href="src/ForSyDe.Atom.MoC.DE.React.LF.html#actionD" class="link">Source</a> <a href="#v:actionD" class="selflink">#</a></p><div class="doc"><p>A delayed action is simply a delayed signal. In ForSyDe the initial value is
 <em>mandatory</em>. If there is a notion of <em>unknown</em>, this has to be captured by the
 domain <code>a</code> of the event (i.e. &quot;one layer below&quot;).</p></div></div><a href="#g:8" id="g:8"><h2>Reactions</h2></a><div class="doc"><p>Reactions are ForSyDe combinational process constructors, having both
 triggering and non-triggering (observing) inputs. Due to the current
 implementation of the host <code><a href="ForSyDe-Atom-MoC-DE-React.html#t:RE" title="ForSyDe.Atom.MoC.DE.React">RE</a></code> MoC, the inputs of a reaction need to come from a
 <code>statesXinputsY</code> utility, which tells which signals are persistent
 (i.e. originating from stateful processes/reactions) or instantaneous (originatig
 from non-stateful reactions or inputs).</p><p><strong>Note:</strong> The equivalent of the <code>is_present</code> construct in LF can be expressed
 using pattern-matching on process function arguments (see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:comb22" title="ForSyDe.Atom.MoC.DE.React">comb22</a></code>).</p></div><div class="top"><p class="src"><a id="v:states2inputs2" class="def">states2inputs2</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; (b3, b4) -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b3 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b4 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1 -&gt; <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2 -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b3, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b4) <a href="src/ForSyDe.Atom.MoC.DE.React.LF.html#states2inputs2" class="link">Source</a> <a href="#v:states2inputs2" class="selflink">#</a></p><div class="doc"><p>Alias for <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:syncAndObs11" title="ForSyDe.Atom.MoC.DE.React">syncAndObs11</a></code>. Denotes which actions come from states (with persistent
 values) and which come from other actions or inputs (instantaneous).</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sts = read &quot;{1@0,2@3,3@6,4@10,5@13}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ins = read &quot;{1@3,2@4,3@5,4@6,5@13}&quot;  :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>states1inputs1 0 sts ins
</code></strong>({1@3s,2@4s,3@5s,4@6s,5@13s},{1@0s,2@3s,2@4s,2@5s,3@6s,4@10s,5@13s})
</pre></div></div><div class="top"><p class="src"><a id="v:reaction22" class="def">reaction22</a> :: (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> t, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> t) =&gt; ([a1] -&gt; [a2] -&gt; ([b1], [b2])) -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t a2) -&gt; (<a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b1, <a href="ForSyDe-Atom-MoC-DE-React.html#t:SignalBase" title="ForSyDe.Atom.MoC.DE.React">SignalBase</a> t b2) <a href="src/ForSyDe.Atom.MoC.DE.React.LF.html#reaction22" class="link">Source</a> <a href="#v:reaction22" class="selflink">#</a></p><div class="doc"><p>Alias for <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:comb22" title="ForSyDe.Atom.MoC.DE.React">comb22</a></code>, tupled version, that can be chained directly from a
 <code>statesXinputsY</code> &quot;utility&quot;, see <code><a href="ForSyDe-Atom-MoC-DE-React.html#v:states2inputs2" title="ForSyDe.Atom.MoC.DE.React">states2inputs2</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sts = read &quot;{1@0,2@3,3@6,4@10,5@13}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ins = read &quot;{1@3,2@4,3@5,4@6,5@13}&quot;  :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>reaction21 (\a b -&gt; [sum a + sum b]) $ states1inputs1 0 sts ins
</code></strong>{1@0s,3@3s,4@4s,5@5s,7@6s,4@10s,10@13s}
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>