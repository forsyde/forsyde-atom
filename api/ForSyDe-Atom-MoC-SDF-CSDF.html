<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ForSyDe.Atom.MoC.SDF.CSDF</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">forsyde-atom-0.3.0.0: Shallow-embedded DSL for modeling cyber-physical systems </span><ul class="links" id="page-menu"><li><a href="src/ForSyDe.Atom.MoC.SDF.CSDF.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li><li><a href="https://forsyde.github.io/forsyde-atom/">Back to ForSyDe Web</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu KTH/EECS/ESY 2018-2020</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ForSyDe.Atom.MoC.SDF.CSDF</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Re-Exported from SDF</a></li><li><a href="#g:2">CSDF actors</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <code>CSDF</code> library implements a DSL of atoms operating according to the
 cyclo-static dataflow model of computation, in terms of the atoms of
 <a href="ForSyDe-Atom-MoC-SDF.html">ForSyDe.Atom.MoC.SDF</a>. As such SADF patterns are operating on
 <code><a href="ForSyDe-Atom-MoC-SDF.html#v:SDF" title="ForSyDe.Atom.MoC.SDF">SDF</a></code> signals, i.e. they have the exact same time semantics,
 hence there is no need for MoC interfaces between these two MoCs.</p><p>CSDF is another attempt to increase SDF's expresivity in a controlled manner by
 allowing dynamic firing rates in a static sequence which repeat cyclically. To implement this library we reused everything: the CSDF actors are implemented as specific <a href="ForSyDe-Atom-MoC-SDF-SADF.html">ForSyDe.Atom.MoC.SDF.SADF</a> patterns, and everything else is re-exported from <a href="ForSyDe-Atom-MoC-SDF.html">ForSyDe.Atom.MoC.SDF</a>.</p><p>Useful pointers:</p><ul><li><a href="ForSyDe-Atom.html">ForSyDe.Atom</a> contains general guidelines for using the API</li><li><a href="ForSyDe-Atom-MoC-SDF.html">ForSyDe.Atom.MoC.SDF</a> defines the synchronous dataflow MoC.</li><li><a href="ForSyDe-Atom-MoC-SDF-SADF.html">ForSyDe.Atom.MoC.SDF.SADF</a> defines the scenario-aware dataflow MoC.</li><li>the <a href="ForSyDe-Atom.html#naming_conv">naming convention</a> rules on how to interpret
   the function names based on their number of inputs and outputs.</li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:Signal">Signal</a> a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-SDF.html#t:SDF" title="ForSyDe.Atom.MoC.SDF">SDF</a> a)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Prod">Prod</a> = <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Cons">Cons</a> = <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:signal">signal</a> :: [a] -&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a</li><li class="src short"><a href="#v:delay">delay</a> :: [a] -&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a</li><li class="src short"><a href="#v:actor22">actor22</a> :: [((<a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Cons" title="ForSyDe.Atom.MoC.SDF.CSDF">Cons</a>, <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Cons" title="ForSyDe.Atom.MoC.SDF.CSDF">Cons</a>), (<a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Prod" title="ForSyDe.Atom.MoC.SDF.CSDF">Prod</a>, <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Prod" title="ForSyDe.Atom.MoC.SDF.CSDF">Prod</a>), [a1] -&gt; [a2] -&gt; ([b1], [b2]))] -&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> b2)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Re-Exported from SDF</h1></a><div class="doc"><p>These constructors and utilities are re-exported from <a href="ForSyDe-Atom-MoC-SDF.html">ForSyDe.Atom.MoC.SDF</a>
 for convenience.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Signal" class="def">Signal</a> a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream" title="ForSyDe.Atom.MoC.Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-SDF.html#t:SDF" title="ForSyDe.Atom.MoC.SDF">SDF</a> a) <a href="src/ForSyDe.Atom.MoC.SDF.Core.html#Signal" class="link">Source</a> <a href="#t:Signal" class="selflink">#</a></p><div class="doc"><p>Type synonym for a SY signal, i.e. &quot;a signal of SY events&quot;</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Prod" class="def">Prod</a> = <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/ForSyDe.Atom.MoC.SDF.Core.html#Prod" class="link">Source</a> <a href="#t:Prod" class="selflink">#</a></p><div class="doc"><p>Type synonym for consumption rate</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Cons" class="def">Cons</a> = <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/ForSyDe.Atom.MoC.SDF.Core.html#Cons" class="link">Source</a> <a href="#t:Cons" class="selflink">#</a></p><div class="doc"><p>Type synonym for production rate</p></div></div><div class="top"><p class="src"><a id="v:signal" class="def">signal</a> :: [a] -&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a <a href="src/ForSyDe.Atom.MoC.SDF.Core.html#signal" class="link">Source</a> <a href="#v:signal" class="selflink">#</a></p><div class="doc"><p>Transforms a list of values into a SDF signal with only one
 partition, i.e. all events share the same (initial) tag.</p></div></div><div class="top"><p class="src"><a id="v:delay" class="def">delay</a> <a href="src/ForSyDe.Atom.MoC.SDF.SDF.html#delay" class="link">Source</a> <a href="#v:delay" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [a]</td><td class="doc"><p>list of initial values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>The <code>delay</code> process &quot;delays&quot; a signal with initial events built
 from a list. It is an instantiation of the <code><a href="ForSyDe-Atom-MoC.html#v:delay" title="ForSyDe.Atom.MoC">delay</a></code>
 constructor.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = signal [1,2,3,4,5]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay [0,0,0] s
</code></strong>{0,0,0,1,2,3,4,5}
</pre><p><img src="fig/moc-sdf-pattern-delay.png" /></p></div></div><a href="#g:2" id="g:2"><h1>CSDF actors</h1></a><div class="top"><p class="src"><a id="v:actor22" class="def">actor22</a> <a href="src/ForSyDe.Atom.MoC.SDF.CSDF.html#actor22" class="link">Source</a> <a href="#v:actor22" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [((<a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Cons" title="ForSyDe.Atom.MoC.SDF.CSDF">Cons</a>, <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Cons" title="ForSyDe.Atom.MoC.SDF.CSDF">Cons</a>), (<a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Prod" title="ForSyDe.Atom.MoC.SDF.CSDF">Prod</a>, <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Prod" title="ForSyDe.Atom.MoC.SDF.CSDF">Prod</a>), [a1] -&gt; [a2] -&gt; ([b1], [b2]))]</td><td class="doc"><p>control signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a1</td><td class="doc"><p>data signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> a2</td><td class="doc"><p>data signal </p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SDF-CSDF.html#t:Signal" title="ForSyDe.Atom.MoC.SDF.CSDF">Signal</a> b2)</td><td class="doc"><p>output data signals</p></td></tr></table></div><div class="doc"><p>A CSDF actor is very similar to a SDF actor, but instead of only one set of
 execution parameter (production rate, consumption rate, function), it takes a
 finite list of such parameters, and cycles through them with each firing. </p><p>Constructors: <code>actor[1-4][1-4]</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [1..10]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f a = [sum a]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>actor11 [(3,1,f),(2,1,f)] s1
</code></strong>{6,9,21,19}
</pre><p><img src="fig/moc-ddf-csdf-actor.png" /></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>