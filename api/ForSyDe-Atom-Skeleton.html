---
layout: haddock
---
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ForSyDe.Atom.Skeleton</title></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/ForSyDe-Atom-Skeleton.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">forsyde-atom-0.2.2.1: A shallow-embedded DSL for modeling cyber-physical systems</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu KTH/ICT/ESY 2015</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr><tr><th>Extensions</th><td>PostfixOperators</td></tr></table><p class="caption">ForSyDe.Atom.Skeleton</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Atoms</a></li><li><a href="#g:2">Skeleton constructors</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module exports a type class with the interfaces for the
 Skeleton layer atoms. It does <em>NOT</em> export any implementation of
 atoms not any constructor as composition of atoms.</p><p><strong>IMPORTANT!!!</strong>
 see the <a href="ForSyDe-Atom.html#naming_conv">naming convention</a> rules
 on how to interpret, use and develop your own constructors.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="file:///opt/ghc/8.2.1/share/doc/ghc-8.2.1/html/libraries/base-4.10.0.0/Data-Functor.html#t:Functor">Functor</a> c =&gt; <a href="#t:Skeleton">Skeleton</a> c <span class="keyword">where</span><ul class="subs"></ul></li><li class="src short"><a href="#v:farm22">farm22</a> :: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; c a1 -&gt; c a2 -&gt; (c b1, c b2)</li><li class="src short"><a href="#v:reduce">reduce</a> :: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c =&gt; (a -&gt; a -&gt; a) -&gt; c a -&gt; a</li><li class="src short"><a href="#v:reducei">reducei</a> :: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c =&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; c a -&gt; a</li><li class="src short"><a href="#v:pipe">pipe</a> :: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c =&gt; c (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:pipe2">pipe2</a> :: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; a -&gt; a) -&gt; c a1 -&gt; c a2 -&gt; a -&gt; a</li></ul></details></div><div id="interface"><h1 id="g:1">Atoms</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="file:///opt/ghc/8.2.1/share/doc/ghc-8.2.1/html/libraries/base-4.10.0.0/Data-Functor.html#t:Functor">Functor</a> c =&gt; <a id="t:Skeleton" class="def">Skeleton</a> c <span class="keyword">where</span> <a href="src/ForSyDe-Atom-Skeleton.html#Skeleton" class="link">Source</a> <a href="#t:Skeleton" class="selflink">#</a></p><div class="doc"><p>Class containing all the Skeleton layer atoms.</p><p>This class is instantiated by a set of categorical types,
 i.e. types which describe an inherent potential for being evaluated
 in parallel. Skeletons are patterns from this layer. When skeletons
 take as arguments entities from the MoC layer (i.e. processes), the
 results themselves are parallel process networks which describe
 systems with an inherent potential to be implemented on parallel
 platforms. All skeletons can be described as composition of the
 three atoms below (<code><a href="ForSyDe-Atom-Skeleton.html#v:-61--60--60--61-">=&lt;&lt;=</a></code> being just a specific instantiation of
 <code><a href="ForSyDe-Atom-Skeleton.html#v:-61--92--61-">=\=</a></code>). This possible due to an existing theorem in the categorical
 type theory, also called the Bird-Merteens formalism
 <a href="ForSyDe-Atom.html#bird97">[Bird97]</a>:</p><p><a id="factorization"></a></p><dl><dt>factorization</dt><dd>A function on a categorical type is an algorithmic
 skeleton (i.e. catamorphism) <em>iff</em> it can be represented in a
 factorized form, i.e. as a <em>map</em> composed with a <em>reduce</em>.</dd></dl><p>Consequently, most of the skeletons for the implemented categorical
 types are described in their factorized form, taking as arguments
 either:</p><ul><li>type constructors or functions derived from type constructors</li><li>processes, i.e. MoC layer entities</li></ul><p>Most of the ground-work on algorithmic skeletons on which this
 module is founded has been laid in <a href="ForSyDe-Atom.html#bird97">[Bird97]</a>,
 <a href="ForSyDe-Atom.html#skillicorn05">[Skillicorn05]</a> and it founds many
 of the frameworks collected in <a href="ForSyDe-Atom.html#gorlatch03">[Gorlatch03]</a>.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="ForSyDe-Atom-Skeleton.html#v:-61-.-61-">(=.=)</a>, <a href="ForSyDe-Atom-Skeleton.html#v:-61--42--61-">(=*=)</a>, <a href="ForSyDe-Atom-Skeleton.html#v:-61--92--61-">(=\=)</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:-61-.-61-" class="def">(=.=)</a> :: (a -&gt; b) -&gt; c a -&gt; c b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D.%3D" class="link">Source</a> <a href="#v:-61-.-61-" class="selflink">#</a></p><div class="doc"><p>Atom which maps a function on each element of a structure
 (i.e. categorical type), defined as:</p><p><img src="fig/eqs-skel-atom-dot.png" /></p><p><code><a href="ForSyDe-Atom-Skeleton.html#v:-61-.-61-">=.=</a></code> together with <code><a href="ForSyDe-Atom-Skeleton.html#v:-61--42--61-">=*=</a></code> form the <code>map</code> pattern.</p></div><p class="src"><a id="v:-61--42--61-" class="def">(=*=)</a> :: c (a -&gt; b) -&gt; c a -&gt; c b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D%2A%3D" class="link">Source</a> <a href="#v:-61--42--61-" class="selflink">#</a></p><div class="doc"><p>Atom which applies the functions contained by as structure
 (i.e. categorical type), on the elements of another structure,
 defined as:</p><p><img src="fig/eqs-skel-atom-star.png" /></p><p><code><a href="ForSyDe-Atom-Skeleton.html#v:-61-.-61-">=.=</a></code> together with <code><a href="ForSyDe-Atom-Skeleton.html#v:-61--42--61-">=*=</a></code> form the <code>map</code> pattern.</p></div><p class="src"><a id="v:-61--92--61-" class="def">(=\=)</a> :: (a -&gt; a -&gt; a) -&gt; c a -&gt; a <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D%5C%3D" class="link">Source</a> <a href="#v:-61--92--61-" class="selflink">#</a></p><div class="doc"><p>Atom which reduces a structure to an element based on an
 <em>associative</em> function, defined as:</p><p><img src="fig/eqs-skel-atom-red.png" /></p></div><p class="src"><a id="v:-61--60--60--61-" class="def">(=&lt;&lt;=)</a> <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D%3C%3C%3D" class="link">Source</a> <a href="#v:-61--60--60--61-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: c (a -&gt; a)</td><td class="doc"><p>vector of functions</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>kernel element</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>result </p></td></tr></table></div><div class="doc"><p>Skeleton which <em>pipes</em> an element through all the functions
 contained by a structure. </p><p><strong>N.B.</strong>: this is not an atom. It has an implicit definition
 which might be augmented by instances of this class to include
 edge cases.</p><p><img src="fig/eqs-skel-pattern-pipe.png" /></p><p>As the composition operation is not associative, we cannot treat
 <code>pipe</code> as a true reduction. Alas, it can still be exploited in
 parallel since it exposes another type of parallelism: time
 parallelism.</p></div><p class="src"><a id="v:first" class="def">first</a> :: c a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#first" class="link">Source</a> <a href="#v:first" class="selflink">#</a></p><div class="doc"><p>Returns the first element in a structure.</p><p><strong>N.B.</strong>: this is not an atom. It has an implicit definition
 which might be replaced by instances of this class with a more
 efficient implementation.</p><p><img src="fig/eqs-skel-pattern-first.png" /></p></div><p class="src"><a id="v:last" class="def">last</a> :: c a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#last" class="link">Source</a> <a href="#v:last" class="selflink">#</a></p><div class="doc"><p>Returns the last element in a structure.</p><p><strong>N.B.</strong>: this is not an atom. It has an implicit definition
 which might be replaced by instances of this class with a more
 efficient implementation.</p><p><img src="fig/eqs-skel-pattern-last.png" /></p></div></div><div class="subs instances"><details id="i:Skeleton" open="open"><summary>Instances</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Skeleton:Skeleton:1"></span> <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a></span> <a href="src/ForSyDe-Atom-Skeleton.html#line-111" class="link">Source</a> <a href="#t:Skeleton" class="selflink">#</a></td><td class="doc"><p>Ensures that <code><a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a></code> is a structure associated with the Skeleton Layer.</p></td></tr><tr><td colspan="2"><details id="i:ic:Skeleton:Skeleton:1"><summary class="hide-when-js-enabled">Instance details</summary><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61-.-61-">(=.=)</a> :: (a -&gt; b) -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> b <a href="src/ForSyDe-Atom-Skeleton.html#%3D.%3D" class="link">Source</a> <a href="#v:-61-.-61-" class="selflink">#</a></p><p class="src"><a href="#v:-61--42--61-">(=*=)</a> :: <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (a -&gt; b) -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> b <a href="src/ForSyDe-Atom-Skeleton.html#%3D%2A%3D" class="link">Source</a> <a href="#v:-61--42--61-" class="selflink">#</a></p><p class="src"><a href="#v:-61--92--61-">(=\=)</a> :: (a -&gt; a -&gt; a) -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#%3D%5C%3D" class="link">Source</a> <a href="#v:-61--92--61-" class="selflink">#</a></p><p class="src"><a href="#v:-61--60--60--61-">(=&lt;&lt;=)</a> :: <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (a -&gt; a) -&gt; a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#%3D%3C%3C%3D" class="link">Source</a> <a href="#v:-61--60--60--61-" class="selflink">#</a></p><p class="src"><a href="#v:first">first</a> :: <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#first" class="link">Source</a> <a href="#v:first" class="selflink">#</a></p><p class="src"><a href="#v:last">last</a> :: <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#last" class="link">Source</a> <a href="#v:last" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><h1 id="g:2">Skeleton constructors</h1><div class="doc"><p>Patterns of in the skeleton layer are provided, like all other
 patterns in ForSyDe-Atom, as constructors. If the layer below
 this one is the <code><a href="ForSyDe-Atom-MoC.html#v:MoC">MoC</a></code> layer, i.e. the functions
 taken as arguments are processes, then these skeletons can be
 regarded as process network constructors, as the structures
 created are process networks with inherent potential for parallel
 implementation.</p></div><div class="top"><p class="src"><a id="v:farm22" class="def">farm22</a> :: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; c a1 -&gt; c a2 -&gt; (c b1, c b2) <a href="src/ForSyDe-Atom-Skeleton.html#farm22" class="link">Source</a> <a href="#v:farm22" class="selflink">#</a></p><div class="doc"><p><code>farm</code> maps a function on a vector. It is the embodiment of the
 <code>map</code> homomorphism, and its naming is inspired from the pattern
 predominant in HPC. Indeed, if we consider the layer below as being
 the <code><a href="ForSyDe-Atom-MoC.html#v:MoC">MoC</a></code> layer (i.e. the passed functions are
 processes), the resulting structure could be regarded as a &quot;farm of
 data-parallel processes&quot;.</p><p>Constructors: <code>farm[1-8][1-4]</code>.</p><p><img src="fig/eqs-skel-pattern-farm.png" />
 <img src="fig/skel-pattern-farm.png" /></p></div></div><div class="top"><p class="src"><a id="v:reduce" class="def">reduce</a> <a href="src/ForSyDe-Atom-Skeleton.html#reduce" class="link">Source</a> <a href="#v:reduce" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; a -&gt; a)</td><td class="doc"><p>associative function (*)</p></td></tr><tr><td class="src">-&gt; c a</td><td class="doc"><p>structure</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>reduced element</p></td></tr></table></div><div class="doc"><p>Infix name for the <code><a href="ForSyDe-Atom-Skeleton.html#v:-61--92--61-">=\=</a></code> atom operator.</p><p>(*) if the operation is not associative then the network can be
 treated like a pipeline.</p></div></div><div class="top"><p class="src"><a id="v:reducei" class="def">reducei</a> <a href="src/ForSyDe-Atom-Skeleton.html#reducei" class="link">Source</a> <a href="#v:reducei" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; a -&gt; a)</td><td class="doc"><p>associative function (*)</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>initial element of structure</p></td></tr><tr><td class="src">-&gt; c a</td><td class="doc"><p>structure</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>reduced element</p></td></tr></table></div><div class="doc"><p><code><a href="ForSyDe-Atom-Skeleton.html#v:reducei">reducei</a></code> is special case of <code><a href="ForSyDe-Atom-Skeleton.html#v:reduce">reduce</a></code> where an initial element is
 specified outside the reduced vector. It is implemented as a
 <code><a href="ForSyDe-Atom-Skeleton.html#v:pipe">pipe</a></code> with switched arguments, and the reduction function is
 constrained to be associative. It is semantically equivalent to the
 pattern depicted below.</p><p>(*) if the operation is not associative then the network is
 semantically equivalent to <code>pipe1</code> (see <code><a href="ForSyDe-Atom-Skeleton.html#v:pipe2">pipe2</a></code>).</p><p><img src="fig/eqs-skel-pattern-reducei.png" />
 <img src="fig/skel-pattern-reducei.png" /></p></div></div><div class="top"><p class="src"><a id="v:pipe" class="def">pipe</a> <a href="src/ForSyDe-Atom-Skeleton.html#pipe" class="link">Source</a> <a href="#v:pipe" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; c (a -&gt; a)</td><td class="doc"><p>vector of functions</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>kernel element</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>result </p></td></tr></table></div><div class="doc"><p>Infix name for the <code><a href="ForSyDe-Atom-Skeleton.html#v:-61--60--60--61-">=&lt;&lt;=</a></code> skeleton operator.</p></div></div><div class="top"><p class="src"><a id="v:pipe2" class="def">pipe2</a> :: <a href="ForSyDe-Atom-Skeleton.html#t:Skeleton">Skeleton</a> c =&gt; (a1 -&gt; a2 -&gt; a -&gt; a) -&gt; c a1 -&gt; c a2 -&gt; a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#pipe2" class="link">Source</a> <a href="#v:pipe2" class="selflink">#</a></p><div class="doc"><p>The <code>pipe</code> constructors are a more generic form of the <code><a href="ForSyDe-Atom-Skeleton.html#v:-61--60--60--61-">=&lt;&lt;=</a></code>
 (<code><a href="ForSyDe-Atom-Skeleton.html#v:pipe">pipe</a></code>) skeleton apt for successive partial application and create
 more robust parameterizable pipeline networks.</p><p>Constructors: <code>comb[1-8]</code>.</p><p><img src="fig/eqs-skel-pattern-pipe1.png" />
 <img src="fig/skel-pattern-pipe1.png" /></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.2</p></div></body></html>
