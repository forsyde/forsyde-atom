<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# OPTIONS_HADDOCK not-home, prune #-}</span><span>
</span><span id="line-2"></span><span class="hs-comment">----------------------------------------------------------------------</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Module      :  ForSyDe.Atom</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Copyright   :  (c) George Ungureanu, 2015-2020</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- License     :  BSD-style (see the file LICENSE)</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- </span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Maintainer  :  ugeorge@kth.se</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Stability   :  experimental</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- &quot;ForSyDe.Atom&quot; is a formal framework for modeling and simulating heterogeneous</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- embedded and cyber-physical systems (CPS) at a high level of abstraction, whose</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- &quot;spiritual parent&quot; is the &lt;https://forsyde.github.io/forsyde-shallow/ ForSyDe&gt;</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- modeling framework &lt;#sander04 [Sander04]&gt;. In ForSyDe, heterogeneous systems are</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- modeled as /networks of processes/ communicating through /signals/. In ForSyDe,</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- processes alone capture the timing semantics of execution and synchronization</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- according to a certain /model of computation (MoC)/. The shallow implementation of</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- ForSyDe, @&lt;https://forsyde.github.io/forsyde-shallow/ forsyde-shallow&gt;@ provides</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- libraries of higher-order functions for instantiating processes called</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- /process constructors/ for several MoCs. </span><span>
</span><span id="line-22"></span><span class="hs-comment">--</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- The @&lt;https://forsyde.github.io/forsyde-atom/ forsyde-atom&gt;@ project started as a</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- proof-of-concept for the atom-based approach to CPS introduced in</span><span>
</span><span id="line-25"></span><span class="hs-comment">-- &lt;ForSyDe-Atom.html#ungureanu17 [Ungureanu17]&gt;. This approach extends the ideas of</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- the tagged signal model by systematically deconstructing processes to their basic</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- semantics and recreating them using a minimal language of primitive building blocks</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- called /atoms/. It also expands the scope of this model by exploiting more aspects</span><span>
</span><span id="line-29"></span><span class="hs-comment">-- of cyber-physical systems than just timing, but also adding primitives for</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- parallelism, behavior extensions, probabilistic distribution, etc., each in its own</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- interacting environment called /layer/.</span><span>
</span><span id="line-32"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-33"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">ForSyDe.Atom</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-34"></span><span>
</span><span id="line-35"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Prerequisites</span></span><span>
</span><span id="line-36"></span><span>  </span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-comment">-- | The API documentation is meant to be a comprehensive reference guide for an</span><span>
</span><span id="line-38"></span><span>  </span><span class="hs-comment">-- interested user, with enough details, pictures and examples to ease the</span><span>
</span><span id="line-39"></span><span>  </span><span class="hs-comment">-- understanding of each API element. It is not meant to be an introduction to the</span><span>
</span><span id="line-40"></span><span>  </span><span class="hs-comment">-- ForSyDe-Atom methodology nor a modeling manual. For proper introductory material</span><span>
</span><span id="line-41"></span><span>  </span><span class="hs-comment">-- we recommend consulting the following:</span><span>
</span><span id="line-42"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-43"></span><span>  </span><span class="hs-comment">-- * &lt;#ungureanu20a [Ungureanu20a]&gt; is a peer-reviewed comprehensive introduction to</span><span>
</span><span id="line-44"></span><span>  </span><span class="hs-comment">--   the methodology and the scientific reasoning behind this modeling framework. It</span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-comment">--   defines the main modeling concepts proposed by ForSyDe-Atom: atom, pattern and</span><span>
</span><span id="line-46"></span><span>  </span><span class="hs-comment">--   layer.</span><span>
</span><span id="line-47"></span><span>  </span><span class="hs-comment">-- </span><span>
</span><span id="line-48"></span><span>  </span><span class="hs-comment">-- * &lt;#ungureanu20b [Ungureanu20b]&gt; is a collection of step-by-step tutorials and</span><span>
</span><span id="line-49"></span><span>  </span><span class="hs-comment">--   simple case studies.</span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-comment">-- </span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-comment">-- * the &lt;https://forsyde.github.io/docs/ Documentation&gt; page from the ForSyDe web</span><span>
</span><span id="line-52"></span><span>  </span><span class="hs-comment">--   site contains up-to-date pointers to further useful material.</span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Using the API</span></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Loading Modules</span></span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span>  </span><span class="hs-comment">-- | &quot;ForSyDe.Atom&quot; is a collection of libraries, each representing a /layer/, which</span><span>
</span><span id="line-59"></span><span>  </span><span class="hs-comment">-- is an own DSL for describing one modeling aspect in a CPS. Each module under</span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-comment">-- &quot;ForSyDe.Atom&quot; , e.g. @ForSyDe.Atom.MoC@ represents a layer, defines the main</span><span>
</span><span id="line-61"></span><span>  </span><span class="hs-comment">-- /atoms/ and the generic /patterns/ for the respective layer. Each module under a</span><span>
</span><span id="line-62"></span><span>  </span><span class="hs-comment">-- layer, e.g. @ForSyDe.Atom.MoC.SY@ describes a sub-domain of that layer and</span><span>
</span><span id="line-63"></span><span>  </span><span class="hs-comment">-- defines the actual semantics of atoms (i.e. overloads atom functions), as well as</span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-comment">-- other specific patterns and utilities. Due to deliberate name clashes and to</span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-comment">-- improve readability, each module needs to be imported with a (maybe qualified)</span><span>
</span><span id="line-66"></span><span>  </span><span class="hs-comment">-- alias:</span><span>
</span><span id="line-67"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-comment">-- &gt; import ForSyDe.Atom.MoC    as MoC</span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-comment">-- &gt; import ForSyDe.Atom.MoC.SY as SY</span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-comment">-- &gt; </span><span>
</span><span id="line-71"></span><span>  </span><span class="hs-comment">-- &gt; -- MoC.comb11 /= SY.comb11</span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-comment">-- </span><span>
</span><span id="line-73"></span><span>  </span><span class="hs-comment">-- By default, the current module, &quot;ForSyDe.Atom&quot;, only re-exports a couple of</span><span>
</span><span id="line-74"></span><span>  </span><span class="hs-comment">-- generic utilities for working with tuples and for plotting signals.</span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="ForSyDe.Atom.Utility.Tuple.html"><span class="hs-identifier">ForSyDe.Atom.Utility.Tuple</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-77"></span><span>  </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="ForSyDe.Atom.Utility.Plot.html"><span class="hs-identifier">ForSyDe.Atom.Utility.Plot</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Available Layers</span></span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span>  </span><span class="hs-comment">-- | Following are the layers provided by the current version of ForSyDe-Atom. Click</span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-comment">-- on any of the links for more documentation:</span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-84"></span><span>  </span><span class="hs-comment">-- * &quot;ForSyDe.Atom.MoC&quot;, a DSL for capturing the semantics of computation and</span><span>
</span><span id="line-85"></span><span>  </span><span class="hs-comment">--   concurrency according to a model of computation.</span><span>
</span><span id="line-86"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-comment">-- * &quot;ForSyDe.Atom.Skel&quot; a DSL for describing structured parallelism.</span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-comment">-- * &quot;ForSyDe.Atom.Probability&quot;, a DSL for describing numerical values as probability</span><span>
</span><span id="line-90"></span><span>  </span><span class="hs-comment">-- * distributions, e.g. Gaussian.</span><span>
</span><span id="line-91"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-comment">-- * &quot;ForSyDe.Atom.ExB&quot;, a DSL for extending the pool of values with logic symbols</span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-comment">--   with well-kown semantics (e.g. absent values).</span><span>
</span><span id="line-94"></span><span>  </span><span>
</span><span id="line-95"></span><span>  </span><span class="annot"><span class="hs-comment">-- ** Naming Convention</span></span><span>
</span><span id="line-96"></span><span>  </span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-comment">-- | #naming_conv# __IMPORTANT!!!__ All multi-argument functions and utilities</span><span>
</span><span id="line-98"></span><span>  </span><span class="hs-comment">-- provided by the @&lt;https://forsyde.github.io/forsyde-atom/ forsyde-atom&gt;@ API are</span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-comment">-- named along the lines of @functionMN@ where @M@ represents the number of</span><span>
</span><span id="line-100"></span><span>  </span><span class="hs-comment">-- __/curried/__ inputs (i.e. @a1 -&gt; a2 -&gt; ... -&gt; aM@), while @N@ represents the</span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-comment">-- number of __/tupled/__ outputs (i.e. @(b1,b2,...,bN)@). For brevity, we only</span><span>
</span><span id="line-102"></span><span>  </span><span class="hs-comment">-- write documentation for functions with 2 inputs and 2 outputs</span><span>
</span><span id="line-103"></span><span>  </span><span class="hs-comment">-- (i.e. @function22@), while all the other available ones are mentioned as a regex</span><span>
</span><span id="line-104"></span><span>  </span><span class="hs-comment">-- (i.e. @function[1-4][1-4]@). In case the provided functions are not sufficient,</span><span>
</span><span id="line-105"></span><span>  </span><span class="hs-comment">-- feel free to implement your own patterns following the examples in the source</span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-comment">-- code.</span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Bibliography</span></span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span>  </span><span class="annot"><span class="hs-comment">-- | Here are gathered pointers to documents referenced throughout the API documentation.</span></span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #bonna19# &lt;https://dl.acm.org/doi/10.1145/3342997?cid=99659130620 [Bonna19]&gt; Bonna, R., Loubach, D. S., Ungureanu, G., &amp; Sander, I. (2019). Modeling and simulation of dynamic applications using scenario-aware dataflow. ACM Transactions on Design Automation of Electronic Systems (TODAES), 24(5), 1-29.</span></span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #buck93# [Buck93] Buck, J. T., &amp; Lee, E. A. (1993). Scheduling dynamic dataflow graphs with bounded memory using the token flow model. In /1993 IEEE international conference on acoustics, speech, and signal processing/ (Vol. 1, pp. 429-432). IEEE.</span></span><span>
</span><span id="line-115"></span><span>  </span><span>
</span><span id="line-116"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #cassandras09# [Cassandras09] Cassandras, C. G., &amp; Lafortune, S. (2009). Introduction to discrete event systems. Springer Science &amp; Business Media.</span></span><span>
</span><span id="line-117"></span><span>  </span><span>
</span><span id="line-118"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #fuji00# [Fujimoto00] Fujimoto, R. M. (2000). Parallel and distributed simulation systems (Vol. 300). New York: Wiley.</span></span><span>
</span><span id="line-119"></span><span>  </span><span>
</span><span id="line-120"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #halbwachs91# &lt;http://ieeexplore.ieee.org/document/97300/ [Halbwachs91]&gt; Halbwachs, N., Caspi, P., Raymond, P., &amp; Pilaud, D. (1991). The synchronous data flow programming language LUSTRE. /Proceedings of the IEEE, 79(9)/, 1305-1320.</span></span><span>
</span><span id="line-121"></span><span>
</span><span id="line-122"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #gorlatch03 e# &lt;http://link.springer.com/chapter/10.1007/978-1-4471-0097-3_1#page-1 [Gorlatch03]&gt; Fischer, J., Gorlatch, S., &amp; Bischof, H. (2003). Foundations of data-parallel skeletons. In /Patterns and skeletons for parallel and distributed computing/ (pp. 1-27). Springer London.</span></span><span>
</span><span id="line-123"></span><span>  </span><span>
</span><span id="line-124"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #kahn76# [Kahn76] Kahn, G., &amp; MacQueen, D. (1976). Coroutines and networks of parallel processes.</span></span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #lee87# [Lee87] Lee, E. A., &amp; Messerschmitt, D. G. (1987). Synchronous data flow. /Proceedings of the IEEE/, 75(9), 1235-1245.</span></span><span>
</span><span id="line-127"></span><span>  </span><span>
</span><span id="line-128"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #lee98# &lt;https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=736561&amp;casa_token=GfbDXDN-wS4AAAAA:uE2y6ZVAGUv8vVwoe9BXTyzdDRFEAWq-c45nZfQurcqTRwU6a1k7rbWHGodSMQDNAOOQqSd7&amp;tag=1 [Lee98]&gt; Lee, E. A., &amp; Sangiovanni-Vincentelli, A. (1998). A framework for comparing models of computation. /IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 17(12)/, 1217-1229.</span></span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #lohstroh19# &lt;https://people.eecs.berkeley.edu/~marten/pdf/Lohstroh_etAl_CyPhy19.pdf [Lohstroh19]&gt; Lohstroh, M., Romeo, &#205;. &#205;., Goens, A., Derler, P., Castrillon, J., Lee, E. A., &amp; Sangiovanni-Vincentelli, A. (2019). Reactors: A deterministic model for composable reactive systems. In /Cyber Physical Systems. Model-Based Design/ (pp. 59-85). Springer, Cham.</span></span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #reekie95# &lt;http://ptolemy.eecs.berkeley.edu/~johnr/papers/pdf/thesis.pdf [Reekie95]&gt; Reekie, H. J. (1995). Realtime signal processing: Dataflow, visual, and functional programming.</span></span><span>
</span><span id="line-133"></span><span>  </span><span>
</span><span id="line-134"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #sander04# &lt;http://people.kth.se/~ingo/Papers/TCAD2004_SystemModeling.pdf [Sander04]&gt; Sander, I., &amp; Jantsch, A. (2004). System modeling and transformational design refinement in ForSyDe [Formal System Design]. /IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 23(1)/, 17-32.</span></span><span>
</span><span id="line-135"></span><span>    </span><span>
</span><span id="line-136"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #skillicorn05# &lt;https://books.google.se/books?hl=ro&amp;lr=&amp;id=rQwsL5xsZigC&amp;oi=fnd&amp;pg=PP1&amp;dq=skillicorn+foundation+parallel+programming&amp;ots=UJMBr0uO2Q&amp;sig=ncyXxE0gFNkUZwVOYyFb_ezWlGY&amp;redir_esc=y#v=onepage&amp;q=skillicorn%20foundation%20parallel%20programming&amp;f=false [Skillicorn05]&gt; Skillicorn, D. B. (2005). Foundations of parallel programming (No. 6). Cambridge University Press.</span></span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #stuijk11# [Stuijk11] Stuijk, S., Geilen, M., Theelen, B., &amp; Basten, T. (2011, July). Scenario-aware dataflow: Modeling, analysis and implementation of dynamic applications. /In 2011 International Conference on Embedded Computer Systems: Architectures, Modeling and Simulation/ (pp. 404-411). IEEE.</span></span><span>
</span><span id="line-139"></span><span>  </span><span>
</span><span id="line-140"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #ungureanu17# &lt;http://ieeexplore.ieee.org/document/7927270/ [Ungureanu17]&gt; Ungureanu, G., &amp; Sander, I., A layered formal framework for modeling of cyber-physical systems, in /2017 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)/, 2017, pp. 1715&#8211;1720.</span></span><span>
</span><span id="line-141"></span><span>  </span><span>
</span><span id="line-142"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #ungureanu18# &lt;https://ieeexplore.ieee.org/document/8342019/ [Ungureanu18]&gt; Ungureanu, G., de Medeiros, J. E. G. &amp; Sander, I., /Bridging discrete and continuous time models with Atoms/, in 2018 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE), 2018, pp. 277-280</span></span><span>
</span><span id="line-143"></span><span>
</span><span id="line-144"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #ungureanu20a# [Ungureanu20a] Ungureanu, G., et. al. , ForSyDe-Atom: Taming complexity in cyber-physical system design with layers, /under review/.</span></span><span>
</span><span id="line-145"></span><span>
</span><span id="line-146"></span><span>  </span><span class="annot"><span class="hs-comment">-- | #ungureanu20b# [Ungureanu20b] Ungureanu, G., ForSyDe-Atom: User manual, version 2, 2020</span></span><span>
</span><span id="line-147"></span><span>
</span><span id="line-148"></span><span>  </span><span>
</span><span id="line-149"></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.ExB.html"><span class="hs-identifier">ForSyDe.Atom.ExB</span></a></span><span>
</span><span id="line-152"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.MoC.html"><span class="hs-identifier">ForSyDe.Atom.MoC</span></a></span><span>
</span><span id="line-153"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.MoC.Stream.html"><span class="hs-identifier">ForSyDe.Atom.MoC.Stream</span></a></span><span>
</span><span id="line-154"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.MoC.Time.html"><span class="hs-identifier">ForSyDe.Atom.MoC.Time</span></a></span><span>
</span><span id="line-155"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.MoC.TimeStamp.html"><span class="hs-identifier">ForSyDe.Atom.MoC.TimeStamp</span></a></span><span>
</span><span id="line-156"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.Skel.html"><span class="hs-identifier">ForSyDe.Atom.Skel</span></a></span><span>
</span><span id="line-157"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.Utility.Tuple.html"><span class="hs-identifier">ForSyDe.Atom.Utility.Tuple</span></a></span><span>
</span><span id="line-158"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="ForSyDe.Atom.Utility.Plot.html"><span class="hs-identifier">ForSyDe.Atom.Utility.Plot</span></a></span><span>
</span><span id="line-159"></span></pre></body></html>