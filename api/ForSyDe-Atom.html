<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>ForSyDe.Atom</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">forsyde-atom-0.3.0.0: Shallow-embedded DSL for modeling cyber-physical systems </span><ul class="links" id="page-menu"><li><a href="src/ForSyDe.Atom.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li><li><a href="https://forsyde.github.io/forsyde-atom/">Back to ForSyDe Web</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) George Ungureanu 2015-2020</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ForSyDe.Atom</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Prerequisites</a></li><li><a href="#g:2">Using the API</a><ul><li><a href="#g:3">Loading Modules</a></li><li><a href="#g:4">Available Layers</a></li><li><a href="#g:5">Naming Convention</a></li></ul></li><li><a href="#g:6">Bibliography</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><a href="ForSyDe-Atom.html">ForSyDe.Atom</a> is a formal framework for modeling and simulating heterogeneous
 embedded and cyber-physical systems (CPS) at a high level of abstraction, whose
 &quot;spiritual parent&quot; is the <a href="https://forsyde.github.io/forsyde-shallow/">ForSyDe</a>
 modeling framework <a href="#sander04">[Sander04]</a>. In ForSyDe, heterogeneous systems are
 modeled as <em>networks of processes</em> communicating through <em>signals</em>. In ForSyDe,
 processes alone capture the timing semantics of execution and synchronization
 according to a certain <em>model of computation (MoC)</em>. The shallow implementation of
 ForSyDe, <code><a href="https://forsyde.github.io/forsyde-shallow/">forsyde-shallow</a></code> provides
 libraries of higher-order functions for instantiating processes called
 <em>process constructors</em> for several MoCs. </p><p>The <code><a href="https://forsyde.github.io/forsyde-atom/">forsyde-atom</a></code> project started as a
 proof-of-concept for the atom-based approach to CPS introduced in
 <a href="ForSyDe-Atom.html#ungureanu17">[Ungureanu17]</a>. This approach extends the ideas of
 the tagged signal model by systematically deconstructing processes to their basic
 semantics and recreating them using a minimal language of primitive building blocks
 called <em>atoms</em>. It also expands the scope of this model by exploiting more aspects
 of cyber-physical systems than just timing, but also adding primitives for
 parallelism, behavior extensions, probabilistic distribution, etc., each in its own
 interacting environment called <em>layer</em>.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short">module <a href="ForSyDe-Atom-Utility-Tuple.html">ForSyDe.Atom.Utility.Tuple</a></li><li class="src short">module <a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Prerequisites</h1></a><div class="doc"><p>The API documentation is meant to be a comprehensive reference guide for an
 interested user, with enough details, pictures and examples to ease the
 understanding of each API element. It is not meant to be an introduction to the
 ForSyDe-Atom methodology nor a modeling manual. For proper introductory material
 we recommend consulting the following:</p><ul><li><a href="#ungureanu20a">[Ungureanu20a]</a> is a peer-reviewed comprehensive introduction to
   the methodology and the scientific reasoning behind this modeling framework. It
   defines the main modeling concepts proposed by ForSyDe-Atom: atom, pattern and
   layer.</li><li><a href="#ungureanu20b">[Ungureanu20b]</a> is a collection of step-by-step tutorials and
   simple case studies.</li><li>the <a href="https://forsyde.github.io/docs/">Documentation</a> page from the ForSyDe web
   site contains up-to-date pointers to further useful material.</li></ul></div><a href="#g:2" id="g:2"><h1>Using the API</h1></a><a href="#g:3" id="g:3"><h2>Loading Modules</h2></a><div class="doc"><p><a href="ForSyDe-Atom.html">ForSyDe.Atom</a> is a collection of libraries, each representing a <em>layer</em>, which
 is an own DSL for describing one modeling aspect in a CPS. Each module under
 <a href="ForSyDe-Atom.html">ForSyDe.Atom</a> , e.g. <code>ForSyDe.Atom.MoC</code> represents a layer, defines the main
 <em>atoms</em> and the generic <em>patterns</em> for the respective layer. Each module under a
 layer, e.g. <code>ForSyDe.Atom.MoC.SY</code> describes a sub-domain of that layer and
 defines the actual semantics of atoms (i.e. overloads atom functions), as well as
 other specific patterns and utilities. Due to deliberate name clashes and to
 improve readability, each module needs to be imported with a (maybe qualified)
 alias:</p><pre>import ForSyDe.Atom.MoC    as MoC
import ForSyDe.Atom.MoC.SY as SY

-- MoC.comb11 /= SY.comb11</pre><p>By default, the current module, <a href="ForSyDe-Atom.html">ForSyDe.Atom</a>, only re-exports a couple of
 generic utilities for working with tuples and for plotting signals.</p></div><div class="top"><p class="src">module <a href="ForSyDe-Atom-Utility-Tuple.html">ForSyDe.Atom.Utility.Tuple</a></p></div><div class="top"><p class="src">module <a href="ForSyDe-Atom-Utility-Plot.html">ForSyDe.Atom.Utility.Plot</a></p></div><a href="#g:4" id="g:4"><h2>Available Layers</h2></a><div class="doc"><p>Following are the layers provided by the current version of ForSyDe-Atom. Click
 on any of the links for more documentation:</p><ul><li><a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, a DSL for capturing the semantics of computation and
   concurrency according to a model of computation.</li><li><a href="ForSyDe-Atom-Skel.html">ForSyDe.Atom.Skel</a> a DSL for describing structured parallelism.</li><li><a href="ForSyDe-Atom-Probability.html">ForSyDe.Atom.Probability</a>, a DSL for describing numerical values as probability</li><li>distributions, e.g. Gaussian.</li><li><a href="ForSyDe-Atom-ExB.html">ForSyDe.Atom.ExB</a>, a DSL for extending the pool of values with logic symbols
   with well-kown semantics (e.g. absent values).</li></ul></div><a href="#g:5" id="g:5"><h2>Naming Convention</h2></a><div class="doc"><p><a id="naming_conv"></a> <strong>IMPORTANT!!!</strong> All multi-argument functions and utilities
 provided by the <code><a href="https://forsyde.github.io/forsyde-atom/">forsyde-atom</a></code> API are
 named along the lines of <code>functionMN</code> where <code>M</code> represents the number of
 <strong><em>curried</em></strong> inputs (i.e. <code>a1 -&gt; a2 -&gt; ... -&gt; aM</code>), while <code>N</code> represents the
 number of <strong><em>tupled</em></strong> outputs (i.e. <code>(b1,b2,...,bN)</code>). For brevity, we only
 write documentation for functions with 2 inputs and 2 outputs
 (i.e. <code>function22</code>), while all the other available ones are mentioned as a regex
 (i.e. <code>function[1-4][1-4]</code>). In case the provided functions are not sufficient,
 feel free to implement your own patterns following the examples in the source
 code.</p></div><a href="#g:6" id="g:6"><h1>Bibliography</h1></a><div class="doc"><p>Here are gathered pointers to documents referenced throughout the API documentation.</p></div><div class="doc"><p><a id="bonna19"></a> <a href="https://dl.acm.org/doi/10.1145/3342997?cid=99659130620">[Bonna19]</a> Bonna, R., Loubach, D. S., Ungureanu, G., &amp; Sander, I. (2019). Modeling and simulation of dynamic applications using scenario-aware dataflow. ACM Transactions on Design Automation of Electronic Systems (TODAES), 24(5), 1-29.</p></div><div class="doc"><p><a id="buck93"></a> [Buck93] Buck, J. T., &amp; Lee, E. A. (1993). Scheduling dynamic dataflow graphs with bounded memory using the token flow model. In <em>1993 IEEE international conference on acoustics, speech, and signal processing</em> (Vol. 1, pp. 429-432). IEEE.</p></div><div class="doc"><p><a id="cassandras09"></a> [Cassandras09] Cassandras, C. G., &amp; Lafortune, S. (2009). Introduction to discrete event systems. Springer Science &amp; Business Media.</p></div><div class="doc"><p><a id="fuji00"></a> [Fujimoto00] Fujimoto, R. M. (2000). Parallel and distributed simulation systems (Vol. 300). New York: Wiley.</p></div><div class="doc"><p><a id="halbwachs91"></a> <a href="http://ieeexplore.ieee.org/document/97300/">[Halbwachs91]</a> Halbwachs, N., Caspi, P., Raymond, P., &amp; Pilaud, D. (1991). The synchronous data flow programming language LUSTRE. <em>Proceedings of the IEEE, 79(9)</em>, 1305-1320.</p></div><div class="doc"><p><a id="gorlatch03 e"></a> <a href="http://link.springer.com/chapter/10.1007/978-1-4471-0097-3_1#page-1">[Gorlatch03]</a> Fischer, J., Gorlatch, S., &amp; Bischof, H. (2003). Foundations of data-parallel skeletons. In <em>Patterns and skeletons for parallel and distributed computing</em> (pp. 1-27). Springer London.</p></div><div class="doc"><p><a id="kahn76"></a> [Kahn76] Kahn, G., &amp; MacQueen, D. (1976). Coroutines and networks of parallel processes.</p></div><div class="doc"><p><a id="lee87"></a> [Lee87] Lee, E. A., &amp; Messerschmitt, D. G. (1987). Synchronous data flow. <em>Proceedings of the IEEE</em>, 75(9), 1235-1245.</p></div><div class="doc"><p><a id="lee98"></a> <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=736561&amp;casa_token=GfbDXDN-wS4AAAAA:uE2y6ZVAGUv8vVwoe9BXTyzdDRFEAWq-c45nZfQurcqTRwU6a1k7rbWHGodSMQDNAOOQqSd7&amp;tag=1">[Lee98]</a> Lee, E. A., &amp; Sangiovanni-Vincentelli, A. (1998). A framework for comparing models of computation. <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 17(12)</em>, 1217-1229.</p></div><div class="doc"><p><a id="lohstroh19"></a> <a href="https://people.eecs.berkeley.edu/~marten/pdf/Lohstroh_etAl_CyPhy19.pdf">[Lohstroh19]</a> Lohstroh, M., Romeo, &#205;. &#205;., Goens, A., Derler, P., Castrillon, J., Lee, E. A., &amp; Sangiovanni-Vincentelli, A. (2019). Reactors: A deterministic model for composable reactive systems. In <em>Cyber Physical Systems. Model-Based Design</em> (pp. 59-85). Springer, Cham.</p></div><div class="doc"><p><a id="reekie95"></a> <a href="http://ptolemy.eecs.berkeley.edu/~johnr/papers/pdf/thesis.pdf">[Reekie95]</a> Reekie, H. J. (1995). Realtime signal processing: Dataflow, visual, and functional programming.</p></div><div class="doc"><p><a id="sander04"></a> <a href="http://people.kth.se/~ingo/Papers/TCAD2004_SystemModeling.pdf">[Sander04]</a> Sander, I., &amp; Jantsch, A. (2004). System modeling and transformational design refinement in ForSyDe [Formal System Design]. <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 23(1)</em>, 17-32.</p></div><div class="doc"><p><a id="skillicorn05"></a> <a href="https://books.google.se/books?hl=ro&amp;lr=&amp;id=rQwsL5xsZigC&amp;oi=fnd&amp;pg=PP1&amp;dq=skillicorn+foundation+parallel+programming&amp;ots=UJMBr0uO2Q&amp;sig=ncyXxE0gFNkUZwVOYyFb_ezWlGY&amp;redir_esc=y#v=onepage&amp;q=skillicorn%20foundation%20parallel%20programming&amp;f=false">[Skillicorn05]</a> Skillicorn, D. B. (2005). Foundations of parallel programming (No. 6). Cambridge University Press.</p></div><div class="doc"><p><a id="stuijk11"></a> [Stuijk11] Stuijk, S., Geilen, M., Theelen, B., &amp; Basten, T. (2011, July). Scenario-aware dataflow: Modeling, analysis and implementation of dynamic applications. <em>In 2011 International Conference on Embedded Computer Systems: Architectures, Modeling and Simulation</em> (pp. 404-411). IEEE.</p></div><div class="doc"><p><a id="ungureanu17"></a> <a href="http://ieeexplore.ieee.org/document/7927270/">[Ungureanu17]</a> Ungureanu, G., &amp; Sander, I., A layered formal framework for modeling of cyber-physical systems, in <em>2017 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</em>, 2017, pp. 1715&#8211;1720.</p></div><div class="doc"><p><a id="ungureanu18"></a> <a href="https://ieeexplore.ieee.org/document/8342019/">[Ungureanu18]</a> Ungureanu, G., de Medeiros, J. E. G. &amp; Sander, I., <em>Bridging discrete and continuous time models with Atoms</em>, in 2018 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE), 2018, pp. 277-280</p></div><div class="doc"><p><a id="ungureanu20a"></a> [Ungureanu20a] Ungureanu, G., et. al. , ForSyDe-Atom: Taming complexity in cyber-physical system design with layers, <em>under review</em>.</p></div><div class="doc"><p><a id="ungureanu20b"></a> [Ungureanu20b] Ungureanu, G., ForSyDe-Atom: User manual, version 2, 2020</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>