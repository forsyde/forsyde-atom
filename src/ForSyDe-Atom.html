<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/ForSyDe/Atom.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home, prune #-}</span>
<a name="line-2"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-3"></a><span class='hs-comment'>-- |</span>
<a name="line-4"></a><span class='hs-comment'>-- Module      :  ForSyDe.Atom</span>
<a name="line-5"></a><span class='hs-comment'>-- Copyright   :  (c) George Ungureanu, KTH/ICT/ESY 2015-2016;</span>
<a name="line-6"></a><span class='hs-comment'>-- License     :  BSD-style (see the file LICENSE)</span>
<a name="line-7"></a><span class='hs-comment'>-- </span>
<a name="line-8"></a><span class='hs-comment'>-- Maintainer  :  ugeorge@kth.se</span>
<a name="line-9"></a><span class='hs-comment'>-- Stability   :  experimental</span>
<a name="line-10"></a><span class='hs-comment'>-- Portability :  portable</span>
<a name="line-11"></a><span class='hs-comment'>--</span>
<a name="line-12"></a><span class='hs-comment'>-- The formal foundation upon which ForSyDe &lt;#sander04 [Sander04]&gt;</span>
<a name="line-13"></a><span class='hs-comment'>-- defines its semantics is the /tagged signal model/</span>
<a name="line-14"></a><span class='hs-comment'>-- &lt;ForSyDe-Atom.html#lee98 [Lee98]&gt;.  This is a denotational</span>
<a name="line-15"></a><span class='hs-comment'>-- framework introduced by Lee and Sangiovanni-Vincentelli as a common</span>
<a name="line-16"></a><span class='hs-comment'>-- meta model for describing properties of concurrent systems in</span>
<a name="line-17"></a><span class='hs-comment'>-- general terms as sets of possible behaviors. Systems are regarded</span>
<a name="line-18"></a><span class='hs-comment'>-- as /compositions/ of /processes/ acting on /signals/ which are sets</span>
<a name="line-19"></a><span class='hs-comment'>-- of /tagged events/. Signals are characterized by a /tag system/</span>
<a name="line-20"></a><span class='hs-comment'>-- which determines causality between events, and could model time,</span>
<a name="line-21"></a><span class='hs-comment'>-- precedence relationships, synchronization points, and other key</span>
<a name="line-22"></a><span class='hs-comment'>-- properties. Based on how tag systems are defined, one can identify</span>
<a name="line-23"></a><span class='hs-comment'>-- several /Models of Computations (MoCs)/ as classes of behaviors</span>
<a name="line-24"></a><span class='hs-comment'>-- dictating the semantics of execution and concurrency in a network</span>
<a name="line-25"></a><span class='hs-comment'>-- of processes.</span>
<a name="line-26"></a><span class='hs-comment'>--</span>
<a name="line-27"></a><span class='hs-comment'>-- These concepts are the supporting pillars of ForSyDe's philosophy,</span>
<a name="line-28"></a><span class='hs-comment'>-- and state the purpose of the @forsyde-atom@ library: it is supposed</span>
<a name="line-29"></a><span class='hs-comment'>-- to be a modelling framework used as a proof-of-concept for the</span>
<a name="line-30"></a><span class='hs-comment'>-- atom-based approach to cyber-physical systems</span>
<a name="line-31"></a><span class='hs-comment'>-- &lt;ForSyDe-Atom.html#ungureanu17 [Ungureanu17]&gt;. This approach</span>
<a name="line-32"></a><span class='hs-comment'>-- extends the tagged signal model by systematically deconstructing</span>
<a name="line-33"></a><span class='hs-comment'>-- processes to their basic semantics and recreating them using a</span>
<a name="line-34"></a><span class='hs-comment'>-- minimal language of primitive building blocks called /atoms/. It</span>
<a name="line-35"></a><span class='hs-comment'>-- also tries to expand the scope of this model by exploiting more</span>
<a name="line-36"></a><span class='hs-comment'>-- aspects than just timing, by adding primitives for parallelism,</span>
<a name="line-37"></a><span class='hs-comment'>-- behavior, etc.</span>
<a name="line-38"></a><span class='hs-comment'>--</span>
<a name="line-39"></a><span class='hs-comment'>-- The API documentation is structured as follows: this page provides</span>
<a name="line-40"></a><span class='hs-comment'>-- an overview of the general notions and concepts, gently introducing</span>
<a name="line-41"></a><span class='hs-comment'>-- the separate modules and the motivation behind them. Each major</span>
<a name="line-42"></a><span class='hs-comment'>-- module corresponds to a separate /layer/</span>
<a name="line-43"></a><span class='hs-comment'>-- &lt;ForSyDe-Atom.html#ungureanu17 [Ungureanu17]&gt; implemented as a type</span>
<a name="line-44"></a><span class='hs-comment'>-- class. The documentation pages for each layer and for each of their</span>
<a name="line-45"></a><span class='hs-comment'>-- instances contains in-depth knowledge and examples, and can be</span>
<a name="line-46"></a><span class='hs-comment'>-- accessed from the contents page or by following the links</span>
<a name="line-47"></a><span class='hs-comment'>-- suggested. For more complex examples and tutorials follow the links</span>
<a name="line-48"></a><span class='hs-comment'>-- in the &lt;https://github.com/forsyde/forsyde-atom project web page&gt;.</span>
<a name="line-49"></a><span class='hs-comment'>--</span>
<a name="line-50"></a><span class='hs-comment'>--  #naming_conv# __IMPORTANT!!!__ All multi-parameter patterns and</span>
<a name="line-51"></a><span class='hs-comment'>-- utilities provided by the library API as higher-order functions are</span>
<a name="line-52"></a><span class='hs-comment'>-- named along the lines of @functionMN@ where @M@ represents the</span>
<a name="line-53"></a><span class='hs-comment'>-- number of __/curried/__ inputs (i.e. @a1 -&gt; a2 -&gt; ... -&gt; aM@),</span>
<a name="line-54"></a><span class='hs-comment'>-- while @N@ represents the number of __/tupled/__ outputs</span>
<a name="line-55"></a><span class='hs-comment'>-- (i.e. @(b1,b2,...,bN)@). To avoid repetition we only provide</span>
<a name="line-56"></a><span class='hs-comment'>-- documentation for functions with 2 inputs and 2 outputs</span>
<a name="line-57"></a><span class='hs-comment'>-- (i.e. @function22@). In case the provided functions do not suffice,</span>
<a name="line-58"></a><span class='hs-comment'>-- feel free to implement your own patterns following the examples in</span>
<a name="line-59"></a><span class='hs-comment'>-- the source code.</span>
<a name="line-60"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-61"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span> <span class='hs-layout'>(</span>
<a name="line-62"></a>  
<a name="line-63"></a>  <span class='hs-comment'>-- * The layered process model</span>
<a name="line-64"></a>
<a name="line-65"></a>  <span class='hs-comment'>-- | The @forsyde-atom@ project is led by three main policies:</span>
<a name="line-66"></a>  <span class='hs-comment'>--</span>
<a name="line-67"></a>  <span class='hs-comment'>-- 1. in order to cope with the complexity of cyber-physical systems</span>
<a name="line-68"></a>  <span class='hs-comment'>-- (CPS) it tries to separate the concerns such as computation,</span>
<a name="line-69"></a>  <span class='hs-comment'>-- timing, synchronization, parallelism, structure, behavior, etc.</span>
<a name="line-70"></a>  <span class='hs-comment'>--</span>
<a name="line-71"></a>  <span class='hs-comment'>-- 1. in order to have a small, ideally minimal grammar to reason</span>
<a name="line-72"></a>  <span class='hs-comment'>-- about systems correctness, it aims to provide primitive</span>
<a name="line-73"></a>  <span class='hs-comment'>-- (indivisible) operators called /atoms/ as building blocks for</span>
<a name="line-74"></a>  <span class='hs-comment'>-- independently developing complex aspects of a system's execution</span>
<a name="line-75"></a>  <span class='hs-comment'>-- through means of composition or generalization.</span>
<a name="line-76"></a>  <span class='hs-comment'>--</span>
<a name="line-77"></a>  <span class='hs-comment'>-- 1. in order to express complex behaviors with a minimal grammar,</span>
<a name="line-78"></a>  <span class='hs-comment'>-- it decouples structure (composition) from meaning (semantics),</span>
<a name="line-79"></a>  <span class='hs-comment'>-- the only semantics carriers being atoms. Thus complex behaviors</span>
<a name="line-80"></a>  <span class='hs-comment'>-- can be described in terms of /patterns of atoms/. Using ad-hoc</span>
<a name="line-81"></a>  <span class='hs-comment'>-- polymorphism, atoms can be overloaded with different semantics</span>
<a name="line-82"></a>  <span class='hs-comment'>-- triggered by the data type they input, whereas their composition</span>
<a name="line-83"></a>  <span class='hs-comment'>-- is always the same.</span>
<a name="line-84"></a>  <span class='hs-comment'>--</span>
<a name="line-85"></a>  <span class='hs-comment'>-- [@atom@] the elementary (primitive, indivisible) constructor</span>
<a name="line-86"></a>  <span class='hs-comment'>-- which embeds a set of semantics relevant for their respective</span>
<a name="line-87"></a>  <span class='hs-comment'>-- layer (e.g. timing, behavioural, structural, etc.)</span>
<a name="line-88"></a>  <span class='hs-comment'>--</span>
<a name="line-89"></a>  <span class='hs-comment'>-- [@atom patterns@] meaningful compositions of atoms. They are</span>
<a name="line-90"></a>  <span class='hs-comment'>-- provided as constructors which need to be properly instantiated</span>
<a name="line-91"></a>  <span class='hs-comment'>-- in order to be used. We also use the term "pattern" to</span>
<a name="line-92"></a>  <span class='hs-comment'>-- differentiate atom compositions as constructors from atoms as</span>
<a name="line-93"></a>  <span class='hs-comment'>-- constructors.</span>
<a name="line-94"></a>  <span class='hs-comment'>--</span>
<a name="line-95"></a>  <span class='hs-comment'>-- The first policy, i.e. the separation of concerns led to the</span>
<a name="line-96"></a>  <span class='hs-comment'>-- so-called /layered process model/ which is reflected in the</span>
<a name="line-97"></a>  <span class='hs-comment'>-- library by providing separate major modules associated with each</span>
<a name="line-98"></a>  <span class='hs-comment'>-- layer. Layers as such are independent collections of entities for</span>
<a name="line-99"></a>  <span class='hs-comment'>-- modeling different aspects of CPS. These aspects interact through</span>
<a name="line-100"></a>  <span class='hs-comment'>-- means of higher-order functions, wrapping each other in as</span>
<a name="line-101"></a>  <span class='hs-comment'>-- structured fashion in a way which can be visualized as below.</span>
<a name="line-102"></a>  <span class='hs-comment'>--</span>
<a name="line-103"></a>  <span class='hs-comment'>-- #layered-model#</span>
<a name="line-104"></a>  <span class='hs-comment'>-- &lt;&lt;docfiles/figs/misc-layered-model.png&gt;&gt;</span>
<a name="line-105"></a>  <span class='hs-comment'>--</span>
<a name="line-106"></a>  <span class='hs-comment'>-- Layers are implemented as type classes which imply:</span>
<a name="line-107"></a>  <span class='hs-comment'>--</span>
<a name="line-108"></a>  <span class='hs-comment'>-- * __atoms__ as function signatures belonging to the type class;</span>
<a name="line-109"></a>  <span class='hs-comment'>--</span>
<a name="line-110"></a>  <span class='hs-comment'>-- * __patterns__ which are compositions atoms, provided as constructors;</span>
<a name="line-111"></a>  <span class='hs-comment'>--</span>
<a name="line-112"></a>  <span class='hs-comment'>-- * __data types__ for all the classes of behaviors concerning the</span>
<a name="line-113"></a>  <span class='hs-comment'>-- aspect described by the layer in question. These types</span>
<a name="line-114"></a>  <span class='hs-comment'>-- instantiate the above type class and overload the atoms with</span>
<a name="line-115"></a>  <span class='hs-comment'>-- semantics in accordance to the behavior described. For example,</span>
<a name="line-116"></a>  <span class='hs-comment'>-- the 'ForSyDe.Atom.MoC.MoC' layer is currently instantiated by</span>
<a name="line-117"></a>  <span class='hs-comment'>-- types describing the 'ForSyDe.Atom.Moc.CT.CT',</span>
<a name="line-118"></a>  <span class='hs-comment'>-- 'ForSyDe.Atom.Moc.DE.DE', 'ForSyDe.Atom.Moc.SY.SY' and</span>
<a name="line-119"></a>  <span class='hs-comment'>-- 'ForSyDe.Atom.Moc.SDF.SDF' MoCs.</span>
<a name="line-120"></a>  <span class='hs-comment'>--</span>
<a name="line-121"></a>  <span class='hs-comment'>-- In order to model interleaving aspects of CPS, layers interact</span>
<a name="line-122"></a>  <span class='hs-comment'>-- with each other through means of higher order functions. As such,</span>
<a name="line-123"></a>  <span class='hs-comment'>-- each layer describes some atoms as higher-order functions which</span>
<a name="line-124"></a>  <span class='hs-comment'>-- take entities belonging to another layer as arguments.</span>
<a name="line-125"></a>  <span class='hs-comment'>-- Intrinsically, the data types belonging to a layer may be wrapping</span>
<a name="line-126"></a>  <span class='hs-comment'>-- types of other layers, as depicted in the &lt;#layered-model figure&gt;</span>
<a name="line-127"></a>  <span class='hs-comment'>-- above. For a short comprehensive overview on layers, please refer</span>
<a name="line-128"></a>  <span class='hs-comment'>-- to &lt;ForSyDe-Atom.html#ungureanu17 [Ungureanu17]&gt;.</span>
<a name="line-129"></a>  <span class='hs-comment'>--</span>
<a name="line-130"></a>  <span class='hs-comment'>-- By convention, the first (innermost) layer is always the</span>
<a name="line-131"></a>  <span class='hs-comment'>-- /function layer/ which describes arbitrary functions on data and</span>
<a name="line-132"></a>  <span class='hs-comment'>-- expresses the system's functional aspects. In the following</span>
<a name="line-133"></a>  <span class='hs-comment'>-- paragraphs we will give an overview of the \"outer\" layers</span>
<a name="line-134"></a>  <span class='hs-comment'>-- currently implemented in @forsyde-atom@, which in comparison,</span>
<a name="line-135"></a>  <span class='hs-comment'>-- express the extra-functional aspects of a system (timing,</span>
<a name="line-136"></a>  <span class='hs-comment'>-- behavior, synchronization, and so on).</span>
<a name="line-137"></a>
<a name="line-138"></a>  <span class='hs-comment'>-- * The Extended Behavior (ExB) Layer</span>
<a name="line-139"></a>
<a name="line-140"></a>  <span class='hs-comment'>-- | As seen in &lt;#layered-model layered process model&gt;, the extended</span>
<a name="line-141"></a>  <span class='hs-comment'>-- behavior layer expands the set of possible behaviors implied by a</span>
<a name="line-142"></a>  <span class='hs-comment'>-- layer (typically the function layer), by defining a set of</span>
<a name="line-143"></a>  <span class='hs-comment'>-- symbols with /known/ semantics, and adding it to (i.e. wrapping)</span>
<a name="line-144"></a>  <span class='hs-comment'>-- the pool of possible values or states.</span>
<a name="line-145"></a>  <span class='hs-comment'>--</span>
<a name="line-146"></a>  <span class='hs-comment'>-- While semantically the 'ExB' layer extends the value pool in</span>
<a name="line-147"></a>  <span class='hs-comment'>-- order to express special events (e.g. error messages or even the</span>
<a name="line-148"></a>  <span class='hs-comment'>-- complete absence of events), it practically provides an</span>
<a name="line-149"></a>  <span class='hs-comment'>-- independent environment to model events with a default/known</span>
<a name="line-150"></a>  <span class='hs-comment'>-- response, independently of the data path. These responses are</span>
<a name="line-151"></a>  <span class='hs-comment'>-- particularly captured by atoms, thus enforcing the high-level</span>
<a name="line-152"></a>  <span class='hs-comment'>-- separation of concerns between e.g. control and data paths.</span>
<a name="line-153"></a>  <span class='hs-comment'>--</span>
<a name="line-154"></a>  <span class='hs-comment'>-- This layer provides:</span>
<a name="line-155"></a>  <span class='hs-comment'>-- </span>
<a name="line-156"></a>  <span class='hs-comment'>-- * a set of extended behavior atoms defining the interfaces for</span>
<a name="line-157"></a>  <span class='hs-comment'>-- the resolution and response functions, as part of the 'ExB' type</span>
<a name="line-158"></a>  <span class='hs-comment'>-- class /(see below)/.</span>
<a name="line-159"></a>  <span class='hs-comment'>--</span>
<a name="line-160"></a>  <span class='hs-comment'>-- * a library of function wrappers as specific atom patterns</span>
<a name="line-161"></a>  <span class='hs-comment'>-- (/Check the "ForSyDe.Atom.ExB" module for extensive/</span>
<a name="line-162"></a>  <span class='hs-comment'>-- /documentation/).</span>
<a name="line-163"></a>  <span class='hs-comment'>--</span>
<a name="line-164"></a>  <span class='hs-comment'>-- * a set of data types defining classes of behaviors and</span>
<a name="line-165"></a>  <span class='hs-comment'>-- instantiating the 'ExB' type class (/check the links in the/</span>
<a name="line-166"></a>  <span class='hs-comment'>-- /&lt;#section.i:ExB instances&gt; section for extensive documentation/).</span>
<a name="line-167"></a>    
<a name="line-168"></a>  <span class='hs-conid'>ExB</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-169"></a>  
<a name="line-170"></a>  <span class='hs-comment'>-- * The Model of Computation (MoC) Layer</span>
<a name="line-171"></a>
<a name="line-172"></a>  <span class='hs-comment'>-- | This layer represents a major part of the @forsyde-atom@</span>
<a name="line-173"></a>  <span class='hs-comment'>-- library and is concerned in modeling the timing aspects of</span>
<a name="line-174"></a>  <span class='hs-comment'>-- CPS. While its foundations have been layered in the classical</span>
<a name="line-175"></a>  <span class='hs-comment'>-- ForSyDe &lt;#sander04 [Sander04]&gt;, it is mainly inspired from</span>
<a name="line-176"></a>  <span class='hs-comment'>-- &lt;#lee98 [Lee98]&gt; an it tries to follow the tagged signal model as</span>
<a name="line-177"></a>  <span class='hs-comment'>-- closely as it is permitted by the host language, and with the</span>
<a name="line-178"></a>  <span class='hs-comment'>-- adaptations require by the atom approach.</span>
<a name="line-179"></a>  <span class='hs-comment'>--</span>
<a name="line-180"></a>  <span class='hs-comment'>-- Although a short introduction of the tagged signal model has been</span>
<a name="line-181"></a>  <span class='hs-comment'>-- written in the introduction of this documentation, we feel</span>
<a name="line-182"></a>  <span class='hs-comment'>-- obliged to provide a primer in the classical ForSyDe theory in</span>
<a name="line-183"></a>  <span class='hs-comment'>-- order to understand how everything fits together.</span>
<a name="line-184"></a>
<a name="line-185"></a>  <span class='hs-comment'>-- ** Signals</span>
<a name="line-186"></a>  
<a name="line-187"></a>  <span class='hs-comment'>-- | &lt;#lee98 [Lee98]&gt; defines signals as (ordered) sets of events</span>
<a name="line-188"></a>  <span class='hs-comment'>-- where each event is composed of a tag /T/ and a value</span>
<a name="line-189"></a>  <span class='hs-comment'>-- /V/. Similarly, in ForSyDe a signal is defined as a (partially or</span>
<a name="line-190"></a>  <span class='hs-comment'>-- totally) /ordered sequence/ of events that enables processes to</span>
<a name="line-191"></a>  <span class='hs-comment'>-- communicate and synchronize. Sequencing might infer an implicit</span>
<a name="line-192"></a>  <span class='hs-comment'>-- order of events, but more importantly it determines an order of</span>
<a name="line-193"></a>  <span class='hs-comment'>-- evaluation, which is a key piece of a simulation engine.</span>
<a name="line-194"></a>  <span class='hs-comment'>--</span>
<a name="line-195"></a>  <span class='hs-comment'>-- &lt;&lt;docfiles/figs/misc-tagged-signal.png&gt;&gt;</span>
<a name="line-196"></a>  <span class='hs-comment'>--</span>
<a name="line-197"></a>  <span class='hs-comment'>-- In ForSyDe-Atom, sequencing is achieved using the 'Stream' data</span>
<a name="line-198"></a>  <span class='hs-comment'>-- type, inspired from &lt;#reekie95 [Reekie95]&gt;. In ForSyDe-Atom,</span>
<a name="line-199"></a>  <span class='hs-comment'>-- signals are streams that carry /events/, where each type of event</span>
<a name="line-200"></a>  <span class='hs-comment'>-- is identified by a type constructor which defines its tag</span>
<a name="line-201"></a>  <span class='hs-comment'>-- system. In other words, we can state that through its tag system,</span>
<a name="line-202"></a>  <span class='hs-comment'>-- a signal is /bound/ to a MoC.</span>
<a name="line-203"></a>
<a name="line-204"></a>  <span class='hs-conid'>Stream</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-205"></a>
<a name="line-206"></a>  <span class='hs-comment'>-- | For extended documentation and a list of all utilities associated</span>
<a name="line-207"></a>  <span class='hs-comment'>-- with the 'Stream' type you can consult:</span>
<a name="line-208"></a>
<a name="line-209"></a>  <span class='hs-keyword'>module</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>MoC</span><span class='hs-varop'>.</span><span class='hs-conid'>Stream</span><span class='hs-layout'>,</span>
<a name="line-210"></a>  
<a name="line-211"></a>  <span class='hs-comment'>-- ** Processes</span>
<a name="line-212"></a>  
<a name="line-213"></a>  <span class='hs-comment'>-- | As described in &lt;#lee98 [Lee98]&gt;, processes are either "set of</span>
<a name="line-214"></a>  <span class='hs-comment'>-- possible behaviors" of signals or "relations" between multiple</span>
<a name="line-215"></a>  <span class='hs-comment'>-- signals. One can describe complex systems by composing processes,</span>
<a name="line-216"></a>  <span class='hs-comment'>-- which in this case is interpreted as the "intersection of the</span>
<a name="line-217"></a>  <span class='hs-comment'>-- behaviors of each of the processes being involved".</span>
<a name="line-218"></a>  <span class='hs-comment'>--</span>
<a name="line-219"></a>  <span class='hs-comment'>-- [monotonicity] In order to ensure causal order and determinancy,</span>
<a name="line-220"></a>  <span class='hs-comment'>-- processes need to be /monotonic/ &lt;#lee98 [Lee98]&gt;. A signal's</span>
<a name="line-221"></a>  <span class='hs-comment'>-- tags (if explicit) /must be/ a partial or total order and all tag</span>
<a name="line-222"></a>  <span class='hs-comment'>-- alterations must be monotonic.</span>
<a name="line-223"></a>  <span class='hs-comment'>--</span>
<a name="line-224"></a>  <span class='hs-comment'>-- ForSyDe inherits this definition with respect to a functional</span>
<a name="line-225"></a>  <span class='hs-comment'>-- view, thus a __process__ /p/ is a functional mapping over (the</span>
<a name="line-226"></a>  <span class='hs-comment'>-- history of) signals. A process can /only/ be instantiated using a</span>
<a name="line-227"></a>  <span class='hs-comment'>-- __process constructor__ /pc/, which is a higher order function</span>
<a name="line-228"></a>  <span class='hs-comment'>-- embedding MoC semantics and/or a specific composition, but</span>
<a name="line-229"></a>  <span class='hs-comment'>-- lacking functionality.</span>
<a name="line-230"></a>  <span class='hs-comment'>--</span>
<a name="line-231"></a>  <span class='hs-comment'>-- #proc-definition#</span>
<a name="line-232"></a>  <span class='hs-comment'>-- &lt;&lt;docfiles/figs/misc-process.png&gt;&gt;</span>
<a name="line-233"></a>  <span class='hs-comment'>--</span>
<a name="line-234"></a>  <span class='hs-comment'>-- Since processes are functions, process composition is equivalent</span>
<a name="line-235"></a>  <span class='hs-comment'>-- to function composition. This means that composing two processes</span>
<a name="line-236"></a>  <span class='hs-comment'>-- @p1@ and @p2@ grants the process @p2 . p1@</span>
<a name="line-237"></a>  <span class='hs-comment'>--</span>
<a name="line-238"></a>  <span class='hs-comment'>-- &gt; p1      :: Signal α -&gt; Signal β</span>
<a name="line-239"></a>  <span class='hs-comment'>-- &gt; p2      :: Signal β -&gt; Signal γ</span>
<a name="line-240"></a>  <span class='hs-comment'>-- &gt; p2 . p1 :: Signal α -&gt; Signal γ</span>
<a name="line-241"></a>  <span class='hs-comment'>--</span>
<a name="line-242"></a>  <span class='hs-comment'>--  This implies that there is a signal @Signal beta @ that</span>
<a name="line-243"></a>  <span class='hs-comment'>--  "streams" the result from @p1@ to @p2@, as suggested in the</span>
<a name="line-244"></a>  <span class='hs-comment'>--  drawing:</span>
<a name="line-245"></a>  <span class='hs-comment'>--</span>
<a name="line-246"></a>  <span class='hs-comment'>-- &lt;&lt;docfiles/figs/misc-ser-composition.png&gt;&gt;</span>
<a name="line-247"></a>  <span class='hs-comment'>--</span>
<a name="line-248"></a>  <span class='hs-comment'>-- __Process networks__ describe ForSyDe systems in terms of</span>
<a name="line-249"></a>  <span class='hs-comment'>-- compositions of processes and originate from Reekie's process</span>
<a name="line-250"></a>  <span class='hs-comment'>-- nets &lt;#reekie95 [Reekie95]&gt;. A process network is a process itself,</span>
<a name="line-251"></a>  <span class='hs-comment'>-- i.e. function from signal(s) to signal(s). The composition above</span>
<a name="line-252"></a>  <span class='hs-comment'>-- @p2 . p1 @ can also be regarded as a process network.</span>
<a name="line-253"></a>  <span class='hs-comment'>--</span>
<a name="line-254"></a>  <span class='hs-comment'>-- In ForSyDe-Atom atoms can be regarded as process constructors as</span>
<a name="line-255"></a>  <span class='hs-comment'>-- their instantiations are functions on signals of events.</span>
<a name="line-256"></a>  <span class='hs-comment'>-- Instantiations of atom patterns are the exact equivalent of</span>
<a name="line-257"></a>  <span class='hs-comment'>-- process networks, which themselves are also processes, depending</span>
<a name="line-258"></a>  <span class='hs-comment'>-- on the level of abstraction you are working with (hierarchical</span>
<a name="line-259"></a>  <span class='hs-comment'>-- blocks vs. flat structures).</span>
<a name="line-260"></a>  <span class='hs-comment'>--</span>
<a name="line-261"></a>  <span class='hs-comment'>-- To understand the versatility of composition and partial</span>
<a name="line-262"></a>  <span class='hs-comment'>-- application in building process constructors, consider the</span>
<a name="line-263"></a>  <span class='hs-comment'>-- example above where composition of two processes infers a signal</span>
<a name="line-264"></a>  <span class='hs-comment'>-- between them. This mechanism also works when composing</span>
<a name="line-265"></a>  <span class='hs-comment'>-- constructors (un-instantiated atoms), which yields another</span>
<a name="line-266"></a>  <span class='hs-comment'>-- constructor. By instantiating (fully applying) the new</span>
<a name="line-267"></a>  <span class='hs-comment'>-- constructor we obtain a process network equivalent to the</span>
<a name="line-268"></a>  <span class='hs-comment'>-- composition of the respective primitive processes obtained by</span>
<a name="line-269"></a>  <span class='hs-comment'>-- instantiating (fully applying) the component atoms, like in the</span>
<a name="line-270"></a>  <span class='hs-comment'>-- example below:</span>
<a name="line-271"></a>  <span class='hs-comment'>--</span>
<a name="line-272"></a>  <span class='hs-comment'>-- &lt;&lt;docfiles/figs/misc-process-constructor.png&gt;&gt;</span>
<a name="line-273"></a>  <span class='hs-comment'>--</span>
<a name="line-274"></a>  <span class='hs-comment'>-- Now if we visualize process networks as graphs, where processes</span>
<a name="line-275"></a>  <span class='hs-comment'>-- are nodes and signals are edges, a meaningful process composition</span>
<a name="line-276"></a>  <span class='hs-comment'>-- could be regarded as graph patterns. Therefore it is safe to</span>
<a name="line-277"></a>  <span class='hs-comment'>-- associate process constructors as patterns in process networks.</span>
<a name="line-278"></a>
<a name="line-279"></a>  <span class='hs-comment'>-- ** Models of Computation</span>
<a name="line-280"></a>  
<a name="line-281"></a>  <span class='hs-comment'>-- | As mentioned in the introduction, /MoCs/ are classes of behaviors</span>
<a name="line-282"></a>  <span class='hs-comment'>-- dictating the semantics of execution and concurrency in a network</span>
<a name="line-283"></a>  <span class='hs-comment'>-- of processes. Based on the definitions of their tag systems</span>
<a name="line-284"></a>  <span class='hs-comment'>-- ForSyDe identifies MoCs as:</span>
<a name="line-285"></a>  <span class='hs-comment'>--</span>
<a name="line-286"></a>  <span class='hs-comment'>-- 1. /timed/ where /T/ is a totally ordered set and /t/ express the</span>
<a name="line-287"></a>  <span class='hs-comment'>-- notion of physical time (e.g. continuous time</span>
<a name="line-288"></a>  <span class='hs-comment'>-- 'ForSyDe.Atom.MoC.CT.CT', discrete event</span>
<a name="line-289"></a>  <span class='hs-comment'>-- 'ForSyDe.Atom.MoC.DE.DE') or precedence (e.g. synchronous</span>
<a name="line-290"></a>  <span class='hs-comment'>-- 'ForSyDe.Atom.MoC.SY.SY');</span>
<a name="line-291"></a>  <span class='hs-comment'>--</span>
<a name="line-292"></a>  <span class='hs-comment'>-- 1. /untimed/, where /T/ is a partially ordered set and /t/ is</span>
<a name="line-293"></a>  <span class='hs-comment'>-- expressed in terms of constraints on the tags in signals</span>
<a name="line-294"></a>  <span class='hs-comment'>-- (e.g. dataflow, synchronous data flow</span>
<a name="line-295"></a>  <span class='hs-comment'>-- 'ForSyDe.Atom.MoC.SDF.SDF').</span>
<a name="line-296"></a>  <span class='hs-comment'>--</span>
<a name="line-297"></a>  <span class='hs-comment'>-- As concerning MoCs, ForSyDe implements the execution semantics</span>
<a name="line-298"></a>  <span class='hs-comment'>-- /through process constructors/, abstracting the timing model and</span>
<a name="line-299"></a>  <span class='hs-comment'>-- inferring a schedule of the process network. In ForSyDe-Atom all</span>
<a name="line-300"></a>  <span class='hs-comment'>-- atoms embed operating semantics dictated by a certain MoC and are</span>
<a name="line-301"></a>  <span class='hs-comment'>-- side-effect-free. This ensures the functional correctness of a</span>
<a name="line-302"></a>  <span class='hs-comment'>-- system even from early design stages.</span>
<a name="line-303"></a>
<a name="line-304"></a>  <span class='hs-comment'>-- ** Representing Time</span>
<a name="line-305"></a>  
<a name="line-306"></a>  <span class='hs-comment'>-- | For explicit time representation, ForSyDe-atom provides two</span>
<a name="line-307"></a>  <span class='hs-comment'>-- distinct data types.</span>
<a name="line-308"></a>
<a name="line-309"></a>  <span class='hs-conid'>Time</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>TimeStamp</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-310"></a>
<a name="line-311"></a>  <span class='hs-comment'>-- ** MoC Layer Overview</span>
<a name="line-312"></a>
<a name="line-313"></a>  <span class='hs-comment'>-- | This layer consists of:</span>
<a name="line-314"></a>  <span class='hs-comment'>--</span>
<a name="line-315"></a>  <span class='hs-comment'>-- * 4 atoms as infix operators, implemented as methods of the type</span>
<a name="line-316"></a>  <span class='hs-comment'>-- class 'MoC'. Since each MoC is determined by its tag system, we</span>
<a name="line-317"></a>  <span class='hs-comment'>-- expose this </span>
<a name="line-318"></a>  <span class='hs-comment'>-- which are instances of this class. Thus an event's type will</span>
<a name="line-319"></a>  <span class='hs-comment'>-- trigger an atom to behave in accordance to its associated MoC.</span>
<a name="line-320"></a>  <span class='hs-comment'>--</span>
<a name="line-321"></a>  <span class='hs-comment'>-- * a library of meaningful atom patterns as process constructors.</span>
<a name="line-322"></a>  <span class='hs-comment'>-- (/Check the "ForSyDe.Atom.MoC" module for extensive/</span>
<a name="line-323"></a>  <span class='hs-comment'>-- /documentation/).</span>
<a name="line-324"></a>  <span class='hs-comment'>--</span>
<a name="line-325"></a>  <span class='hs-comment'>-- * a set of data types defining tag systems through the structure</span>
<a name="line-326"></a>  <span class='hs-comment'>-- of events (i.e. /T/ &amp;#215; /V/). They are instances of the 'MoC'</span>
<a name="line-327"></a>  <span class='hs-comment'>-- type class and define the rules of execution that will trigger an</span>
<a name="line-328"></a>  <span class='hs-comment'>-- atom to behave in accordance to its associated MoC. For each</span>
<a name="line-329"></a>  <span class='hs-comment'>-- supported MoC, @forsyde-atom@ provides a module which defines the</span>
<a name="line-330"></a>  <span class='hs-comment'>-- signal (event) type, but also a set of utilities and process</span>
<a name="line-331"></a>  <span class='hs-comment'>-- constructors as specific instantiations of atom patterns.</span>
<a name="line-332"></a>  <span class='hs-comment'>-- (/Check the links in the &lt;#section.i:MoC instances&gt; section for/</span>
<a name="line-333"></a>  <span class='hs-comment'>-- /extensive documentation/).</span>
<a name="line-334"></a>  
<a name="line-335"></a>  <span class='hs-conid'>MoC</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>  
<a name="line-336"></a>
<a name="line-337"></a>  <span class='hs-comment'>-- * The Skeleton Layer</span>
<a name="line-338"></a>
<a name="line-339"></a>  <span class='hs-comment'>-- | The skeleton layer describes recursive and regular composition</span>
<a name="line-340"></a>  <span class='hs-comment'>-- of processes which expose inherent potential for parallelism. As</span>
<a name="line-341"></a>  <span class='hs-comment'>-- such, it wraps lower layer entities (i.e. processes, signals),</span>
<a name="line-342"></a>  <span class='hs-comment'>-- into regular structures called /categorical types/. Most of the</span>
<a name="line-343"></a>  <span class='hs-comment'>-- ground work for this layer is based on the categorical type</span>
<a name="line-344"></a>  <span class='hs-comment'>-- theory &lt;#bird97 [Bird97]&gt;, which enable the description of</span>
<a name="line-345"></a>  <span class='hs-comment'>-- algorithmic skeletons as high-level constructs encapsulating</span>
<a name="line-346"></a>  <span class='hs-comment'>-- parallelism and communication with an associated cost complexity.</span>
<a name="line-347"></a>  <span class='hs-comment'>--</span>
<a name="line-348"></a>  <span class='hs-comment'>-- This layer provides:</span>
<a name="line-349"></a>  <span class='hs-comment'>--</span>
<a name="line-350"></a>  <span class='hs-comment'>-- * 3 atoms as infix operators which, as demonstrated in &lt;#bird97 [Bird97]&gt;</span>
<a name="line-351"></a>  <span class='hs-comment'>-- and &lt;#skillicorn05 [Skillicorn05]&gt;, are enough to describe /all/</span>
<a name="line-352"></a>  <span class='hs-comment'>-- algorithmic skeletons.</span>
<a name="line-353"></a>  <span class='hs-comment'>--</span>
<a name="line-354"></a>  <span class='hs-comment'>-- * a library of generic skeletons as specific atom patterns.</span>
<a name="line-355"></a>  <span class='hs-comment'>-- (/Check the "ForSyDe.Atom.Skeleton" module for extensive/</span>
<a name="line-356"></a>  <span class='hs-comment'>-- /documentation/).</span>
<a name="line-357"></a>  <span class='hs-comment'>--</span>
<a name="line-358"></a>  <span class='hs-comment'>-- * a set of different categorical types which implement these</span>
<a name="line-359"></a>  <span class='hs-comment'>-- atoms, as instances of the 'Skeleton' type class. These types</span>
<a name="line-360"></a>  <span class='hs-comment'>-- provide additional skeletons patterns of atoms which takes as</span>
<a name="line-361"></a>  <span class='hs-comment'>-- arguments their own type constructors.</span>
<a name="line-362"></a>  <span class='hs-comment'>-- (/Check the links in the &lt;#section.i:Skeleton instances&gt; section for/</span>
<a name="line-363"></a>  <span class='hs-comment'>-- /extensive documentation/).</span>
<a name="line-364"></a>  
<a name="line-365"></a>  <span class='hs-conid'>Skeleton</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-366"></a>
<a name="line-367"></a>  <span class='hs-comment'>-- * Utilities</span>
<a name="line-368"></a>
<a name="line-369"></a>  <span class='hs-comment'>-- | The 'ForSyDe.Atom' module exports a set of utility functions,</span>
<a name="line-370"></a>  <span class='hs-comment'>-- mainly for aiding the designer to avoid working with zipped</span>
<a name="line-371"></a>  <span class='hs-comment'>-- tuples which might pollute the design. Utilities are function</span>
<a name="line-372"></a>  <span class='hs-comment'>-- without any semantical value (thus not considered atoms). They</span>
<a name="line-373"></a>  <span class='hs-comment'>-- operate on and might alter the /structure/ of some datum, but it</span>
<a name="line-374"></a>  <span class='hs-comment'>-- does not affect its state.</span>
<a name="line-375"></a>  <span class='hs-comment'>--</span>
<a name="line-376"></a>  <span class='hs-comment'>-- For a list of all the provided utilities, please consult the</span>
<a name="line-377"></a>  <span class='hs-comment'>-- following module:</span>
<a name="line-378"></a>
<a name="line-379"></a>  <span class='hs-keyword'>module</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>Utility</span><span class='hs-layout'>,</span>
<a name="line-380"></a>
<a name="line-381"></a>  <span class='hs-comment'>-- | Among the most useful utilities we mentions the @unzip@</span>
<a name="line-382"></a>  <span class='hs-comment'>-- function. Recall that in all our definitions for patterns, they</span>
<a name="line-383"></a>  <span class='hs-comment'>-- were expressed in the most general form as functions from /n/-ary</span>
<a name="line-384"></a>  <span class='hs-comment'>-- Cartesian products to /m/-ary Cartesian products. While partial</span>
<a name="line-385"></a>  <span class='hs-comment'>-- application provides a versatile mechanism that can translate</span>
<a name="line-386"></a>  <span class='hs-comment'>-- n-ary inputs into curried arguments (which is very powerful in</span>
<a name="line-387"></a>  <span class='hs-comment'>-- combination with an applicative style), we cannot do so for</span>
<a name="line-388"></a>  <span class='hs-comment'>-- return types. For the latter we must rely on tuples. But working</span>
<a name="line-389"></a>  <span class='hs-comment'>-- with tuples of data wrapped in several layers of structures</span>
<a name="line-390"></a>  <span class='hs-comment'>-- becomes extremely cumbersome. Take for example the case of a</span>
<a name="line-391"></a>  <span class='hs-comment'>-- process constructed with /pc/ in equation (1) below. Using only</span>
<a name="line-392"></a>  <span class='hs-comment'>-- the provided atoms to implement /pc/ would give us a process</span>
<a name="line-393"></a>  <span class='hs-comment'>-- which returns only one signal of a tuple and not, as we would</span>
<a name="line-394"></a>  <span class='hs-comment'>-- like, a tuple of signals of events.</span>
<a name="line-395"></a>  <span class='hs-comment'>--</span>
<a name="line-396"></a>  <span class='hs-comment'>-- &lt;&lt;docfiles/figs/misc-unzip.png&gt;&gt;</span>
<a name="line-397"></a>  <span class='hs-comment'>--</span>
<a name="line-398"></a>  <span class='hs-comment'>-- Therefore, by implementing all data types associated with signals</span>
<a name="line-399"></a>  <span class='hs-comment'>-- and events as instances of 'Functor', we were able to provide a</span>
<a name="line-400"></a>  <span class='hs-comment'>-- (set of) /unzip/ utility functions defined as in equation (2)</span>
<a name="line-401"></a>  <span class='hs-comment'>-- above, in the "ForSyDe.Atom.Utility" module.  Mind that we call</span>
<a name="line-402"></a>  <span class='hs-comment'>-- /unzip/ a utility and not an atom, since it has no</span>
<a name="line-403"></a>  <span class='hs-comment'>-- synchronization nor behavior semantic. It just conveniently</span>
<a name="line-404"></a>  <span class='hs-comment'>-- "lifts" the wrapped tuples in order to create "collections" of</span>
<a name="line-405"></a>  <span class='hs-comment'>-- events and signals, and it is imposed by the mechanisms of the</span>
<a name="line-406"></a>  <span class='hs-comment'>-- type system in the host language.</span>
<a name="line-407"></a>
<a name="line-408"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>||&lt;</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-409"></a>  
<a name="line-410"></a>  <span class='hs-comment'>-- * Bibliography</span>
<a name="line-411"></a>
<a name="line-412"></a>  <span class='hs-comment'>-- | #bird87# &lt;https://www.cs.ox.ac.uk/files/3378/PRG56.pdf [Bird87]&gt; Bird, R. S. (1987). An introduction to the theory of lists. In /Logic of programming and calculi of discrete design/ (pp. 5-42). Springer Berlin Heidelberg.</span>
<a name="line-413"></a>
<a name="line-414"></a>  <span class='hs-comment'>-- | #bird97# &lt;<a href="http://dl.acm.org/citation.cfm?id=248932">http://dl.acm.org/citation.cfm?id=248932</a> [Bird97]&gt; Bird, R. S. &amp; de Moor, O. (1997). Algebra of Programming. Prentice-Hall, Inc., Upper Saddle River, NJ, USA. </span>
<a name="line-415"></a>
<a name="line-416"></a>  <span class='hs-comment'>-- | #fuji00# [Fujimoto00] Fujimoto, R. M. (2000). Parallel and distributed simulation systems (Vol. 300). New York: Wiley.</span>
<a name="line-417"></a>  
<a name="line-418"></a>  <span class='hs-comment'>-- | #halbwachs91# &lt;<a href="http://ieeexplore.ieee.org/document/97300/">http://ieeexplore.ieee.org/document/97300/</a> [Halbwachs91]&gt; Halbwachs, N., Caspi, P., Raymond, P., &amp; Pilaud, D. (1991). The synchronous data flow programming language LUSTRE. /Proceedings of the IEEE, 79(9)/, 1305-1320.</span>
<a name="line-419"></a>
<a name="line-420"></a>  <span class='hs-comment'>-- | #gorlatch03# &lt;<a href="http://link.springer.com/chapter/10.1007/978-1-4471-0097-3_1#page-1">http://link.springer.com/chapter/10.1007/978-1-4471-0097-3_1#page-1</a> [Gorlatch03]&gt; Fischer, J., Gorlatch, S., &amp; Bischof, H. (2003). Foundations of data-parallel skeletons. In /Patterns and skeletons for parallel and distributed computing/ (pp. 1-27). Springer London.</span>
<a name="line-421"></a>  
<a name="line-422"></a>  <span class='hs-comment'>-- | #kahn76# [Kahn76] Kahn, G., &amp; MacQueen, D. (1976). Coroutines and networks of parallel processes.</span>
<a name="line-423"></a>
<a name="line-424"></a>  <span class='hs-comment'>-- | #lee98# [Lee98] Lee, E. A., &amp; Sangiovanni-Vincentelli, A. (1998). A framework for comparing models of computation. /IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 17(12)/, 1217-1229. </span>
<a name="line-425"></a>
<a name="line-426"></a>  <span class='hs-comment'>-- | #reekie95# &lt;<a href="http://ptolemy.eecs.berkeley.edu/~johnr/papers/pdf/thesis.pdf">http://ptolemy.eecs.berkeley.edu/~johnr/papers/pdf/thesis.pdf</a> [Reekie95]&gt; Reekie, H. J. (1995). Realtime signal processing: Dataflow, visual, and functional programming.</span>
<a name="line-427"></a>  
<a name="line-428"></a>  <span class='hs-comment'>-- | #sander04# &lt;<a href="http://people.kth.se/~ingo/Papers/TCAD2004_SystemModeling.pdf">http://people.kth.se/~ingo/Papers/TCAD2004_SystemModeling.pdf</a> [Sander04]&gt; Sander, I., &amp; Jantsch, A. (2004). System modeling and transformational design refinement in ForSyDe [formal system design]. /IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 23(1)/, 17-32.</span>
<a name="line-429"></a>    
<a name="line-430"></a>  <span class='hs-comment'>-- | #skillicorn05# &lt;https://books.google.se/books?hl=ro&amp;lr=&amp;id=rQwsL5xsZigC&amp;oi=fnd&amp;pg=PP1&amp;dq=skillicorn+foundation+parallel+programming&amp;ots=UJMBr0uO2Q&amp;sig=ncyXxE0gFNkUZwVOYyFb_ezWlGY&amp;redir_esc=y#v=onepage&amp;q=skillicorn%20foundation%20parallel%20programming&amp;f=false [Skillicorn05]&gt; Skillicorn, D. B. (2005). Foundations of parallel programming (No. 6). Cambridge University Press.</span>
<a name="line-431"></a>
<a name="line-432"></a>  <span class='hs-comment'>-- | #ungureanu17# &lt;<a href="http://ieeexplore.ieee.org/document/7927270/">http://ieeexplore.ieee.org/document/7927270/</a> [Ungureanu17]&gt; Ungureanu, G., &amp; Sander, I., /A layered formal framework for modeling of cyber-physical systems/, in 2017 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE), 2017, pp. 1715–1720.</span>
<a name="line-433"></a>  
<a name="line-434"></a><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-435"></a>
<a name="line-436"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>ExB</span>
<a name="line-437"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>MoC</span>
<a name="line-438"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>MoC</span><span class='hs-varop'>.</span><span class='hs-conid'>Stream</span>
<a name="line-439"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>MoC</span><span class='hs-varop'>.</span><span class='hs-conid'>Time</span>
<a name="line-440"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>MoC</span><span class='hs-varop'>.</span><span class='hs-conid'>TimeStamp</span>
<a name="line-441"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>Skeleton</span>
<a name="line-442"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ForSyDe</span><span class='hs-varop'>.</span><span class='hs-conid'>Atom</span><span class='hs-varop'>.</span><span class='hs-conid'>Utility</span>
<a name="line-443"></a>
</pre></body>
</html>
