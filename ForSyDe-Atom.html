<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ForSyDe.Atom</title><link href="ocean.css" rel="stylesheet" type="text/css" title="ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_ForSyDe-Atom.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/ForSyDe-Atom.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">forsyde-atom-0.2.0.0: A shallow-embedded DSL for modeling cyber-physical systems</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) George Ungureanu, KTH/ICT/ESY 2015-2016;</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ForSyDe.Atom</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The layered process model</a></li><li><a href="#g:2">The Extended Behavior (ExB) Layer</a></li><li><a href="#g:3">The Model of Computation (MoC) Layer</a><ul><li><a href="#g:4">Signals</a></li><li><a href="#g:5">Processes</a></li><li><a href="#g:6">Models of Computation</a></li><li><a href="#g:7">Representing Time</a></li><li><a href="#g:8">MoC Layer Overview</a></li></ul></li><li><a href="#g:9">The Skeleton Layer</a></li><li><a href="#g:10">Utilities</a></li><li><a href="#g:11">Bibliography</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The formal foundation upon which ForSyDe <a href="#sander04">[Sander04]</a>
 defines its semantics is the <em>tagged signal model</em>
 <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>.  This is a denotational
 framework introduced by Lee and Sangiovanni-Vincentelli as a common
 meta model for describing properties of concurrent systems in
 general terms as sets of possible behaviors. Systems are regarded
 as <em>compositions</em> of <em>processes</em> acting on <em>signals</em> which are sets
 of <em>tagged events</em>. Signals are characterized by a <em>tag system</em>
 which determines causality between events, and could model time,
 precedence relationships, synchronization points, and other key
 properties. Based on how tag systems are defined, one can identify
 several <em>Models of Computations (MoCs)</em> as classes of behaviors
 dictating the semantics of execution and concurrency in a network
 of processes.</p><p>These concepts are the supporting pillars of ForSyDe's philosophy,
 and state the purpose of the <code>forsyde-atom</code> library: it is supposed
 to be a modelling framework used as a proof-of-concept for the
 atom-based approach to cyber-physical systems
 <a href="ForSyDe-Atom.html#ungureanu17">[Ungureanu17]</a>. This approach
 extends the tagged signal model by systematically deconstructing
 processes to their basic semantics and recreating them using a
 minimal language of primitive building blocks called <em>atoms</em>. It
 also tries to expand the scope of this model by exploiting more
 aspects than just timing, by adding primitives for parallelism,
 behavior, etc.</p><p>The API documentation is structured as follows: this page provides
 an overview of the general notions and concepts, gently introducing
 the separate modules and the motivation behind them. Each major
 module corresponds to a separate <em>layer</em>
 <a href="ForSyDe-Atom.html#ungureanu17">[Ungureanu17]</a> implemented as a type
 class. The documentation pages for each layer and for each of their
 instances contains in-depth knowledge and examples, and can be
 accessed from the contents page or by following the links
 suggested. For more complex examples and tutorials follow the links
 in the <a href="https://github.com/forsyde/forsyde-atom">project web page</a>.</p><p><a name="naming_conv"></a> <strong>IMPORTANT!!!</strong> All multi-parameter patterns and
 utilities provided by the library API as higher-order functions are
 named along the lines of <code>functionMN</code> where <code>M</code> represents the
 number of <strong><em>curried</em></strong> inputs (i.e. <code>a1 -&gt; a2 -&gt; ... -&gt; aM</code>),
 while <code>N</code> represents the number of <strong><em>tupled</em></strong> outputs
 (i.e. <code>(b1,b2,...,bN)</code>). To avoid repetition we only provide
 documentation for functions with 2 inputs and 2 outputs
 (i.e. <code>function22</code>). In case the provided functions do not suffice,
 feel free to implement your own patterns following the examples in
 the source code.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> Functor b =&gt; <a href="#t:ExB">ExB</a> b <span class="keyword">where</span><ul class="subs"><li><a href="#v:extend">extend</a> :: a -&gt; b a</li><li><a href="#v:-47-.-92-">(/.\)</a> :: (a -&gt; a') -&gt; b a -&gt; b a'</li><li><a href="#v:-47--42--92-">(/*\)</a> :: b (a -&gt; a') -&gt; b a -&gt; b a'</li><li><a href="#v:-47--38--92-">(/&amp;\)</a> :: b Bool -&gt; b a -&gt; b a</li><li><a href="#v:-47--33--92-">(/!\)</a> :: a -&gt; b a -&gt; a</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Stream">Stream</a> e<ul class="subs"><li>= <a href="#v:NullS">NullS</a></li><li>| e <a href="#v::-45-">:-</a> (<a href="ForSyDe-Atom.html#t:Stream">Stream</a> e)</li></ul></li><li class="src short">module <a href="ForSyDe-Atom-MoC-Stream.html">ForSyDe.Atom.MoC.Stream</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Time">Time</a> = Rational</li><li class="src short"><span class="keyword">type</span> <a href="#t:TimeStamp">TimeStamp</a> = DiffTime</li><li class="src short"><span class="keyword">class</span> Applicative e =&gt; <a href="#t:MoC">MoC</a> e <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:Fun">Fun</a> e a b</li><li><span class="keyword">type</span> <a href="#t:Ret">Ret</a> e b</li><li><a href="#v:-45-.-45-">(-.-)</a> :: <a href="ForSyDe-Atom.html#t:Fun">Fun</a> e a b -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e b)</li><li><a href="#v:-45--42--45-">(-*-)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e (<a href="ForSyDe-Atom.html#t:Fun">Fun</a> e a b)) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e b)</li><li><a href="#v:-45--42-">(-*)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e (<a href="ForSyDe-Atom.html#t:Ret">Ret</a> e b)) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e b)</li><li><a href="#v:-45--60--45-">(-&lt;-)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a)</li><li><a href="#v:-45--38--45-">(-&amp;-)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a)</li></ul></li><li class="src short"><span class="keyword">class</span> Functor c =&gt; <a href="#t:Skeleton">Skeleton</a> c <span class="keyword">where</span><ul class="subs"><li><a href="#v:-61-.-61-">(=.=)</a> :: (a -&gt; b) -&gt; c a -&gt; c b</li><li><a href="#v:-61--42--61-">(=*=)</a> :: c (a -&gt; b) -&gt; c a -&gt; c b</li><li><a href="#v:-61--92--61-">(=\=)</a> :: (a -&gt; a -&gt; a) -&gt; c a -&gt; a</li><li><a href="#v:-61--60--60--61-">(=&lt;&lt;=)</a> :: c (a -&gt; a) -&gt; a -&gt; a</li><li><a href="#v:first">first</a> :: c a -&gt; a</li><li><a href="#v:last">last</a> :: c a -&gt; a</li></ul></li><li class="src short">module <a href="ForSyDe-Atom-Utility.html">ForSyDe.Atom.Utility</a></li><li class="src short"><a href="#v:-124--124--60-">(||&lt;)</a> :: (Functor f1, Functor f2) =&gt; f1 (f2 (a1, a2)) -&gt; (f1 (f2 a1), f1 (f2 a2))</li></ul></div><div id="interface"><h1 id="g:1">The layered process model</h1><div class="doc"><p>The <code>forsyde-atom</code> project is led by three main policies:</p><ol><li>in order to cope with the complexity of cyber-physical systems
 (CPS) it tries to separate the concerns such as computation,
 timing, synchronization, parallelism, structure, behavior, etc.</li><li>in order to have a small, ideally minimal grammar to reason
 about systems correctness, it aims to provide primitive
 (indivisible) operators called <em>atoms</em> as building blocks for
 independently developing complex aspects of a system's execution
 through means of composition or generalization.</li><li>in order to express complex behaviors with a minimal grammar,
 it decouples structure (composition) from meaning (semantics),
 the only semantics carriers being atoms. Thus complex behaviors
 can be described in terms of <em>patterns of atoms</em>. Using ad-hoc
 polymorphism, atoms can be overloaded with different semantics
 triggered by the data type they input, whereas their composition
 is always the same.</li></ol><dl><dt><code>atom</code></dt><dd>the elementary (primitive, indivisible) constructor
 which embeds a set of semantics relevant for their respective
 layer (e.g. timing, behavioural, structural, etc.)</dd><dt><code>atom patterns</code></dt><dd>meaningful compositions of atoms. They are
 provided as constructors which need to be properly instantiated
 in order to be used. We also use the term &quot;pattern&quot; to
 differentiate atom compositions as constructors from atoms as
 constructors.</dd></dl><p>The first policy, i.e. the separation of concerns led to the
 so-called <em>layered process model</em> which is reflected in the
 library by providing separate major modules associated with each
 layer. Layers as such are independent collections of entities for
 modeling different aspects of CPS. These aspects interact through
 means of higher-order functions, wrapping each other in as
 structured fashion in a way which can be visualized as below.</p><p><a name="layered-model"></a>
 <img src="docfiles/figs/misc-layered-model.png" /></p><p>Layers are implemented as type classes which imply:</p><ul><li><strong>atoms</strong> as function signatures belonging to the type class;</li><li><strong>patterns</strong> which are compositions atoms, provided as constructors;</li><li><strong>data types</strong> for all the classes of behaviors concerning the
 aspect described by the layer in question. These types
 instantiate the above type class and overload the atoms with
 semantics in accordance to the behavior described. For example,
 the <code><a href="ForSyDe-Atom.html#t:MoC">MoC</a></code> layer is currently instantiated by
 types describing the <code><a href="ForSyDe-Atom-Moc-CT.html#v:CT">CT</a></code>,
 <code><a href="ForSyDe-Atom-Moc-DE.html#v:DE">DE</a></code>, <code><a href="ForSyDe-Atom-Moc-SY.html#v:SY">SY</a></code> and
 <code><a href="ForSyDe-Atom-Moc-SDF.html#v:SDF">SDF</a></code> MoCs.</li></ul><p>In order to model interleaving aspects of CPS, layers interact
 with each other through means of higher order functions. As such,
 each layer describes some atoms as higher-order functions which
 take entities belonging to another layer as arguments.
 Intrinsically, the data types belonging to a layer may be wrapping
 types of other layers, as depicted in the <a href="#layered-model">figure</a>
 above. For a short comprehensive overview on layers, please refer
 to <a href="ForSyDe-Atom.html#ungureanu17">[Ungureanu17]</a>.</p><p>By convention, the first (innermost) layer is always the
 <em>function layer</em> which describes arbitrary functions on data and
 expresses the system's functional aspects. In the following
 paragraphs we will give an overview of the &quot;outer&quot; layers
 currently implemented in <code>forsyde-atom</code>, which in comparison,
 express the extra-functional aspects of a system (timing,
 behavior, synchronization, and so on).</p></div><h1 id="g:2">The Extended Behavior (ExB) Layer</h1><div class="doc"><p>As seen in <a href="#layered-model">layered process model</a>, the extended
 behavior layer expands the set of possible behaviors implied by a
 layer (typically the function layer), by defining a set of
 symbols with <em>known</em> semantics, and adding it to (i.e. wrapping)
 the pool of possible values or states.</p><p>While semantically the <code><a href="ForSyDe-Atom.html#t:ExB">ExB</a></code> layer extends the value pool in
 order to express special events (e.g. error messages or even the
 complete absence of events), it practically provides an
 independent environment to model events with a default/known
 response, independently of the data path. These responses are
 particularly captured by atoms, thus enforcing the high-level
 separation of concerns between e.g. control and data paths.</p><p>This layer provides:</p><ul><li>a set of extended behavior atoms defining the interfaces for
 the resolution and response functions, as part of the <code><a href="ForSyDe-Atom.html#t:ExB">ExB</a></code> type
 class <em>(see below)</em>.</li><li>a library of function wrappers as specific atom patterns
 (<em>Check the <a href="ForSyDe-Atom-ExB.html">ForSyDe.Atom.ExB</a> module for extensive</em>
 <em>documentation</em>).</li><li>a set of data types defining classes of behaviors and
 instantiating the <code><a href="ForSyDe-Atom.html#t:ExB">ExB</a></code> type class (<em>check the links in the</em>
 <em><a href="#section.i:ExB">instances</a> section for extensive documentation</em>).</li></ul></div><div class="top"><p class="src"><span class="keyword">class</span> Functor b =&gt; <a name="t:ExB" class="def">ExB</a> b <span class="keyword">where</span> <a href="src/ForSyDe-Atom-ExB.html#ExB" class="link">Source</a></p><div class="doc"><p>Class which defines the atoms for the extended behavior layer.</p><p>As its name suggests, this layer is extending the behavior of
 processes (or merely of functions if we ignore timing semantics
 completely), by expanding the domains of the wrapped layer
 (e.g. the set of values) with symbols having clearly-defined
 semantics (e.g. special events with known responses).</p><p>The types associated with this layer can simply be describes as:</p><p><img src="docfiles/figs/eqs-exb-types.png" /></p><p>where  <em>&#945;</em> is a base type and <em>b</em> is the type extension,
 i.e. a set of symbols with clearly-defined semantics.</p><p>Extended behavior atoms are functions of these types, defined as
 interfaces in the <code><a href="ForSyDe-Atom.html#t:ExB">ExB</a></code> type class.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:extend" class="def">extend</a> :: a -&gt; b a <a href="src/ForSyDe-Atom-ExB.html#extend" class="link">Source</a></p><div class="doc"><p>Extends a value (from a layer below) with a set of symbols with
 known semantics, as described by a type instantiating this class.</p></div><p class="src"><a name="v:-47-.-92-" class="def">(/.\)</a> :: (a -&gt; a') -&gt; b a -&gt; b a' <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-ExB.html#%2F.%5C" class="link">Source</a></p><div class="doc"><p>Basic functor operator. Lifts a function (from a layer below)
 into the domain of the extended behavior layer.</p><p><img src="docfiles/figs/eqs-exb-atom-func.png" /></p></div><p class="src"><a name="v:-47--42--92-" class="def">(/*\)</a> :: b (a -&gt; a') -&gt; b a -&gt; b a' <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-ExB.html#%2F%2A%5C" class="link">Source</a></p><div class="doc"><p>Applicative operator. Defines a res between two extended
 behavior symbols.</p><p><img src="docfiles/figs/eqs-exb-atom-app.png" /></p></div><p class="src"><a name="v:-47--38--92-" class="def">(/&amp;\)</a> :: b Bool -&gt; b a -&gt; b a <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-ExB.html#%2F%26%5C" class="link">Source</a></p><div class="doc"><p>Predicate operator. Generates a defined behavior based on an
 extended Boolean predicate.</p><p><img src="docfiles/figs/eqs-exb-atom-phi.png" /></p></div><p class="src"><a name="v:-47--33--92-" class="def">(/!\)</a> :: a -&gt; b a -&gt; a <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-ExB.html#%2F%21%5C" class="link">Source</a></p><div class="doc"><p>Degrade operator. Degrades a behavior-extended value into a
 non-extended one (from a layer below), based on a kernel
 value. Used also to throw exceptions.</p><p><img src="docfiles/figs/eqs-exb-atom-deg.png" /></p></div></div><div class="subs instances"><p id="control.i:ExB" class="caption collapser" onclick="toggleSection('i:ExB')">Instances</p><div id="section.i:ExB" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="ForSyDe-Atom.html#t:ExB">ExB</a> <a href="ForSyDe-Atom-ExB-Absent.html#t:AbstExt">AbstExt</a></span> <a href="src/ForSyDe-Atom-ExB.html#line-62" class="link">Source</a></td><td class="doc"><p>Implements the absent semantics of the extended behavior atoms.</p></td></tr></table></div></div></div><h1 id="g:3">The Model of Computation (MoC) Layer</h1><div class="doc"><p>This layer represents a major part of the <code>forsyde-atom</code>
 library and is concerned in modeling the timing aspects of
 CPS. While its foundations have been layered in the classical
 ForSyDe <a href="#sander04">[Sander04]</a>, it is mainly inspired from
 <a href="#lee98">[Lee98]</a> an it tries to follow the tagged signal model as
 closely as it is permitted by the host language, and with the
 adaptations require by the atom approach.</p><p>Although a short introduction of the tagged signal model has been
 written in the introduction of this documentation, we feel
 obliged to provide a primer in the classical ForSyDe theory in
 order to understand how everything fits together.</p></div><h2 id="g:4">Signals</h2><div class="doc"><p><a href="#lee98">[Lee98]</a> defines signals as (ordered) sets of events
 where each event is composed of a tag <em>T</em> and a value
 <em>V</em>. Similarly, in ForSyDe a signal is defined as a (partially or
 totally) <em>ordered sequence</em> of events that enables processes to
 communicate and synchronize. Sequencing might infer an implicit
 order of events, but more importantly it determines an order of
 evaluation, which is a key piece of a simulation engine.</p><p><img src="docfiles/figs/misc-tagged-signal.png" /></p><p>In ForSyDe-Atom, sequencing is achieved using the <code><a href="ForSyDe-Atom.html#t:Stream">Stream</a></code> data
 type, inspired from <a href="#reekie95">[Reekie95]</a>. In ForSyDe-Atom,
 signals are streams that carry <em>events</em>, where each type of event
 is identified by a type constructor which defines its tag
 system. In other words, we can state that through its tag system,
 a signal is <em>bound</em> to a MoC.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Stream" class="def">Stream</a> e <a href="src/ForSyDe-Atom-MoC-Stream.html#Stream" class="link">Source</a></p><div class="doc"><p>Defines a stream of events, encapsulating them in a structure
 isomorphic to an infinite list <a href="ForSyDe-Atom.html#bird87">[Bird87]</a>,
 thus all properties of lists may also be applied to
 <code><a href="ForSyDe-Atom.html#t:Stream">Stream</a></code>s. While, in combination with lazy evaluation, it is
 possible to create and simulate infinite signals, we need to ensure
 that the first/previous event is always fully evaluated. This can
 be translated into the following rule:</p><dl><dt>zero-delay feedbacks</dt><dd>are forbidden, due to un-evaluated
 self-referential calls. In a feedback loop, there always has to be
 enough events to ensure the data flow.</dd></dl><p>This rule imposes that the stream of data is uninterrupted in order
 to have an evaluatable kernel every time a new event is produced
 (i.e. to avoid deadlocks). Thus we can add the rule:</p><dl><dt>cleaning of output events</dt><dd>is also forbidden.  In other words, for
 each new input at any instant in time, a process must react with
 <em>at least</em> one output event.</dd></dl></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:NullS" class="def">NullS</a></td><td class="doc"><p>terminates a signal</p></td></tr><tr><td class="src">e <a name="v::-45-" class="def">:-</a> (<a href="ForSyDe-Atom.html#t:Stream">Stream</a> e) <span class="fixity">infixr 3</span><span class="rightedge"></span></td><td class="doc"><p>the default constructor appends an
 event to the head of the stream</p></td></tr></table></div><div class="subs instances"><p id="control.i:Stream" class="caption collapser" onclick="toggleSection('i:Stream')">Instances</p><div id="section.i:Stream" class="show"><table><tr><td class="src clearfix"><span class="inst-left">Functor <a href="ForSyDe-Atom.html#t:Stream">Stream</a></span> <a href="src/ForSyDe-Atom-MoC-Stream.html#line-48" class="link">Source</a></td><td class="doc"><p>allows for the mapping of an arbitrary function <code>(a -&gt; b)</code> upon
 all the events of a <code>(<code><a href="ForSyDe-Atom.html#t:Stream">Stream</a></code> a)</code>.</p></td></tr><tr><td class="src clearfix"><span class="inst-left">Applicative <a href="ForSyDe-Atom.html#t:Stream">Stream</a></span> <a href="src/ForSyDe-Atom-MoC-Stream.html#line-53" class="link">Source</a></td><td class="doc"><p>enables the <code><a href="ForSyDe-Atom.html#t:Stream">Stream</a></code> to behave like a <code><a href="Control-Applicative.html#v:ZipList">ZipList</a></code></p></td></tr><tr><td class="src clearfix"><span class="inst-left">Foldable <a href="ForSyDe-Atom.html#t:Stream">Stream</a></span> <a href="src/ForSyDe-Atom-MoC-Stream.html#line-60" class="link">Source</a></td><td class="doc"><p>provides folding functions useful for implementing utilities, such as <code>length</code>.</p></td></tr><tr><td class="src clearfix"><span class="inst-left">Read a =&gt; Read (<a href="ForSyDe-Atom.html#t:Stream">Stream</a> a)</span> <a href="src/ForSyDe-Atom-MoC-Stream.html#line-78" class="link">Source</a></td><td class="doc"><p>signal <code>(1 :- 2 :- NullS)</code> is read using the string <code>&quot;{1,2}&quot;</code>.</p></td></tr><tr><td class="src clearfix"><span class="inst-left">Show a =&gt; Show (<a href="ForSyDe-Atom.html#t:Stream">Stream</a> a)</span> <a href="src/ForSyDe-Atom-MoC-Stream.html#line-68" class="link">Source</a></td><td class="doc"><p>signal <code>(1 :- 2 :- NullS)</code> is represented as <code>{1,2}</code>.</p></td></tr></table></div></div></div><div class="doc"><p>For extended documentation and a list of all utilities associated
 with the <code><a href="ForSyDe-Atom.html#t:Stream">Stream</a></code> type you can consult:</p></div><div class="top"><p class="src">module <a href="ForSyDe-Atom-MoC-Stream.html">ForSyDe.Atom.MoC.Stream</a></p></div><h2 id="g:5">Processes</h2><div class="doc"><p>As described in <a href="#lee98">[Lee98]</a>, processes are either &quot;set of
 possible behaviors&quot; of signals or &quot;relations&quot; between multiple
 signals. One can describe complex systems by composing processes,
 which in this case is interpreted as the &quot;intersection of the
 behaviors of each of the processes being involved&quot;.</p><dl><dt>monotonicity</dt><dd>In order to ensure causal order and determinancy,
 processes need to be <em>monotonic</em> <a href="#lee98">[Lee98]</a>. A signal's
 tags (if explicit) <em>must be</em> a partial or total order and all tag
 alterations must be monotonic.</dd></dl><p>ForSyDe inherits this definition with respect to a functional
 view, thus a <strong>process</strong> <em>p</em> is a functional mapping over (the
 history of) signals. A process can <em>only</em> be instantiated using a
 <strong>process constructor</strong> <em>pc</em>, which is a higher order function
 embedding MoC semantics and/or a specific composition, but
 lacking functionality.</p><p><a name="proc-definition"></a>
 <img src="docfiles/figs/misc-process.png" /></p><p>Since processes are functions, process composition is equivalent
 to function composition. This means that composing two processes
 <code>p1</code> and <code>p2</code> grants the process <code>p2 . p1</code></p><pre>p1      :: Signal &#945; -&gt; Signal &#946;
p2      :: Signal &#946; -&gt; Signal &#947;
p2 . p1 :: Signal &#945; -&gt; Signal &#947;</pre><p>This implies that there is a signal <code>Signal beta </code> that
  &quot;streams&quot; the result from <code>p1</code> to <code>p2</code>, as suggested in the
  drawing:</p><p><img src="docfiles/figs/misc-ser-composition.png" /></p><p><strong>Process networks</strong> describe ForSyDe systems in terms of
 compositions of processes and originate from Reekie's process
 nets <a href="#reekie95">[Reekie95]</a>. A process network is a process itself,
 i.e. function from signal(s) to signal(s). The composition above
 <code>p2 . p1 </code> can also be regarded as a process network.</p><p>In ForSyDe-Atom atoms can be regarded as process constructors as
 their instantiations are functions on signals of events.
 Instantiations of atom patterns are the exact equivalent of
 process networks, which themselves are also processes, depending
 on the level of abstraction you are working with (hierarchical
 blocks vs. flat structures).</p><p>To understand the versatility of composition and partial
 application in building process constructors, consider the
 example above where composition of two processes infers a signal
 between them. This mechanism also works when composing
 constructors (un-instantiated atoms), which yields another
 constructor. By instantiating (fully applying) the new
 constructor we obtain a process network equivalent to the
 composition of the respective primitive processes obtained by
 instantiating (fully applying) the component atoms, like in the
 example below:</p><p><img src="docfiles/figs/misc-process-constructor.png" /></p><p>Now if we visualize process networks as graphs, where processes
 are nodes and signals are edges, a meaningful process composition
 could be regarded as graph patterns. Therefore it is safe to
 associate process constructors as patterns in process networks.</p></div><h2 id="g:6">Models of Computation</h2><div class="doc"><p>As mentioned in the introduction, <em>MoCs</em> are classes of behaviors
 dictating the semantics of execution and concurrency in a network
 of processes. Based on the definitions of their tag systems
 ForSyDe identifies MoCs as:</p><ol><li><em>timed</em> where <em>T</em> is a totally ordered set and <em>t</em> express the
 notion of physical time (e.g. continuous time
 <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT">CT</a></code>, discrete event
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE">DE</a></code>) or precedence (e.g. synchronous
 <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY">SY</a></code>);</li><li><em>untimed</em>, where <em>T</em> is a partially ordered set and <em>t</em> is
 expressed in terms of constraints on the tags in signals
 (e.g. dataflow, synchronous data flow
 <code><a href="ForSyDe-Atom-MoC-SDF.html#v:SDF">SDF</a></code>).</li></ol><p>As concerning MoCs, ForSyDe implements the execution semantics
 <em>through process constructors</em>, abstracting the timing model and
 inferring a schedule of the process network. In ForSyDe-Atom all
 atoms embed operating semantics dictated by a certain MoC and are
 side-effect-free. This ensures the functional correctness of a
 system even from early design stages.</p></div><h2 id="g:7">Representing Time</h2><div class="doc"><p>For explicit time representation, ForSyDe-atom provides two
 distinct data types.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Time" class="def">Time</a> = Rational <a href="src/ForSyDe-Atom-MoC-Time.html#Time" class="link">Source</a></p><div class="doc"><p>Type alias for the type to represent metric (continuous)
 time. Underneath we use <code>Rational</code> that is able to represent any
 <em>t</em> between <em>t&#8321;</em> &lt; <em>t&#8322;</em> &#8712; <em>T</em>.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:TimeStamp" class="def">TimeStamp</a> = DiffTime <a href="src/ForSyDe-Atom-MoC-TimeStamp.html#TimeStamp" class="link">Source</a></p><div class="doc"><p>Alias for the type representing discrete time. It is inherently
 quantizable, the quantum being a picosecond (10&#8315;&#185;&#178;
 seconds), thus it can be considered order-isomorphic with a set of
 integers, i.e. between any two timestamps there is a finite number
 of timestamps. Moreover, a timestamp can be easily translated into
 a rational number representing fractions of a second, so the
 conversion between timestamps (discrete time) and rationals
 (analog/continuous time) is straightforward.</p><p>This type is used in the explicit tags of the
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE">DE</a></code> MoC (and subsequently the discrete event
 evaluation engine for simulating the <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT">CT</a></code> MoC).</p></div></div><h2 id="g:8">MoC Layer Overview</h2><div class="doc"><p>This layer consists of:</p><ul><li>4 atoms as infix operators, implemented as methods of the type
 class <code><a href="ForSyDe-Atom.html#t:MoC">MoC</a></code>. Since each MoC is determined by its tag system, we
 expose this 
 which are instances of this class. Thus an event's type will
 trigger an atom to behave in accordance to its associated MoC.</li><li>a library of meaningful atom patterns as process constructors.
 (<em>Check the <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a> module for extensive</em>
 <em>documentation</em>).</li><li>a set of data types defining tag systems through the structure
 of events (i.e. <em>T</em> &#215; <em>V</em>). They are instances of the <code><a href="ForSyDe-Atom.html#t:MoC">MoC</a></code>
 type class and define the rules of execution that will trigger an
 atom to behave in accordance to its associated MoC. For each
 supported MoC, <code>forsyde-atom</code> provides a module which defines the
 signal (event) type, but also a set of utilities and process
 constructors as specific instantiations of atom patterns.
 (<em>Check the links in the <a href="#section.i:MoC">instances</a> section for</em>
 <em>extensive documentation</em>).</li></ul></div><div class="top"><p class="src"><span class="keyword">class</span> Applicative e =&gt; <a name="t:MoC" class="def">MoC</a> e <span class="keyword">where</span> <a href="src/ForSyDe-Atom-MoC.html#MoC" class="link">Source</a></p><div class="doc"><p>This is a type class defining interfaces for the MoC layer
 atoms. Each model of computation exposes its tag system through a
 unique event constructor as an instance of this class, which
 defines <em>T</em> &#215; <em>V</em>.</p><p><a name="context"></a> To express all possible MoCs which can be described using
 a <em>tagged</em> <em>signal</em> <em>model</em> we need to capture the most general
 form of their atoms. Recall that all atoms in the layered framework
 are represented as higher-order functions on structured types
 (instances of this class), taking functions of other (lower) layers
 as arguments. While this principle stands also for this layer, the
 functions taken as arguments need to be formatted for each MoC in
 particular in order to capture additional information, which we can
 call in general terms as the <em>execution context</em>.</p><p>One typical example of additional information is the consumption
 and production rates of for data flow MoCs (e.g. SDF). In this case
 the passed functions are defined over &quot;partitions&quot; of events,
 i.e. groupings of events with the same partial order in relation
 to, for example, a process firing. The formal description of such a
 &quot;formatted function&quot; taken as argument by a MoC entity is:</p><p><img src="docfiles/figs/eqs-moc-atom-formatted-func.png" /></p><p>where <em>a</em> and <em>b</em> might be Cartesian products of different types,
 corresponding to how many signals the constructor is applied to or
 how many signals it yields, and each type is expressed as:</p><p><img src="docfiles/figs/eqs-moc-atom-formatted-arg.png" /></p><p>While, as you can see above, the execution context can be extracted
 from the type information, working with type-level parameters is
 not a trivial task in Haskell, especially if we want to describe a
 general and extensible type class. This is why we have chosen a
 pragmatic approach in implementing the <code><a href="ForSyDe-Atom.html#t:MoC">MoC</a></code> class:</p><ul><li>any (possible) Cartesian product of <em>&#945;</em> is represented using
 a recursive type, namely a list [<em>&#945;</em>].</li><li>as the execution context cannot (or can hardly) be extracted from
 the recursive type, in the most general case we pass both context
 <em>and</em> argument as a pair (see each instance in particular). To aid
 in pairing contexts with each argument in a function, the <code>ctxt</code>
 utilities are provided (see <code><a href="ForSyDe-Atom-MoC.html#v:ctxt22">ctxt22</a></code>).</li><li>this artifice was masked using the generic type families <code><a href="ForSyDe-Atom.html#t:Fun">Fun</a></code>
 and <code>Res</code>. </li></ul></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:Fun" class="def">Fun</a> e a b <a href="src/ForSyDe-Atom-MoC.html#Fun" class="link">Source</a></p><div class="doc"><p><img src="docfiles/figs/eqs-moc-atom-function.png" /></p><p>This is a type family alias for a context-bound function passed
 as an argument to a MoC atom. In the most simple case it can be
 regarded as an enhanced <code>-&gt;</code> type operator. While hiding the
 explicit definition of arguments, this implementation choice
 certainly has its advantages in avoiding unnecessary or redundant
 type constructors (see version 0.1.1 and prior). Aliases are
 replaced at compile time, thus not affecting run-time
 performance.</p></div><p class="src"><span class="keyword">type</span> <a name="t:Ret" class="def">Ret</a> e b <a href="src/ForSyDe-Atom-MoC.html#Ret" class="link">Source</a></p><div class="doc"><p><img src="docfiles/figs/eqs-moc-atom-result.png" /></p><p>As with <code><a href="ForSyDe-Atom.html#t:Fun">Fun</a></code>, this alias hides a context-bound value
 (e.g. function return). Although the definition seems to be
 redundant with <code><a href="ForSyDe-Atom.html#t:Fun">Fun</a></code>, this alias is needed for utilities to
 recreate clean types again (see <code><a href="ForSyDe-Atom.html#v:-45--42-">-*</a></code>).</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:-45-.-45-" class="def">(-.-)</a> :: <a href="ForSyDe-Atom.html#t:Fun">Fun</a> e a b -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e b) <span class="fixity">infixl 5</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-MoC.html#-.-" class="link">Source</a></p><div class="doc"><p><img src="docfiles/figs/eqs-moc-atom-dot.png" /></p><p>This atom is mapping a function on values (in the presence of a
 context) to a signal, i.e. stream of tagged events. As ForSyDe
 deals with <em>determinate</em>, <em>functional</em> processes, this atom
 defines the (only) <em>behavior</em> of a process in rapport to one
 input signal <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>.</p></div><p class="src"><a name="v:-45--42--45-" class="def">(-*-)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e (<a href="ForSyDe-Atom.html#t:Fun">Fun</a> e a b)) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e b) <span class="fixity">infixl 5</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-MoC.html#-%2A-" class="link">Source</a></p><div class="doc"><p><img src="docfiles/figs/eqs-moc-atom-star.png" /></p><p>This atom synchronizes two signals, one carrying functions on
 values (in the presence of a context), and the other containing
 values, during which it applies the former on the latter. As
 concerning the process created, this atom defines a <em>relation</em>
 between two signals <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>.</p></div><p class="src"><a name="v:-45--42-" class="def">(-*)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e (<a href="ForSyDe-Atom.html#t:Ret">Ret</a> e b)) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e b) <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-MoC.html#-%2A" class="link">Source</a></p><div class="doc"><p><img src="docfiles/figs/eqs-moc-atom-post.png" /></p><p>Artificial <em>utility</em> which drops the context and/or partitioning
 yielding a clean signal type. </p></div><p class="src"><a name="v:-45--60--45-" class="def">(-&lt;-)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-MoC.html#-%3C-" class="link">Source</a></p><div class="doc"><p><img src="docfiles/figs/eqs-moc-atom-pre.png" /></p><p>This atom appends a (partition of) events at the beginning of a
 signal. This atom is necessary to ensure <em>complete partial order</em>
 of a signal and assures the <em>least upper bound</em> necessary for
 example in the evaluation of feedback loops
 <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>.</p><p>Notice the difference between the formal and the implemented type
 signatures. In the implementation the value/partition is wrapped
 inside an event type to enable smooth composition. You might also
 notice the type for the &quot;initial event(s)&quot; as being wrapped
 inside a signal constructor. This allows defining an DSL for this
 layer which is centered around signals exclusively, while also
 enabling to define atoms as homomorphisms to certain extent
 <a href="ForSyDe-Atom.html#bird97">[Bird97]</a>. Certain MoCs might have
 additional constraints on the first operand being finite.</p></div><p class="src"><a name="v:-45--38--45-" class="def">(-&amp;-)</a> :: <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) -&gt; <a href="ForSyDe-Atom.html#t:Stream">Stream</a> (e a) <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-MoC.html#-%26-" class="link">Source</a></p><div class="doc"><p><img src="docfiles/figs/eqs-moc-atom-phi.png" /></p><p>This atom allows the manipulation of tags in a signal in a
 restrictive way which preserves <em>monotonicity</em> and <em>continuity</em>
 in a process <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>, namely by
 &#8220;phase-shifting&#8221; all tags in a signal with the appropriate metric
 corresponding to each MoC. Thus it preserves the characteristic
 function intact <a href="ForSyDe-Atom.html#sander04">[Sander04]</a>.</p><p>As with the <code><a href="ForSyDe-Atom.html#v:-45--60--45-">-&lt;-</a></code> atom, we can justify the type signature for
 smooth composition and the definition of atoms as homomorphisms
 to certain extent. This in turn allows the interpretation of the
 <code><a href="ForSyDe-Atom.html#v:-45--38--45-">-&amp;-</a></code> operator as &quot;aligning the phases&quot; of two signals: the
 second operand is aligned based on the first.</p></div></div><div class="subs instances"><p id="control.i:MoC" class="caption collapser" onclick="toggleSection('i:MoC')">Instances</p><div id="section.i:MoC" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="ForSyDe-Atom.html#t:MoC">MoC</a> <a href="ForSyDe-Atom-MoC-SY.html#t:SY">SY</a></span> <a href="src/ForSyDe-Atom-MoC.html#line-32" class="link">Source</a></td><td class="doc"><p>Implenents the execution and synchronization semantics for the SY
 MoC through its atoms.</p></td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="ForSyDe-Atom.html#t:MoC">MoC</a> <a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a></span> <a href="src/ForSyDe-Atom-MoC.html#line-34" class="link">Source</a></td><td class="doc"><p>Implenents the execution and synchronization semantics for the DE
 MoC through its atoms.</p></td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="ForSyDe-Atom.html#t:MoC">MoC</a> <a href="ForSyDe-Atom-MoC-SDF.html#t:SDF">SDF</a></span> <a href="src/ForSyDe-Atom-MoC.html#line-40" class="link">Source</a></td><td class="doc"><p>Implenents the SDF semantics for the MoC atoms</p></td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="ForSyDe-Atom.html#t:MoC">MoC</a> <a href="ForSyDe-Atom-MoC-CT.html#t:CT">CT</a></span> <a href="src/ForSyDe-Atom-MoC.html#line-42" class="link">Source</a></td><td class="doc"><p>Implenents the execution and synchronization semantics for the CT
 MoC through its atoms.</p></td></tr></table></div></div></div><h1 id="g:9">The Skeleton Layer</h1><div class="doc"><p>The skeleton layer describes recursive and regular composition
 of processes which expose inherent potential for parallelism. As
 such, it wraps lower layer entities (i.e. processes, signals),
 into regular structures called <em>categorical types</em>. Most of the
 ground work for this layer is based on the categorical type
 theory <a href="#bird97">[Bird97]</a>, which enable the description of
 algorithmic skeletons as high-level constructs encapsulating
 parallelism and communication with an associated cost complexity.</p><p>This layer provides:</p><ul><li>3 atoms as infix operators which, as demonstrated in <a href="#bird97">[Bird97]</a>
 and <a href="#skillicorn05">[Skillicorn05]</a>, are enough to describe <em>all</em>
 algorithmic skeletons.</li><li>a library of generic skeletons as specific atom patterns.
 (<em>Check the <a href="ForSyDe-Atom-Skeleton.html">ForSyDe.Atom.Skeleton</a> module for extensive</em>
 <em>documentation</em>).</li><li>a set of different categorical types which implement these
 atoms, as instances of the <code><a href="ForSyDe-Atom.html#t:Skeleton">Skeleton</a></code> type class. These types
 provide additional skeletons patterns of atoms which takes as
 arguments their own type constructors.
 (<em>Check the links in the <a href="#section.i:Skeleton">instances</a> section for</em>
 <em>extensive documentation</em>).</li></ul></div><div class="top"><p class="src"><span class="keyword">class</span> Functor c =&gt; <a name="t:Skeleton" class="def">Skeleton</a> c <span class="keyword">where</span> <a href="src/ForSyDe-Atom-Skeleton.html#Skeleton" class="link">Source</a></p><div class="doc"><p>Class containing all the Skeleton layer atoms.</p><p>This class is instantiated by a set of categorical types,
 i.e. types which describe an inherent potential for being evaluated
 in parallel. Skeletons are patterns from this layer. When skeletons
 take as arguments entities from the MoC layer (i.e. processes), the
 results themselves are parallel process networks which describe
 systems with an inherent potential to be implemented on parallel
 platforms. All skeletons can be described as composition of the
 three atoms below (<code><a href="ForSyDe-Atom.html#v:-61--60--60--61-">=&lt;&lt;=</a></code> being just a specific instantiation of
 <code><a href="ForSyDe-Atom.html#v:-61--92--61-">=\=</a></code>). This possible due to an existing theorem in the categorical
 type theory, also called the Bird-Merteens formalism
 <a href="ForSyDe-Atom.html#bird97">[Bird97]</a>:</p><p><a name="factorization"></a></p><dl><dt>factorization</dt><dd>A function on a categorical type is an algorithmic
 skeleton (i.e. catamorphism) <em>iff</em> it can be represented in a
 factorized form, i.e. as a <em>map</em> composed with a <em>reduce</em>.</dd></dl><p>Consequently, most of the skeletons for the implemented categorical
 types are described in their factorized form, taking as arguments
 either:</p><ul><li>type constructors or functions derived from type constructors</li><li>processes, i.e. MoC layer entities</li></ul><p>Most of the ground-work on algorithmic skeletons on which this
 module is founded has been laid in <a href="ForSyDe-Atom.html#bird97">[Bird97]</a>,
 <a href="ForSyDe-Atom.html#skillicorn05">[Skillicorn05]</a> and it founds many
 of the frameworks collected in <a href="ForSyDe-Atom.html#gorlatch03">[Gorlatch03]</a>.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="ForSyDe-Atom.html#v:-61-.-61-">(=.=)</a>, <a href="ForSyDe-Atom.html#v:-61--42--61-">(=*=)</a>, <a href="ForSyDe-Atom.html#v:-61--92--61-">(=\=)</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:-61-.-61-" class="def">(=.=)</a> :: (a -&gt; b) -&gt; c a -&gt; c b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D.%3D" class="link">Source</a></p><div class="doc"><p>Atom which maps a function on each element of a structure
 (i.e. categorical type), defined as:</p><p><img src="docfiles/figs/eqs-skel-atom-dot.png" /></p><p><code><a href="ForSyDe-Atom.html#v:-61-.-61-">=.=</a></code> together with <code><a href="ForSyDe-Atom.html#v:-61--42--61-">=*=</a></code> form the <code>map</code> pattern.</p></div><p class="src"><a name="v:-61--42--61-" class="def">(=*=)</a> :: c (a -&gt; b) -&gt; c a -&gt; c b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D%2A%3D" class="link">Source</a></p><div class="doc"><p>Atom which applies the functions contained by as structure
 (i.e. categorical type), on the elements of another structure,
 defined as:</p><p><img src="docfiles/figs/eqs-skel-atom-star.png" /></p><p><code><a href="ForSyDe-Atom.html#v:-61-.-61-">=.=</a></code> together with <code><a href="ForSyDe-Atom.html#v:-61--42--61-">=*=</a></code> form the <code>map</code> pattern.</p></div><p class="src"><a name="v:-61--92--61-" class="def">(=\=)</a> :: (a -&gt; a -&gt; a) -&gt; c a -&gt; a <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D%5C%3D" class="link">Source</a></p><div class="doc"><p>Atom which reduces a structure to an element based on an
 <em>associative</em> function, defined as:</p><p><img src="docfiles/figs/eqs-skel-atom-red.png" /></p></div><p class="src"><a name="v:-61--60--60--61-" class="def">(=&lt;&lt;=)</a> <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Skeleton.html#%3D%3C%3C%3D" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: c (a -&gt; a)</td><td class="doc"><p>vector of functions</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>kernel element</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>result </p></td></tr></table></div><div class="doc"><p>Skeleton which <em>pipes</em> an element through all the functions
 contained by a structure. </p><p><strong>N.B.</strong>: this is not an atom. It has an implicit definition
 which might be augmented by instances of this class to include
 edge cases.</p><p><img src="docfiles/figs/eqs-skel-pattern-pipe.png" /></p><p>As the composition operation is not associative, we cannot treat
 <code>pipe</code> as a true reduction. Alas, it can still be exploited in
 parallel since it exposes another type of parallelism: time
 parallelism.</p></div><p class="src"><a name="v:first" class="def">first</a> :: c a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#first" class="link">Source</a></p><div class="doc"><p>Returns the first element in a structure.</p><p><strong>N.B.</strong>: this is not an atom. It has an implicit definition
 which might be replaced by instances of this class with a more
 efficient implementation.</p><p><img src="docfiles/figs/eqs-skel-pattern-first.png" /></p></div><p class="src"><a name="v:last" class="def">last</a> :: c a -&gt; a <a href="src/ForSyDe-Atom-Skeleton.html#last" class="link">Source</a></p><div class="doc"><p>Returns the last element in a structure.</p><p><strong>N.B.</strong>: this is not an atom. It has an implicit definition
 which might be replaced by instances of this class with a more
 efficient implementation.</p><p><img src="docfiles/figs/eqs-skel-pattern-last.png" /></p></div></div><div class="subs instances"><p id="control.i:Skeleton" class="caption collapser" onclick="toggleSection('i:Skeleton')">Instances</p><div id="section.i:Skeleton" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="ForSyDe-Atom.html#t:Skeleton">Skeleton</a> <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a></span> <a href="src/ForSyDe-Atom-Skeleton.html#line-111" class="link">Source</a></td><td class="doc"><p>Ensures that <code><a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a></code> is a structure associated with the Skeleton Layer.</p></td></tr></table></div></div></div><h1 id="g:10">Utilities</h1><div class="doc"><p>The <code><a href="ForSyDe.html#v:Atom">Atom</a></code> module exports a set of utility functions,
 mainly for aiding the designer to avoid working with zipped
 tuples which might pollute the design. Utilities are function
 without any semantical value (thus not considered atoms). They
 operate on and might alter the <em>structure</em> of some datum, but it
 does not affect its state.</p><p>For a list of all the provided utilities, please consult the
 following module:</p></div><div class="top"><p class="src">module <a href="ForSyDe-Atom-Utility.html">ForSyDe.Atom.Utility</a></p></div><div class="doc"><p>Among the most useful utilities we mentions the <code>unzip</code>
 function. Recall that in all our definitions for patterns, they
 were expressed in the most general form as functions from <em>n</em>-ary
 Cartesian products to <em>m</em>-ary Cartesian products. While partial
 application provides a versatile mechanism that can translate
 n-ary inputs into curried arguments (which is very powerful in
 combination with an applicative style), we cannot do so for
 return types. For the latter we must rely on tuples. But working
 with tuples of data wrapped in several layers of structures
 becomes extremely cumbersome. Take for example the case of a
 process constructed with <em>pc</em> in equation (1) below. Using only
 the provided atoms to implement <em>pc</em> would give us a process
 which returns only one signal of a tuple and not, as we would
 like, a tuple of signals of events.</p><p><img src="docfiles/figs/misc-unzip.png" /></p><p>Therefore, by implementing all data types associated with signals
 and events as instances of <code>Functor</code>, we were able to provide a
 (set of) <em>unzip</em> utility functions defined as in equation (2)
 above, in the <a href="ForSyDe-Atom-Utility.html">ForSyDe.Atom.Utility</a> module.  Mind that we call
 <em>unzip</em> a utility and not an atom, since it has no
 synchronization nor behavior semantic. It just conveniently
 &quot;lifts&quot; the wrapped tuples in order to create &quot;collections&quot; of
 events and signals, and it is imposed by the mechanisms of the
 type system in the host language.</p></div><div class="top"><p class="src"><a name="v:-124--124--60-" class="def">(||&lt;)</a> :: (Functor f1, Functor f2) =&gt; f1 (f2 (a1, a2)) -&gt; (f1 (f2 a1), f1 (f2 a2)) <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/ForSyDe-Atom-Utility.html#%7C%7C%3C" class="link">Source</a></p><div class="doc"><p>This set of utility functions &quot;unzip&quot; nested n-tuples, provided
 as postfix operators. They are crucial for reconstructing data
 types from higher-order functions which input functions with
 multiple outputs. It relies on the nested types being instances of
 <code>Functor</code>.</p><p>The operator convention is <code>(|+&lt;+)</code>, where the number of <code>|</code>
 represent the number of layers the n-tuple is lifted, while the
 number of <code>&lt;</code> + 1 is the order <em>n</em> of the n-tuple.</p><p><a href="ForSyDe-Atom-Utility.html">ForSyDe.Atom.Utility</a> exports the constructors below. Please
 follow the examples in the source code if they do not suffice:</p><pre>   |&lt;,    |&lt;&lt;,    |&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,
  ||&lt;,   ||&lt;&lt;,   ||&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,
 |||&lt;,  |||&lt;&lt;,  |||&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,  
||||&lt;, ||||&lt;&lt;, ||||&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;, </pre><p>Example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XPostfixOperators
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>([Just (1,2,3), Nothing, Just (4,5,6)] ||&lt;&lt;)
</code></strong>([Just 1,Nothing,Just 4],[Just 2,Nothing,Just 5],[Just 3,Nothing,Just 6])
</pre></div></div><h1 id="g:11">Bibliography</h1><div class="doc"><p><a name="bird87"></a> <a href="https://www.cs.ox.ac.uk/files/3378/PRG56.pdf">[Bird87]</a> Bird, R. S. (1987). An introduction to the theory of lists. In <em>Logic of programming and calculi of discrete design</em> (pp. 5-42). Springer Berlin Heidelberg.</p></div><div class="doc"><p><a name="bird97"></a> <a href="http://dl.acm.org/citation.cfm?id=248932">[Bird97]</a> Bird, R. S. &amp; de Moor, O. (1997). Algebra of Programming. Prentice-Hall, Inc., Upper Saddle River, NJ, USA. </p></div><div class="doc"><p><a name="fuji00"></a> [Fujimoto00] Fujimoto, R. M. (2000). Parallel and distributed simulation systems (Vol. 300). New York: Wiley.</p></div><div class="doc"><p><a name="halbwachs91"></a> <a href="http://ieeexplore.ieee.org/document/97300/">[Halbwachs91]</a> Halbwachs, N., Caspi, P., Raymond, P., &amp; Pilaud, D. (1991). The synchronous data flow programming language LUSTRE. <em>Proceedings of the IEEE, 79(9)</em>, 1305-1320.</p></div><div class="doc"><p><a name="gorlatch03"></a> <a href="http://link.springer.com/chapter/10.1007/978-1-4471-0097-3_1#page-1">[Gorlatch03]</a> Fischer, J., Gorlatch, S., &amp; Bischof, H. (2003). Foundations of data-parallel skeletons. In <em>Patterns and skeletons for parallel and distributed computing</em> (pp. 1-27). Springer London.</p></div><div class="doc"><p><a name="kahn76"></a> [Kahn76] Kahn, G., &amp; MacQueen, D. (1976). Coroutines and networks of parallel processes.</p></div><div class="doc"><p><a name="lee98"></a> [Lee98] Lee, E. A., &amp; Sangiovanni-Vincentelli, A. (1998). A framework for comparing models of computation. <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 17(12)</em>, 1217-1229. </p></div><div class="doc"><p><a name="reekie95"></a> <a href="http://ptolemy.eecs.berkeley.edu/~johnr/papers/pdf/thesis.pdf">[Reekie95]</a> Reekie, H. J. (1995). Realtime signal processing: Dataflow, visual, and functional programming.</p></div><div class="doc"><p><a name="sander04"></a> <a href="http://people.kth.se/~ingo/Papers/TCAD2004_SystemModeling.pdf">[Sander04]</a> Sander, I., &amp; Jantsch, A. (2004). System modeling and transformational design refinement in ForSyDe [formal system design]. <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 23(1)</em>, 17-32.</p></div><div class="doc"><p><a name="skillicorn05"></a> <a href="https://books.google.se/books?hl=ro&amp;lr=&amp;id=rQwsL5xsZigC&amp;oi=fnd&amp;pg=PP1&amp;dq=skillicorn+foundation+parallel+programming&amp;ots=UJMBr0uO2Q&amp;sig=ncyXxE0gFNkUZwVOYyFb_ezWlGY&amp;redir_esc=y#v=onepage&amp;q=skillicorn%20foundation%20parallel%20programming&amp;f=false">[Skillicorn05]</a> Skillicorn, D. B. (2005). Foundations of parallel programming (No. 6). Cambridge University Press.</p></div><div class="doc"><p><a name="ungureanu17"></a> <a href="http://ieeexplore.ieee.org/document/7927270/">[Ungureanu17]</a> Ungureanu, G., &amp; Sander, I., <em>A layered formal framework for modeling of cyber-physical systems</em>, in 2017 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE), 2017, pp. 1715&#8211;1720.</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>