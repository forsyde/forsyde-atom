<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ForSyDe.Atom.MoC.DE</title><link href="ocean.css" rel="stylesheet" type="text/css" title="ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_ForSyDe-Atom-MoC-DE.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/ForSyDe-Atom-MoC-DE.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">forsyde-atom-0.2.0.0: A shallow-embedded DSL for modeling cyber-physical systems</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) George Ungureanu, KTH/ICT/ESY 2016</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>ugeorge@kth.se</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">ForSyDe.Atom.MoC.DE</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Discrete event (<code>DE</code>)</a></li><li><a href="#g:2">Aliases &amp; utilities</a></li><li><a href="#g:3"><code>DE</code> process constuctors</a><ul><li><a href="#g:4">Simple</a></li><li><a href="#g:5">Interface processes</a></li><li><a href="#g:6">Hybrid processes</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <code>DE</code> library implements the atoms holding the sematics for the
 discrete event computation model. It also provides a set of helpers
 for properly instantiating process network patterns as process
 constructors.</p><p><strong>IMPORTANT!!!</strong>
 see the <a href="ForSyDe-Atom.html#naming_conv">naming convention</a> rules
 on how to interpret, use and develop your own constructors.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:TimeStamp">TimeStamp</a> = DiffTime</li><li class="src short"><span class="keyword">data</span> <a href="#t:DE">DE</a> a = <a href="#v:DE">DE</a> {<ul class="subs"><li><a href="#v:tag">tag</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a></li><li><a href="#v:val">val</a> :: a</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:Signal">Signal</a> a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a)</li><li class="src short"><a href="#v:unit2">unit2</a> :: ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, a), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, a1)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1)</li><li class="src short"><a href="#v:infinite">infinite</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</li><li class="src short"><a href="#v:signal">signal</a> :: [(<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, a)] -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</li><li class="src short"><a href="#v:checkSignal">checkSignal</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a)</li><li class="src short"><a href="#v:readSignal">readSignal</a> :: Read a =&gt; String -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</li><li class="src short"><a href="#v:delay">delay</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a> -&gt; a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</li><li class="src short"><a href="#v:delay-39-">delay'</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</li><li class="src short"><a href="#v:comb22">comb22</a> :: (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:reconfig22">reconfig22</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (a1 -&gt; a2 -&gt; (b1, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:sync2">sync2</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2)</li><li class="src short"><a href="#v:constant2">constant2</a> :: (b1, b2) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:generate2">generate2</a> :: (b1 -&gt; b2 -&gt; (b1, b2)) -&gt; ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b1), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:stated22">stated22</a> :: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b1), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:state22">state22</a> :: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b1), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:moore22">moore22</a> :: (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; (b1, b2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, st) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:mealy22">mealy22</a> :: (st -&gt; a1 -&gt; a2 -&gt; st) -&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, st) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li><li class="src short"><a href="#v:toSY2">toSY2</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b -&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> a, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> b)</li><li class="src short"><a href="#v:toCT2">toCT2</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b -&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:Signal">Signal</a> a, <a href="ForSyDe-Atom-MoC-CT.html#t:Signal">Signal</a> b)</li><li class="src short"><a href="#v:zipx">zipx</a> :: <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (<a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a)</li><li class="src short"><a href="#v:unzipx">unzipx</a> :: Integer -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (<a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a)</li><li class="src short"><a href="#v:unzipx-39-">unzipx'</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (<a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a)</li><li class="src short"><a href="#v:embedSY22">embedSY22</a> :: (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> b2)) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</li></ul></div><div id="interface"><h1 id="g:1">Discrete event (<code>DE</code>)</h1><div class="doc"><p>According to <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>, &quot;a
 discrete-event system is a timed system <em>Q</em> where for all <em>s</em>
 &#8712; <em>Q</em>, the tag sytem is order-isomorphic to a subset of the
 integers. Order-isomorphic means simply that there exists an
 order-preserving bijection between the events in <em>T</em> and a subset
 of the integers (or the entire set of integers).&quot;</p><p>The discrete event (<code>DE</code>) MoC does suggest the notion of physical
 time through its tags, also called timestamps. As the definition
 above implies, an important property of the DE tag system is that
 between any two timestamps <em>t&#7524;</em> and <em>t&#7525;</em> there is a
 <strong><em>finite</em></strong> number of possible timestamps. Based on this we can
 formulate the folowing specialized definition:</p><dl><dt>The DE MoC</dt><dd>is abstracting the execution semantics of a system
 where synchronization is <em>discretized</em> and <em>time-aware</em>, and it
 is performed whenever a new event occurs.</dd></dl><p>There are many variants of discrete event simulators, each of
 them implementing slight variations of the semantics stated in
 <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>. The execution model covered by
 the DE implementation of ForSyDe-atom may be described as a
 simplified &quot;cycle simulator&quot; with no delta-delay nor superdense
 time. The signals behave as &quot;latched channels&quot; (similar to an HDL
 simulator), and processes react instantaneously to any new
 event. While the simplicity of the execution engine is a desired
 one, more complex behaviors such as zero-time feedback, non-zero
 reaction time and communication protocols (e.g. lossy buffers)
 may be achieved by composing patterns from the <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>
 and/or <a href="ForSyDe-Atom-ExB.html">ForSyDe.Atom.ExB</a> layers. Nevertheless, the DE behaviors
 possible within ForSyDe-Atom are included in the class of
 <em>conservative simulators</em> as presented in
 <a href="ForSyDe-Atom.html#fuji00">[Fujimoto00]</a>, due to the dataflow
 nature of the evaluation mechanisms. Below you can see an example
 of a simple DE process, without behavior extensions:</p><p><img src="docfiles/figs/moc-de-example.png" /></p><p>Below are stated a few particularities of our DE MoC
 implementation:</p><ol><li>According to <a href="ForSyDe-Atom.html#lee98">[Lee98]</a>, our DE MoC is
 a one-sided system, i.e. time starts from an absolute 0. While
 negative time cannot be represented, signals can be phase-aligned
 with the help of the <code><a href="ForSyDe-Atom-MoC.html#v:-45--38--45-">-&amp;-</a></code> atom. All signals
 need to start from timestamp 0, and events need to be positioned
 with their tags in strict ascending order. The <code><a href="ForSyDe-Atom-MoC-DE.html#v:checkSignal">checkSignal</a></code>
 utility enforces these rules.</li><li>tags are explicit and a DE event will construct a type around
 both a tag and a value. Tags represent the start time of the
 event, the end time being implicit from the start time of the
 next event. By doing so, we ensure that the time domain is
 non-disjoint, i.e. a sub-case of continous time. </li><li>according to the previous point, events are assumed to persist
 from their time of arrival until the next event arrives or, if
 there is no incoming event, until infinity. This default behavior
 can be be interpret signals as being either persistent channels
 (e.g. latched wires), or non-blocking buffers of size 1.</li><li>as a consequence to the previous is that feedback loops will
 generate an infinite number of events (strictly preceding each
 other), since a loop updates the value after a certain delay, and
 any input is assumed to go to infinity. Thus we can now fully
 jutify the definition of the <code><a href="ForSyDe-Atom-MoC.html#v:delay">delay</a></code> pattern as
 consisting in a <em>prepend</em> (i.e. generating the new value) and a
 <em>phase shift</em> (i.e. advancing time with a positive integer). This
 is done in order to both preserve causality <em>and</em> avoid deadlock.</li><li>due to the reactive and dataflow natures of the execution
 system, DE processes <em>are forbidden</em> to clean up events. Doing so
 might lead to deadlock wherever any feedback is involved. This
 means that a new event is created every time a new event arrives,
 regardless of what value it carries. This means that <em>all</em> values
 are propagated, justifying our system's conservative approach
 <a href="ForSyDe-Atom.html#fuji00">[Fujimoto00]</a>. Atoms themselves do not
 clean signals, but using interfaces that do should be treated
 with extreme special care, as it is considered unsafe and
 deadlock-prone.</li><li>due to the conservative approach, and to the fact that MoC
 atoms are independent synchronization entities, ForSyDe
 simulators are completely parallelizable, since processes are
 self-sufficient and do not depend on a global event queue (as
 compared to other cycle simulators).</li><li>any signal from outside needs to be sane (<em>T</em> must be a total
 order) before being injected into a ForSyDe process
 network. Helper functions are equipped with sanity
 checkers. Inside a ForSyDe process network, transformations are
 rate-monotonic, thus output signals are guaranteed to be sane.</li><li>since <em>T</em> is a total order, there is no need for an
 <a href="ForSyDe-Atom-MoC.html#context">execution context</a> and we can
 ignore the formatting of functions in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, thus we
 can safely assume:</li></ol><p><img src="docfiles/figs/eqs-moc-timed-context.png" /></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:TimeStamp" class="def">TimeStamp</a> = DiffTime <a href="src/ForSyDe-Atom-MoC-TimeStamp.html#TimeStamp" class="link">Source</a></p><div class="doc"><p>Alias for the type representing discrete time. It is inherently
 quantizable, the quantum being a picosecond (10&#8315;&#185;&#178;
 seconds), thus it can be considered order-isomorphic with a set of
 integers, i.e. between any two timestamps there is a finite number
 of timestamps. Moreover, a timestamp can be easily translated into
 a rational number representing fractions of a second, so the
 conversion between timestamps (discrete time) and rationals
 (analog/continuous time) is straightforward.</p><p>This type is used in the explicit tags of the
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE">DE</a></code> MoC (and subsequently the discrete event
 evaluation engine for simulating the <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT">CT</a></code> MoC).</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DE" class="def">DE</a> a <a href="src/ForSyDe-Atom-MoC-DE-Core.html#DE" class="link">Source</a></p><div class="doc"><p>The DE event. It identifies a discrete event signal.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DE" class="def">DE</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:tag" class="def">tag</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a></dt><dd class="doc"><p>timestamp</p></dd><dt class="src"><a name="v:val" class="def">val</a> :: a</dt><dd class="doc"><p>the value</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DE" class="caption collapser" onclick="toggleSection('i:DE')">Instances</p><div id="section.i:DE" class="show"><table><tr><td class="src clearfix"><span class="inst-left">Functor <a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a></span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-70" class="link">Source</a></td><td class="doc"><p>Allows for mapping of functions on a DE event.</p></td></tr><tr><td class="src clearfix"><span class="inst-left">Applicative <a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a></span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-74" class="link">Source</a></td><td class="doc"><p>Allows for lifting functions on a pair of DE events.</p></td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="ForSyDe-Atom-MoC.html#t:MoC">MoC</a> <a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a></span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-34" class="link">Source</a></td><td class="doc"><p>Implenents the execution and synchronization semantics for the DE
 MoC through its atoms.</p></td></tr><tr><td class="src clearfix"><span class="inst-left">Eq a =&gt; Eq (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a)</span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-30" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Read a =&gt; Read (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a)</span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-64" class="link">Source</a></td><td class="doc"><p>Reads the string of type <code>v@t</code> as an event <code>DE t v</code>.</p></td></tr><tr><td class="src clearfix"><span class="inst-left">Show a =&gt; Show (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a)</span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-60" class="link">Source</a></td><td class="doc"><p>Shows the event with tag <code>t</code> and value <code>v</code> as <code> v @t</code>.</p></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Ret">Ret</a> <a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> b = b</span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-36" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="keyword">type</span> <a href="ForSyDe-Atom-MoC.html#t:Fun">Fun</a> <a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a b = a -&gt; b</span> <a href="src/ForSyDe-Atom-MoC-DE-Core.html#line-35" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Aliases &amp; utilities</h1><div class="doc"><p>A set of type synonyms and utilities are provided for
 convenience. The API type signatures will feature these aliases
 to hide the cumbersome construction of atoms and patters as seen
 in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Signal" class="def">Signal</a> a = <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a) <a href="src/ForSyDe-Atom-MoC-DE-Core.html#Signal" class="link">Source</a></p><div class="doc"><p>Type synonym for a SY signal, i.e. &quot;a signal of SY events&quot;</p></div></div><div class="top"><p class="src"><a name="v:unit2" class="def">unit2</a> :: ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, a), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, a1)) -&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1) <a href="src/ForSyDe-Atom-MoC-DE-Core.html#unit2" class="link">Source</a></p><div class="doc"><p>Wraps a (tuple of) pair(s) <code>(tag, value)</code> into the equivalent
 unit signal(s), in this case a signal with one event with the
 period <code>tag</code> carrying <code>value</code>.</p><p>The following helpers are exported:</p><pre>unit, unit2, unit3, unit4,</pre></div></div><div class="top"><p class="src"><a name="v:infinite" class="def">infinite</a> :: a -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a <a href="src/ForSyDe-Atom-MoC-DE-Core.html#infinite" class="link">Source</a></p><div class="doc"><p>Creates an infinite signal.</p></div></div><div class="top"><p class="src"><a name="v:signal" class="def">signal</a> :: [(<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, a)] -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a <a href="src/ForSyDe-Atom-MoC-DE-Core.html#signal" class="link">Source</a></p><div class="doc"><p>Transforms a list of tuples <code>(tag, value)</code> into a DE
 signal. Checks if it is well-formed.</p></div></div><div class="top"><p class="src"><a name="v:checkSignal" class="def">checkSignal</a> :: <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a) -&gt; <a href="ForSyDe-Atom-MoC-Stream.html#t:Stream">Stream</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:DE">DE</a> a) <a href="src/ForSyDe-Atom-MoC-DE-Core.html#checkSignal" class="link">Source</a></p><div class="doc"><p>Checks if a signal is well-formed or not, according to the DE MoC
 interpretation in <code>ForSyDe-Atom</code>.</p></div></div><div class="top"><p class="src"><a name="v:readSignal" class="def">readSignal</a> :: Read a =&gt; String -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a <a href="src/ForSyDe-Atom-MoC-DE-Core.html#readSignal" class="link">Source</a></p><div class="doc"><p>Reads a signal from a string and checks if it is well-formed.
 Like with the <code>read</code> function from <code>Prelude</code>, you must specify the
 type of the signal.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>readSignal &quot;{ 1@0, 2@2, 3@5, 4@7, 5@10 }&quot; :: Signal Int
</code></strong>{ 1 @0s, 2 @2s, 3 @5s, 4 @7s, 5 @10s}
</pre><p>Incorrect usage (not covered by <code>doctest</code>):</p><pre>&#955;&gt; readSignal &quot;{ 1@0, 2@2, 3@5, 4@10, 5@7 }&quot; :: Signal Int
{ 1 @0s, 2 @2s, 3 @5s*** Exception: [MoC.DE] malformed signal
&#955;&gt; readSignal &quot;{ 1@1, 2@2, 3@5, 4@7, 5@10 }&quot; :: Signal Int
*** Exception: [MoC.DE] signal does not start from global 0</pre></div></div><h1 id="g:3"><code>DE</code> process constuctors</h1><div class="doc"><p>The DE process constructors are basically specific
 instantiations of patterns defined in <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>. Some
 might also be wrapping functions in an extended behavioural
 model.</p></div><h2 id="g:4">Simple</h2><div class="doc"><p>These are mainly direct instantiations of patterns defined in
 <a href="ForSyDe-Atom-MoC.html">ForSyDe.Atom.MoC</a>, using DE-specific utilities.</p></div><div class="top"><p class="src"><a name="v:delay" class="def">delay</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#delay" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a></td><td class="doc"><p>time delay</p></td></tr><tr><td class="src">-&gt; a</td><td class="doc"><p>initial value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>The <code>delay</code> process &quot;delays&quot; a signal with one
 event. Instantiates the <code><a href="ForSyDe-Atom-MoC.html#v:delay">delay</a></code> pattern.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay 3 0 s
</code></strong>{ 0 @0s, 1 @3s, 2 @5s, 3 @9s, 4 @11s, 5 @12s}
</pre><p><img src="docfiles/figs/moc-de-pattern-delay.png" /></p></div></div><div class="top"><p class="src"><a name="v:delay-39-" class="def">delay'</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#delay%27" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</td><td class="doc"><p>signal &quot;borrowing&quot; the initial event</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</td><td class="doc"><p>input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</td><td class="doc"><p>output signal</p></td></tr></table></div><div class="doc"><p>Similar to the previous, but this is the raw instantiation of the
 <code><a href="ForSyDe-Atom-MoC.html#v:delay">delay</a></code> pattern. It &quot;borrows&quot; the first event from
 one signal and appends it at the head of another signal.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{3@0, 4@4, 5@5, 6@8, 7@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>delay' s1 s2
</code></strong>{ 1 @0s, 3 @2s, 4 @6s, 5 @7s, 6 @10s, 7 @11s}
</pre><p><img src="docfiles/figs/moc-de-pattern-delayp.png" /></p></div></div><div class="top"><p class="src"><a name="v:comb22" class="def">comb22</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#comb22" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>function on values</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>comb</code> processes map combinatorial functions on signals and take
 care of synchronization between input signals. It instantiates the
 <code>comb</code> pattern (see <code><a href="ForSyDe-Atom-MoC.html#v:comb22">comb22</a></code>).</p><p>The following constructors are provided:</p><pre>comb11, comb12, comb13, comb14,
comb21, comb22, comb23, comb24,
comb31, comb32, comb33, comb34,
comb41, comb42, comb43, comb44,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = infinite 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb11 (+1) s2
</code></strong>{ 2 @0s, 3 @2s, 4 @6s, 5 @8s, 6 @9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>comb22 (\a b-&gt; (a+b,a-b)) s1 s2
</code></strong>({ 2 @0s, 3 @2s, 4 @6s, 5 @8s, 6 @9s},{ 0 @0s, -1 @2s, -2 @6s, -3 @8s, -4 @9s})
</pre><p><img src="docfiles/figs/moc-de-pattern-comb.png" /></p></div></div><div class="top"><p class="src"><a name="v:reconfig22" class="def">reconfig22</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#reconfig22" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>signal carrying functions</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc"><p>first input signal carrying arguments</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc"><p>second input signal carrying arguments</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>reconfig</code> creates a DE adaptive process where the first signal
 carries functions and the other carry the arguments. It
 instantiates the <code>reconfig</code> atom pattern (see
 <code><a href="ForSyDe-Atom-MoC.html#v:reconfig22">reconfig22</a></code>).</p><p>The following constructors are provided:</p><pre>reconfig11, reconfig12, reconfig13, reconfig14,
reconfig21, reconfig22, reconfig23, reconfig24,
reconfig31, reconfig32, reconfig33, reconfig34,
reconfig41, reconfig42, reconfig43, reconfig44,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let sf = signal [(0,(+1)),(2,(*2)),(5,(+1)),(7,(*2))]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = signal [(0,1),(3,2),(5,3),(9,4)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>reconfig11 sf s1
</code></strong>{ 2 @0s, 2 @2s, 4 @3s, 4 @5s, 6 @7s, 8 @9s}
</pre><p><img src="docfiles/figs/moc-de-pattern-reconfig.png" /></p></div></div><div class="top"><p class="src"><a name="v:sync2" class="def">sync2</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#sync2" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2)</td><td class="doc"><p>two output signals</p></td></tr></table></div><div class="doc"><p><code>sync</code> synchronizes multiple signals, so that they have the same
 set of tags, and consequently, the same number of events. It
 instantiates the <code>comb</code> atom pattern (see
 <code><a href="ForSyDe-Atom-MoC.html#v:comb22">comb22</a></code>).</p><p>The following constructors are provided:</p><pre>sync2, sync3, sync4,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = readSignal &quot;{1@0, 2@2, 3@6, 4@8,  5@9}&quot;  :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = readSignal &quot;{1@0, 2@5, 3@6, 4@10, 5@12}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sync2 s1 s2
</code></strong>({ 1 @0s, 2 @2s, 2 @5s, 3 @6s, 4 @8s, 5 @9s, 5 @10s, 5 @12s},{ 1 @0s, 1 @2s, 2 @5s, 3 @6s, 3 @8s, 3 @9s, 4 @10s, 5 @12s})
</pre><p><img src="docfiles/figs/moc-de-pattern-sync.png" /></p></div></div><div class="top"><p class="src"><a name="v:constant2" class="def">constant2</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#constant2" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b1, b2)</td><td class="doc"><p>values to be repeated</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A signal generator which keeps a value constant. As compared with
 the <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY">SY</a></code>, it just constructs an infinite signal
 with constant value (i.e. a signal with one event starting from
 time 0).</p><p>The following constructors are provided:</p><pre>constant1, constant2, constant3, constant4,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>constant1 2
</code></strong>{ 2 @0s}
</pre><p><img src="docfiles/figs/moc-de-pattern-constant.png" /></p></div></div><div class="top"><p class="src"><a name="v:generate2" class="def">generate2</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#generate2" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b1 -&gt; b2 -&gt; (b1, b2))</td><td class="doc"><p>function to generate next value</p></td></tr><tr><td class="src">-&gt; ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b1), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b2))</td><td class="doc"><p>kernel values tupled with their generation rate.</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc"><p>generated signals</p></td></tr></table></div><div class="doc"><p>A signal generator based on a function and a kernel value. It
 is actually an instantiation of the <code>stated0X</code> constructor
 (check <code><a href="ForSyDe-Atom-MoC.html#v:stated22">stated22</a></code>).</p><p>The following constructors are provided:</p><pre>generate1, generate2, generate3, generate4,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (s1,s2) = generate2 (\a b -&gt; (a+1,b+2)) ((3,1),(1,2))
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 5 s1
</code></strong>{ 1 @0s, 2 @3s, 2 @4s, 2 @5s, 3 @6s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 s2
</code></strong>{ 2 @0s, 4 @1s, 6 @2s, 8 @3s, 10 @4s, 12 @5s, 14 @6s}
</pre><p><img src="docfiles/figs/moc-de-pattern-generate.png" /></p></div></div><div class="top"><p class="src"><a name="v:stated22" class="def">stated22</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#stated22" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b1), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b2))</td><td class="doc"><p>initial state values tupled with their initial delay</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>stated</code> is a state machine without an output decoder. It is an
 instantiation of the <code>state</code> MoC constructor (see
 <code><a href="ForSyDe-Atom-MoC.html#v:stated22">stated22</a></code>).</p><p>The following constructors are provided:</p><pre>stated11, stated12, stated13, stated14,
stated21, stated22, stated23, stated24,
stated31, stated32, stated33, stated34,
stated41, stated42, stated43, stated44,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ stated11 (+) (6,1) s
</code></strong>{ 1 @0s, 2 @6s, 3 @8s, 5 @12s, 7 @14s, 8 @15s, 10 @18s}
</pre><p><img src="docfiles/figs/moc-de-pattern-stated.png" /></p></div></div><div class="top"><p class="src"><a name="v:state22" class="def">state22</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#state22" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b1 -&gt; b2 -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; ((<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b1), (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, b2))</td><td class="doc"><p>initial state values tupled with their initial delay</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc"><p>first input signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc"><p>second input signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc"><p>output signals</p></td></tr></table></div><div class="doc"><p><code>state</code> is a state machine without an output decoder, and the
 state non-transparent. It is an instantiation of the <code>state</code> MoC
 constructor (see <code><a href="ForSyDe-Atom-MoC.html#v:state22">state22</a></code>).</p><p>The following constructors are provided:</p><pre>state11, state12, state13, state14,
state21, state22, state23, state24,
state31, state32, state33, state34,
state41, state42, state43, state44,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ state11 (+) (6,1) s
</code></strong>{ 2 @0s, 3 @2s, 5 @6s, 7 @8s, 8 @9s, 10 @12s, 12 @14s}
</pre><p><img src="docfiles/figs/moc-de-pattern-state.png" />                   </p></div></div><div class="top"><p class="src"><a name="v:moore22" class="def">moore22</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#moore22" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; (b1, b2))</td><td class="doc"><p>output decoder</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, st)</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>moore</code> processes model Moore state machines. It is an
 instantiation of the <code>moore</code> MoC constructor (see
 <code><a href="ForSyDe-Atom-MoC.html#v:moore22">moore22</a></code>).</p><p>The following constructors are provided:</p><pre>moore11, moore12, moore13, moore14,
moore21, moore22, moore23, moore24,
moore31, moore32, moore33, moore34,
moore41, moore42, moore43, moore44,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ moore11 (+) (+1) (6,1) s
</code></strong>{ 2 @0s, 3 @6s, 4 @8s, 6 @12s, 8 @14s, 9 @15s, 11 @18s}
</pre><p><img src="docfiles/figs/moc-de-pattern-moore.png" />          </p></div></div><div class="top"><p class="src"><a name="v:mealy22" class="def">mealy22</a> <a href="src/ForSyDe-Atom-MoC-DE-Lib.html#mealy22" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (st -&gt; a1 -&gt; a2 -&gt; st)</td><td class="doc"><p>next state function</p></td></tr><tr><td class="src">-&gt; (st -&gt; a1 -&gt; a2 -&gt; (b1, b2))</td><td class="doc"><p>outpt decoder</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, st)</td><td class="doc"><p>initial state: tag and value</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>mealy</code> processes model Mealy state machines. It is an
 instantiation of the <code>mealy</code> MoC constructor
 (see <code><a href="ForSyDe-Atom-MoC.html#v:mealy22">mealy22</a></code>).</p><p>The following constructors are provided:</p><pre>mealy11, mealy12, mealy13, mealy14,
mealy21, mealy22, mealy23, mealy24,
mealy31, mealy32, mealy33, mealy34,
mealy41, mealy42, mealy43, mealy44,</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeS 7 $ mealy11 (+) (-) (6,1) s
</code></strong>{ 0 @0s, -1 @2s, -1 @6s, -1 @8s, -2 @9s, 0 @12s, 2 @14s}
</pre><p><img src="docfiles/figs/moc-de-pattern-mealy.png" /></p></div></div><h2 id="g:5">Interface processes</h2><div class="top"><p class="src"><a name="v:toSY2" class="def">toSY2</a> <a href="src/ForSyDe-Atom-MoC-DE-Interface.html#toSY2" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b</td><td class="doc"><p>second input DE signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> <a href="ForSyDe-Atom-MoC-DE.html#t:TimeStamp">TimeStamp</a>, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> a, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> b)</td><td class="doc"><p>signal carrying timestamps tupled with the two output
 <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY">SY</a></code> signals</p></td></tr></table></div><div class="doc"><p>Synchronizes a (set of) <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE">DE</a></code> signal(s) an
 strips off their explicit tags, outputting the equivalent
 <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY">SY</a></code> signal(s), tupled with an SY signal
 carrying the timestamps for the synchronization points.</p><p>The following constructors are provided:</p><pre>toSY, toSY2, toSY3, toSY4</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.infinite 1
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = DE.readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toSY2 s1 s2
</code></strong>({0s,2s,6s,8s,9s},{1,1,1,1,1},{1,2,3,4,5})
</pre><p><img src="docfiles/figs/moc-de-tosy.png" /></p></div></div><div class="top"><p class="src"><a name="v:toCT2" class="def">toCT2</a> <a href="src/ForSyDe-Atom-MoC-DE-Interface.html#toCT2" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b</td><td class="doc"><p>second input DE signal</p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-CT.html#t:Signal">Signal</a> a, <a href="ForSyDe-Atom-MoC-CT.html#t:Signal">Signal</a> b)</td><td class="doc"><p>two output <code><a href="ForSyDe-Atom-MoC-CT.html#v:CT">CT</a></code> signals</p></td></tr></table></div><div class="doc"><p>Semantic preserving transformation between a (set of) DE
 signal(s) and the equivalent CT signals, provided there is a
 relation between the timestamps and real time. There is no
 interpolation or other convertion method involved, the CT events
 being represented as constant functions during their time span.</p><p>The following constructors are provided:</p><pre>toCT, toCT2, toCT3, toCT4</pre><p>TODO: example</p><p><img src="docfiles/figs/moc-de-toct.png" /></p></div></div><div class="top"><p class="src"><a name="v:zipx" class="def">zipx</a> :: <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a) -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (<a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a) <a href="src/ForSyDe-Atom-MoC-DE-Interface.html#zipx" class="link">Source</a></p><div class="doc"><p>Synchronizes all the signals contained by a vector and zips them
 into one signal of vectors. It instantiates the
 <code><a href="ForSyDe-Atom-Skeleton-Vector.html#v:zipx">zipx</a></code> skeleton.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s2 = DE.readSignal &quot;{1@0, 2@2, 3@4, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [s1,s1,s2,s2]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>v1
</code></strong>&lt;{ 1 @0s, 2 @2s, 3 @6s, 4 @8s, 5 @9s},{ 1 @0s, 2 @2s, 3 @6s, 4 @8s, 5 @9s},{ 1 @0s, 2 @2s, 3 @4s, 4 @8s, 5 @9s},{ 1 @0s, 2 @2s, 3 @4s, 4 @8s, 5 @9s}&gt;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>zipx v1
</code></strong>{ &lt;1,1,1,1&gt; @0s, &lt;2,2,2,2&gt; @2s, &lt;2,2,3,3&gt; @4s, &lt;3,3,3,3&gt; @6s, &lt;4,4,4,4&gt; @8s, &lt;5,5,5,5&gt; @9s}
</pre><p><img src="docfiles/figs/moc-de-zipx.png" /></p></div></div><div class="top"><p class="src"><a name="v:unzipx" class="def">unzipx</a> :: Integer -&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (<a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a) <a href="src/ForSyDe-Atom-MoC-DE-Interface.html#unzipx" class="link">Source</a></p><div class="doc"><p>Unzips the vectors carried by a signal into a vector of
 signals. It instantiates the <code><a href="ForSyDe-Atom-Skeleton-Vector.html#v:unzipx">unzipx</a></code>
 skeleton. To avoid infinite recurrence, the user needs to provide
 the length of the output vector.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [1,2,3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.signal [(0,v1),(2,v1),(6,v1),(8,v1),(9,v1)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s1
</code></strong>{ &lt;1,2,3,4&gt; @0s, &lt;1,2,3,4&gt; @2s, &lt;1,2,3,4&gt; @6s, &lt;1,2,3,4&gt; @8s, &lt;1,2,3,4&gt; @9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unzipx 4 s1
</code></strong>&lt;{ 1 @0s, 1 @2s, 1 @6s, 1 @8s, 1 @9s},{ 2 @0s, 2 @2s, 2 @6s, 2 @8s, 2 @9s},{ 3 @0s, 3 @2s, 3 @6s, 3 @8s, 3 @9s},{ 4 @0s, 4 @2s, 4 @6s, 4 @8s, 4 @9s}&gt;
</pre><p><img src="docfiles/figs/moc-de-unzipx.png" /></p></div></div><div class="top"><p class="src"><a name="v:unzipx-39-" class="def">unzipx'</a> :: <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> (<a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> a) -&gt; <a href="ForSyDe-Atom-Skeleton-Vector.html#t:Vector">Vector</a> (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a) <a href="src/ForSyDe-Atom-MoC-DE-Interface.html#unzipx%27" class="link">Source</a></p><div class="doc"><p>Same as <code><a href="ForSyDe-Atom-MoC-DE.html#v:unzipx">unzipx</a></code>, but &quot;sniffs&quot; the first event to determine the length of the output vector. Might have unsafe behavior!</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let v1 = V.vector [1,2,3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s1 = DE.signal [(0,v1),(2,v1),(6,v1),(8,v1),(9,v1)]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s1
</code></strong>{ &lt;1,2,3,4&gt; @0s, &lt;1,2,3,4&gt; @2s, &lt;1,2,3,4&gt; @6s, &lt;1,2,3,4&gt; @8s, &lt;1,2,3,4&gt; @9s}
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unzipx' s1
</code></strong>&lt;{ 1 @0s, 1 @2s, 1 @6s, 1 @8s, 1 @9s},{ 2 @0s, 2 @2s, 2 @6s, 2 @8s, 2 @9s},{ 3 @0s, 3 @2s, 3 @6s, 3 @8s, 3 @9s},{ 4 @0s, 4 @2s, 4 @6s, 4 @8s, 4 @9s}&gt;
</pre></div></div><h2 id="g:6">Hybrid processes</h2><div class="top"><p class="src"><a name="v:embedSY22" class="def">embedSY22</a> <a href="src/ForSyDe-Atom-MoC-DE-Hybrid.html#embedSY22" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> a1 -&gt; <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> a2 -&gt; (<a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-SY.html#t:Signal">Signal</a> b2))</td><td class="doc"><p><code><a href="ForSyDe-Atom-MoC-SY.html#v:SY">SY</a></code> process</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a1</td><td class="doc"><p>first input DE signal</p></td></tr><tr><td class="src">-&gt; <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> a2</td><td class="doc"><p>second input DE signal </p></td></tr><tr><td class="src">-&gt; (<a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b1, <a href="ForSyDe-Atom-MoC-DE.html#t:Signal">Signal</a> b2)</td><td class="doc"><p>two output <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE">DE</a></code> signals</p></td></tr></table></div><div class="doc"><p>Embeds a <code><a href="ForSyDe-Atom-MoC-SY.html#v:SY">SY</a></code> process inside a
 <code><a href="ForSyDe-Atom-MoC-DE.html#v:DE">DE</a></code> environment. Internally, it synchronizes
 the input signals, translates them to SY, feeds them to a SY
 process and translates the result back to DE using the same input
 tags. Seen from outside, this process behaves like a DE process
 with &quot;instantaneous response&quot;, even for feedback loops.</p><p>The following constructors are provided:</p><pre>embedSY11, embedSY12, embedSY13, embedSY14,
embedSY21, embedSY22, embedSY23, embedSY24,
embedSY31, embedSY32, embedSY33, embedSY34,
embedSY41, embedSY42, embedSY43, embedSY44,</pre><p>For the following example, see the difference between its output
 and the one of <code><a href="ForSyDe-Atom-MoC-DE.html#v:stated22">stated22</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let s = readSignal &quot;{1@0, 2@2, 3@6, 4@8, 5@9}&quot; :: DE.Signal Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embedSY11 (SY.stated11 (+) 1) s
</code></strong>{ 1 @0s, 2 @2s, 4 @6s, 7 @8s, 11 @9s}
</pre><p><img src="docfiles/figs/moc-de-pattern-embedsy.png" /></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>