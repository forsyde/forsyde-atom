-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A shallow-embedded DSL for modeling cyber-physical systems
--   
--   The ForSyDe (Formal System Design) methodology has been developed with
--   the objective to move system design to a higher level of abstraction
--   and to bridge the abstraction gap by transformational design
--   refinement. It targets the modelling and characterization of
--   cyber-physical systems inheriting the theory of <a>Models of
--   Computation (MoCs)</a>, providing both a correct-by-construction
--   execution model and analyzable entry point for further synthesis
--   flows. For more information about ForSyDe and its associated projects
--   please consult the <a>ForSyDe webpage</a>.
--   
--   The <tt>forsyde-atom</tt> library is a shallow-embedded DSL
--   implementing the execution semantics of an <i>atom-based approach</i>
--   to ForSyDe. Its purpose is to provide a modeling framework for
--   cyber-physical systems and to serve as a proof-of-concept for a future
--   (non-strict typed) DSL. Adhering to the formalism set by the <a>PhD
--   Thesis of Ingo Sander</a>, the current framework views systems as
--   networks of processes communicating through signals. The <i>atom-based
--   approach</i> to ForSyDe adds some new important concepts:
--   
--   <ul>
--   <li>the separation of concerns through semantically-independent
--   <b><i>layers</i></b> of computation, behavior, synchronization and
--   structure. Each layer offers a different analyzable view of a given
--   system and is described using the concept of <i>higher-order
--   functions</i>.</li>
--   <li>the description of each layer as a network of primitive building
--   blocks called <b><i>atoms</i></b>. Each atom embeds an undividable
--   operation, and wraps functions of lower layers with the semantics
--   dictated by a higher layer. They are described using the powerful
--   concept of <i>applicative functors</i>.</li>
--   <li>the complete <b><i>autonomy</i></b> of atoms in relation to the
--   patterns they build. As such, process networks or constructors are
--   nothing but <i>structural</i> ad-hoc compositions that aid in
--   achieving complex behaviors whereas the actual behavior is dictated by
--   the atoms alone. This is proved (for the time being) for the
--   <i>Synchronization Layer</i> by implementing all MoCs as instances of
--   <i>only one type class</i>.</li>
--   </ul>
--   
--   While the host language limits the possibility of providing general
--   (e.g. proces) constructors due to type-strictness, the
--   <tt>forsyde-atom</tt> framework is by all means complete. In this
--   sense the user can create her own custom <i>correct-by-design</i>
--   constructors and networks as compositions of the provided atoms and
--   utilities. Also, this haddock-generated page is organized both as an
--   API documentation and as a technical report to facilitate te use and
--   understanding of the formal principles behing the design process.
@package forsyde-atom
@version 0.2.2.1


-- | This module defines the shallow-embedded <a>Stream</a> datatype and
--   utility functions operating on it. In ForSyDe a signal is represented
--   as a (partially or totally) <i>ordered</i> sequence of events that
--   enables processes to communicate and synchronize. The <a>Stream</a>
--   type is but an ordered structure to encapsulate events as infinite
--   streams.
module ForSyDe.Atom.MoC.Stream

-- | Defines a stream of events, encapsulating them in a structure
--   isomorphic to an infinite list <a>[Bird87]</a>, thus all properties of
--   lists may also be applied to <a>Stream</a>s. While, in combination
--   with lazy evaluation, it is possible to create and simulate infinite
--   signals, we need to ensure that the first/previous event is always
--   fully evaluated. This can be translated into the following rule:
--   
--   <ul>
--   <li><i>zero-delay feedbacks</i> are forbidden, due to un-evaluated
--   self-referential calls. In a feedback loop, there always has to be
--   enough events to ensure the data flow.</li>
--   </ul>
--   
--   This rule imposes that the stream of data is uninterrupted in order to
--   have an evaluatable kernel every time a new event is produced (i.e. to
--   avoid deadlocks). Thus we can add the rule:
--   
--   <ul>
--   <li><i>cleaning of output events</i> is also forbidden. In other
--   words, for each new input at any instant in time, a process must react
--   with <i>at least</i> one output event.</li>
--   </ul>
data Stream e

-- | terminates a signal
NullS :: Stream e

-- | the default constructor appends an event to the head of the stream
(:-) :: e -> Stream e -> Stream e

-- | allows for the mapping of an arbitrary function <tt>(a -&gt; b)</tt>
--   upon all the events of a <tt>(<a>Stream</a> a)</tt>.

-- | enables the <a>Stream</a> to behave like a <a>ZipList</a>

-- | provides folding functions useful for implementing utilities, such as
--   <a>length</a>.

-- | signal <tt>(1 :- 2 :- NullS)</tt> is represented as <tt>{1,2}</tt>.

-- | signal <tt>(1 :- 2 :- NullS)</tt> is read using the string
--   <tt>"{1,2}"</tt>.

-- | The function <tt>signal</tt> converts a list into a signal.
stream :: [a] -> Stream a

-- | The function <a>fromStream</a> converts a signal into a list.
fromStream :: Stream a -> [a]

-- | Returns the head of a signal.
headS :: Stream a -> a

-- | Returns the tail of a signal
tailS :: () => Stream e -> Stream e

-- | Returns the last event in a signal.
lastS :: () => Stream p -> p

-- | Returns an infinite list containing the same repeated event.
repeatS :: a -> Stream a

-- | Returns the first <tt>n</tt> events in a signal.
takeS :: (Ord t, Num t) => t -> Stream e -> Stream e

-- | Drops the first <tt>n</tt> events in a signal.
dropS :: (Ord t, Num t) => t -> Stream e -> Stream e

-- | Returns the first events of a signal which comply to a condition.
takeWhileS :: (a -> Bool) -> Stream a -> Stream a

-- | Concatenates two signals.
(+-+) :: () => Stream e -> Stream e -> Stream e
instance GHC.Base.Functor ForSyDe.Atom.MoC.Stream.Stream
instance GHC.Base.Applicative ForSyDe.Atom.MoC.Stream.Stream
instance Data.Foldable.Foldable ForSyDe.Atom.MoC.Stream.Stream
instance GHC.Show.Show a => GHC.Show.Show (ForSyDe.Atom.MoC.Stream.Stream a)
instance GHC.Read.Read a => GHC.Read.Read (ForSyDe.Atom.MoC.Stream.Stream a)


-- | This module implements a timestamp data type, based on
--   <a>Data.Time.Clock</a>.
module ForSyDe.Atom.MoC.TimeStamp

-- | Alias for the type representing discrete time. It is inherently
--   quantizable, the quantum being a picosecond (10⁻¹² seconds), thus it
--   can be considered order-isomorphic with a set of integers, i.e.
--   between any two timestamps there is a finite number of timestamps.
--   Moreover, a timestamp can be easily translated into a rational number
--   representing fractions of a second, so the conversion between
--   timestamps (discrete time) and rationals (analog/continuous time) is
--   straightforward.
--   
--   This type is used in the explicit tags of the <a>DE</a> MoC (and
--   subsequently the discrete event evaluation engine for simulating the
--   <a>CT</a> MoC).
type TimeStamp = DiffTime

-- | Specifies a timestamp in terms of picoseconds.
picosec :: Integer -> TimeStamp

-- | Specifies a timestamp in terms of nanoseconds.
nanosec :: Integer -> TimeStamp

-- | Specifies a timestamp in terms of microseconds.
microsec :: Integer -> TimeStamp

-- | Specifies a timestamp in terms of miliseconds.
milisec :: Integer -> TimeStamp

-- | Specifies a timestamp in terms of seconds.
sec :: Integer -> TimeStamp

-- | Specifies a timestamp in terms of minutes.
minutes :: Integer -> TimeStamp

-- | Specifies a timestamp in terms of hours.
hours :: Integer -> TimeStamp

-- | Converts a timestamp to a rational number, used for describing
--   continuous time.
toTime :: TimeStamp -> Rational

-- | <a>TimeStamp</a> representation of the number π. Converted from the
--   <a>Prelude</a> equivalent, which is <a>Floating</a>.
pi :: TimeStamp

-- | reads <tt>[n]s</tt> as a fraction of a second, where <tt>[n]</tt> is a
--   floating point number.
instance GHC.Read.Read Data.Time.Clock.Internal.DiffTime.DiffTime


-- | Collection of utility functions for working with <a>Time</a>. While
--   the <a>CT</a> MoC describes time as being a non-disjoint continuum
--   (represented in ForSyDe-Atom with <a>Rational</a> numbers), most of
--   the functions here are non-ideal approximations or conversions from
--   floating point equivalents. The trigonometric functions are imported
--   from the <a>numbers</a> package, with a fixed <tt>eps</tt> parameter.
--   
--   These utilities are meant to get started with using the CT MoC, and
--   should be used with caution if result fidelity is a requirement. In
--   this case the user should find a native <a>Rational</a> implementation
--   for a particular function.
module ForSyDe.Atom.MoC.Time

-- | Type alias for the type to represent metric (continuous) time.
--   Underneath we use <a>Rational</a> that is able to represent any
--   <i>t</i> between <i>t₁</i> &lt; <i>t₂</i> ∈ <i>T</i>.
type Time = Rational

-- | Converts <a>TimeStamp</a> into <a>Time</a> representation.
time :: TimeStamp -> Time

-- | Returns a constant function.
const :: a -> (Time -> a)

-- | Euler's number in <a>Time</a> format. Converted from the
--   <a>Prelude</a> equivalent, which is <a>Floating</a>.
e :: Time

-- | "Power of" function taking <a>Time</a>s as arguments. Converts back
--   and forth to <a>Floating</a>, as it uses the <a>**</a> operator, so it
--   is prone to conversion errors.
(*^*) :: Time -> Time -> Time

-- | <a>Time</a> representation of the number π. Rational representation
--   with a precision of <tt>0.000001</tt>.
pi :: Time

-- | Sine of <a>Time</a>. Rational representation with a precision of
--   <tt>0.000001</tt>.
sin :: Time -> Time

-- | Cosine of <a>Time</a>. Rational representation with a precision of
--   <tt>0.000001</tt>.
cos :: Time -> Time

-- | Tangent of <a>Time</a>. Rational representation with a precision of
--   <tt>0.000001</tt>.
tan :: Time -> Time

-- | Arctangent of <a>Time</a>. Rational representation with a precision of
--   <tt>0.000001</tt>.
atan :: Time -> Time

-- | Arcsine of <a>Time</a>. Rational representation with a precision of
--   <tt>0.000001</tt>.
asin :: Time -> Time

-- | Arccosine of <a>Time</a>. Rational representation with a precision of
--   <tt>0.000001</tt>.
acos :: Time -> Time

-- | Square root of <a>Time</a>. Rational representation with a precision
--   of <tt>0.000001</tt>.
sqrt :: Time -> Time

-- | Exponent of <a>Time</a>. Rational representation with a precision of
--   <tt>0.000001</tt>.
exp :: Time -> Time

-- | Hyperbolic cosine of <a>Time</a>. Rational representation with a
--   precision of <tt>0.000001</tt>.
cosh :: Time -> Time

-- | Hyperbolic sine of <a>Time</a>. Rational representation with a
--   precision of <tt>0.000001</tt>.
sinh :: Time -> Time

-- | Hyperbolic tangent of <a>Time</a>. Rational representation with a
--   precision of <tt>0.000001</tt>.
tanh :: Time -> Time

-- | Hyperbolic arctangent of <a>Time</a>. Rational representation with a
--   precision of <tt>0.000001</tt>.
atanh :: Time -> Time

-- | Hyperbolic arcsine of <a>Time</a>. Rational representation with a
--   precision of <tt>0.000001</tt>.
asinh :: Time -> Time

-- | Hyperbolic arccosine of <a>Time</a>. Rational representation with a
--   precision of <tt>0.000001</tt>.
acosh :: Time -> Time

-- | Natural logarithm of <a>Time</a>. Rational representation with a
--   precision of <tt>0.000001</tt>.
log :: Time -> Time


-- | This module implements general purpose utility functions. It mainly
--   hosts functions dealing with tuples. Utility are provided for up until
--   9-tuples. Follow the examples in the source code in case it does not
--   suffice.
--   
--   <b>IMPORTANT!!!</b> Most of the multi-parameter higher-order functions
--   provided by the library API are named along the lines of
--   <tt>functionMN</tt> where <tt>M</tt> represents the number of
--   <b><i>curried</i></b> inputs (i.e. <tt>a1 -&gt; a2 -&gt; ... -&gt;
--   aM</tt>), while <tt>N</tt> represents the number of
--   <b><i>tupled</i></b> outputs (i.e. <tt>(b1,b2,...,bN)</tt>). To avoid
--   repetition we shall only provide documentation for functions with 2
--   inputs and 2 outputs (i.e. <tt>function22</tt>).
module ForSyDe.Atom.Utility.Tuple

-- | The <tt>at</tt><i>xy</i> functions return the <i>y</i>-th element of
--   an <i>x</i>-tuple.
--   
--   <a>ForSyDe.Atom.Utility</a> exports the constructors below. Please
--   follow the examples in the source code if they do not suffice:
--   
--   <pre>
--   at21, at22,
--   at31, at32, at33,
--   at41, at42, at43, at44,
--   at51, at52, at53, at54, at55,
--   at61, at62, at63, at64, at65, at66, 
--   at71, at72, at73, at74, at75, at76, at77,
--   at81, at82, at83, at84, at85, at86, at87, at88,
--   at91, at92, at93, at94, at95, at96, at97, at98, at99,
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; at53 (1,2,3,4,5)
--   3
--   </pre>
at22 :: (a1, a2) -> a2

-- | This set of utility functions "unzip" nested n-tuples, provided as
--   postfix operators. They are crucial for reconstructing data types from
--   higher-order functions which input functions with multiple outputs. It
--   relies on the nested types being instances of <a>Functor</a>.
--   
--   The operator convention is <tt>(|+&lt;+)</tt>, where the number of
--   <tt>|</tt> represent the number of layers the n-tuple is lifted, while
--   the number of <tt>&lt;</tt> + 1 is the order <i>n</i> of the n-tuple.
--   
--   <a>ForSyDe.Atom.Utility</a> exports the constructors below. Please
--   follow the examples in the source code if they do not suffice:
--   
--   <pre>
--      |&lt;,    |&lt;&lt;,    |&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,
--     ||&lt;,   ||&lt;&lt;,   ||&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,
--    |||&lt;,  |||&lt;&lt;,  |||&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,  
--   ||||&lt;, ||||&lt;&lt;, ||||&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;, 
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XPostfixOperators
--   
--   &gt;&gt;&gt; ([Just (1,2,3), Nothing, Just (4,5,6)] ||&lt;&lt;)
--   ([Just 1,Nothing,Just 4],[Just 2,Nothing,Just 5],[Just 3,Nothing,Just 6])
--   </pre>
(||<) :: (Functor f1, Functor f2) => f1 (f2 (a1, a2)) -> (f1 (f2 a1), f1 (f2 a2))
infixl 3 ||<

-- | Infix currying operators used for convenience.
--   
--   The operator convention is <tt>(&lt;&gt;+)</tt>, where the number of
--   <tt>&gt;</tt> + 1 is the order <i>n</i> of the n-tuple.
--   
--   <a>ForSyDe.Atom.Utility</a> exports the constructors below. Please
--   follow the examples in the source code if they do not suffice:
--   
--   <pre>
--   &lt;&gt;, &lt;&gt;&gt;, &lt;&gt;&gt;&gt;, &lt;&gt;&gt;&gt;&gt;, &lt;&gt;&gt;&gt;&gt;&gt;, &lt;&gt;&gt;&gt;&gt;&gt;&gt;, &lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;, &lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; (+) &lt;&gt; (1,2)
--   3
--   </pre>
(<>) :: (a1 -> a2 -> b1) -> (a1, a2) -> b1
infixl 6 <>

-- | Infix function application operator for tuples.
--   
--   The operator convention is <tt>($+)</tt>, where the number of
--   <tt>$</tt> is the order <i>n</i> of the n-tuple. For Applying a
--   function on nontuples we rely on <a>$</a> provided by <a>Prelude</a>.
--   
--   <a>ForSyDe.Atom.Utility</a> exports the constructors below. Please
--   follow the examples in the source code if they do not suffice:
--   
--   <pre>
--   $$, $$$, $$$$, $$$$$, $$$$$$, $$$$$$$, $$$$$$$$, $$$$$$$$$
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; ((+),(-)) $$ (1,1) $$ (2,2)
--   (3,-1)
--   </pre>
($$) :: (a1 -> b1, a2 -> b2) -> (a1, a2) -> (b1, b2)
infixl 6 $$


-- | This parent module contains sub-modules that concern utility
--   functions. Due to legacy reasons, only the
--   <a>ForSyDe.Atom.Utility.Tuple</a> module is re-exported. All other
--   sub-modules need to be imported explicitly.
module ForSyDe.Atom.Utility


-- | This module exports a type class with the interfaces for the Skeleton
--   layer atoms. It does <i>NOT</i> export any implementation of atoms not
--   any constructor as composition of atoms.
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.Skeleton

-- | Class containing all the Skeleton layer atoms.
--   
--   This class is instantiated by a set of categorical types, i.e. types
--   which describe an inherent potential for being evaluated in parallel.
--   Skeletons are patterns from this layer. When skeletons take as
--   arguments entities from the MoC layer (i.e. processes), the results
--   themselves are parallel process networks which describe systems with
--   an inherent potential to be implemented on parallel platforms. All
--   skeletons can be described as composition of the three atoms below
--   (<a>=&lt;&lt;=</a> being just a specific instantiation of <a>=\=</a>).
--   This possible due to an existing theorem in the categorical type
--   theory, also called the Bird-Merteens formalism <a>[Bird97]</a>:
--   
--   
--   <ul>
--   <li><i>factorization</i> A function on a categorical type is an
--   algorithmic skeleton (i.e. catamorphism) <i>iff</i> it can be
--   represented in a factorized form, i.e. as a <i>map</i> composed with a
--   <i>reduce</i>.</li>
--   </ul>
--   
--   Consequently, most of the skeletons for the implemented categorical
--   types are described in their factorized form, taking as arguments
--   either:
--   
--   <ul>
--   <li>type constructors or functions derived from type constructors</li>
--   <li>processes, i.e. MoC layer entities</li>
--   </ul>
--   
--   Most of the ground-work on algorithmic skeletons on which this module
--   is founded has been laid in <a>[Bird97]</a>, <a>[Skillicorn05]</a> and
--   it founds many of the frameworks collected in <a>[Gorlatch03]</a>.
class Functor c => Skeleton c

-- | Atom which maps a function on each element of a structure (i.e.
--   categorical type), defined as:
--   
--   
--   <a>=.=</a> together with <a>=*=</a> form the <tt>map</tt> pattern.
(=.=) :: Skeleton c => (a -> b) -> c a -> c b

-- | Atom which applies the functions contained by as structure (i.e.
--   categorical type), on the elements of another structure, defined as:
--   
--   
--   <a>=.=</a> together with <a>=*=</a> form the <tt>map</tt> pattern.
(=*=) :: Skeleton c => c (a -> b) -> c a -> c b

-- | Atom which reduces a structure to an element based on an
--   <i>associative</i> function, defined as:
--   
(=\=) :: Skeleton c => (a -> a -> a) -> c a -> a

-- | Skeleton which <i>pipes</i> an element through all the functions
--   contained by a structure.
--   
--   <b>N.B.</b>: this is not an atom. It has an implicit definition which
--   might be augmented by instances of this class to include edge cases.
--   
--   
--   As the composition operation is not associative, we cannot treat
--   <tt>pipe</tt> as a true reduction. Alas, it can still be exploited in
--   parallel since it exposes another type of parallelism: time
--   parallelism.
(=<<=) :: Skeleton c => c (a -> a) -> a -> a

-- | Returns the first element in a structure.
--   
--   <b>N.B.</b>: this is not an atom. It has an implicit definition which
--   might be replaced by instances of this class with a more efficient
--   implementation.
--   
first :: Skeleton c => c a -> a

-- | Returns the last element in a structure.
--   
--   <b>N.B.</b>: this is not an atom. It has an implicit definition which
--   might be replaced by instances of this class with a more efficient
--   implementation.
--   
last :: Skeleton c => c a -> a

-- | <tt>farm</tt> maps a function on a vector. It is the embodiment of the
--   <tt>map</tt> homomorphism, and its naming is inspired from the pattern
--   predominant in HPC. Indeed, if we consider the layer below as being
--   the <a>MoC</a> layer (i.e. the passed functions are processes), the
--   resulting structure could be regarded as a "farm of data-parallel
--   processes".
--   
--   Constructors: <tt>farm[1-8][1-4]</tt>.
--   
farm22 :: Skeleton c => (a1 -> a2 -> (b1, b2)) -> c a1 -> c a2 -> (c b1, c b2)

-- | Infix name for the <a>=\=</a> atom operator.
--   
--   (*) if the operation is not associative then the network can be
--   treated like a pipeline.
reduce :: Skeleton c => (a -> a -> a) -> c a -> a

-- | <a>reducei</a> is special case of <a>reduce</a> where an initial
--   element is specified outside the reduced vector. It is implemented as
--   a <a>pipe</a> with switched arguments, and the reduction function is
--   constrained to be associative. It is semantically equivalent to the
--   pattern depicted below.
--   
--   (*) if the operation is not associative then the network is
--   semantically equivalent to <tt>pipe1</tt> (see <a>pipe2</a>).
--   
reducei :: Skeleton c => (a -> a -> a) -> a -> c a -> a

-- | Infix name for the <a>=&lt;&lt;=</a> skeleton operator.
pipe :: Skeleton c => c (a -> a) -> a -> a

-- | The <tt>pipe</tt> constructors are a more generic form of the
--   <a>=&lt;&lt;=</a> (<a>pipe</a>) skeleton apt for successive partial
--   application and create more robust parameterizable pipeline networks.
--   
--   Constructors: <tt>comb[1-8]</tt>.
--   
pipe2 :: Skeleton c => (a1 -> a2 -> a -> a) -> c a1 -> c a2 -> a -> a


-- | This module exports the core entities of the MoC layer: interfaces for
--   atoms and process constructors as patterns of atoms. It does
--   <i>NOT</i> export any implementation or instantiation of any specific
--   MoC.
--   
--   Current MoC implementations can be used by importing their respective
--   modules:
--   
--   <ul>
--   <li><a>ForSyDe.Atom.MoC.CT</a></li>
--   <li><a>ForSyDe.Atom.MoC.DE</a></li>
--   <li><a>ForSyDe.Atom.MoC.SY</a></li>
--   <li><a>ForSyDe.Atom.MoC.SDF</a></li>
--   </ul>
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.MoC

-- | This is a type class defining interfaces for the MoC layer atoms. Each
--   model of computation exposes its tag system through a unique event
--   constructor as an instance of this class, which defines <i>T</i> ×
--   <i>V</i>.
--   
--   To express all possible MoCs which can be described using a
--   <i>tagged</i> <i>signal</i> <i>model</i> we need to capture the most
--   general form of their atoms. Recall that all atoms in the layered
--   framework are represented as higher-order functions on structured
--   types (instances of this class), taking functions of other (lower)
--   layers as arguments. While this principle stands also for this layer,
--   the functions taken as arguments need to be formatted for each MoC in
--   particular in order to capture additional information, which we can
--   call in general terms as the <i>execution context</i>.
--   
--   One typical example of additional information is the consumption and
--   production rates of for data flow MoCs (e.g. SDF). In this case the
--   passed functions are defined over "partitions" of events, i.e.
--   groupings of events with the same partial order in relation to, for
--   example, a process firing. The formal description of such a "formatted
--   function" taken as argument by a MoC entity is:
--   
--   
--   where <i>a</i> and <i>b</i> might be Cartesian products of different
--   types, corresponding to how many signals the constructor is applied to
--   or how many signals it yields, and each type is expressed as:
--   
--   
--   While, as you can see above, the execution context can be extracted
--   from the type information, working with type-level parameters is not a
--   trivial task in Haskell, especially if we want to describe a general
--   and extensible type class. This is why we have chosen a pragmatic
--   approach in implementing the <a>MoC</a> class:
--   
--   <ul>
--   <li>any (possible) Cartesian product of <i>α</i> is represented using
--   a recursive type, namely a list [<i>α</i>].</li>
--   <li>as the execution context cannot (or can hardly) be extracted from
--   the recursive type, in the most general case we pass both context
--   <i>and</i> argument as a pair (see each instance in particular). To
--   aid in pairing contexts with each argument in a function, the
--   <tt>ctxt</tt> utilities are provided (see <a>ctxt22</a>).</li>
--   <li>this artifice was masked using the generic type families
--   <a>Fun</a> and <tt>Res</tt>.</li>
--   </ul>
class (Applicative e) => MoC e where {
    type family Fun e a b;
    type family Ret e b;
}

-- | This atom is mapping a function on values (in the presence of a
--   context) to a signal, i.e. stream of tagged events. As ForSyDe deals
--   with <i>determinate</i>, <i>functional</i> processes, this atom
--   defines the (only) <i>behavior</i> of a process in rapport to one
--   input signal <a>[Lee98]</a>.
--   
(-.-) :: MoC e => Fun e a b -> Stream (e a) -> Stream (e b)

-- | This atom synchronizes two signals, one carrying functions on values
--   (in the presence of a context), and the other containing values,
--   during which it applies the former on the latter. As concerning the
--   process created, this atom defines a <i>relation</i> between two
--   signals <a>[Lee98]</a>.
--   
(-*-) :: MoC e => Stream (e (Fun e a b)) -> Stream (e a) -> Stream (e b)

-- | Artificial <i>utility</i> which drops the context and/or partitioning
--   yielding a clean signal type.
--   
(-*) :: MoC e => Stream (e (Ret e b)) -> Stream (e b)

-- | This atom appends a (partition of) events at the beginning of a
--   signal. This atom is necessary to ensure <i>complete partial order</i>
--   of a signal and assures the <i>least upper bound</i> necessary for
--   example in the evaluation of feedback loops <a>[Lee98]</a>.
--   
--   
--   Notice the difference between the formal and the implemented type
--   signatures. In the implementation the value/partition is wrapped
--   inside an event type to enable smooth composition. You might also
--   notice the type for the "initial event(s)" as being wrapped inside a
--   signal constructor. This allows defining an DSL for this layer which
--   is centered around signals exclusively, while also enabling to define
--   atoms as homomorphisms to certain extent <a>[Bird97]</a>. Certain MoCs
--   might have additional constraints on the first operand to be finite.
(-<-) :: MoC e => Stream (e a) -> Stream (e a) -> Stream (e a)

-- | This atom allows the manipulation of tags in a signal in a restrictive
--   way which preserves <i>monotonicity</i> and <i>continuity</i> in a
--   process <a>[Lee98]</a>, namely by “phase-shifting” all tags in a
--   signal with the appropriate metric corresponding to each MoC. Thus it
--   preserves the characteristic function intact <a>[Sander04]</a>.
--   
--   
--   As with the <a>-&lt;-</a> atom, we can justify the type signature for
--   smooth composition and the definition of atoms as homomorphisms to
--   certain extent. This in turn allows the interpretation of the
--   <a>-&amp;-</a> operator as "aligning the phases" of two signals: the
--   second operand is aligned based on the first.
(-&-) :: MoC e => Stream (e a) -> Stream (e a) -> Stream (e a)

-- | 
--   The <a>delay</a> process provides both initial token(s) and shifts the
--   phase of the signal. In other words, it "delays" a signal with one or
--   several events.
--   
--   There is also an infix variant <a>-&amp;&gt;-</a> (<tt>infixl 3</tt>).
--   To justify the first argument, see the documentation of the
--   <a>-&lt;-</a> atom.
delay :: MoC e => Stream e a -> Stream e a -> Stream e a

-- | <i>(*) to be read </i> <tt>a1 -&gt; a2 -&gt; (b1, b2)</tt> <i>where
--   each</i> <i>argument and result might be individually wrapped with a
--   context</i> <i>and might also express a partition.</i>
--   
--   
--   The <tt>comb</tt> processes takes care of synchronization between
--   signals and maps combinatorial functions on their event values.
--   
--   This library exports constructors of type <tt>comb[1-8][1-4]</tt>.
comb22 :: (MoC e) => (Fun e a1 (Fun e a2 (Ret e b1, Ret e b2))) -> Stream (e a1) -> Stream (e a2) -> (Stream (e b1), Stream (e b2))

-- | <i>(*) to be read </i> <tt>a1 -&gt; a2 -&gt; (b1, b2)</tt> <i>where
--   each</i> <i>argument and result might be individually wrapped with a
--   context</i> <i>and might also express a partition.</i>
--   
--   
--   The <tt>reconfig</tt> processes constructs adaptive processes, where
--   the first signal carries functions, and it is synchronized with all
--   the other signals.
--   
--   This library exports constructors of type <tt>reconfig[1-8][1-4]</tt>.
reconfig22 :: (MoC e) => Stream (e (Fun e a1 (Fun e a2 (Ret e b1, Ret e b2)))) -> Stream (e a1) -> Stream (e a2) -> (Stream (e b1), Stream (e b2))

-- | <i>(*) meaning </i> <tt>st1 -&gt; st2 -&gt; a1 -&gt; a2 -&gt;
--   (st1,st2)</tt> <i>where each argument and result might be individually
--   wrapped</i> <i>with a context and might also express a partition.</i>
--   
--   <i>(**) see the documentation for <a>-&lt;-</a> for justification</i>
--   <i>of the type</i>
--   
--   
--   The <tt>state</tt> processes generate process networks corresponding
--   to a simple state machine like in the graph above.
--   
--   This library exports constructors of type <tt>state[1-4][1-4]</tt>.
state22 :: MoC e => Fun e st1 (Fun e st2 (Fun e a1 (Fun e a2 (Ret e st1, Ret e st2)))) -> (Stream (e st1), Stream (e st2)) -> Stream (e a1) -> Stream (e a2) -> (Stream (e st1), Stream (e st2))

-- | <i>(*) meaning </i> <tt>st1 -&gt; st2 -&gt; a1 -&gt; a2 -&gt;
--   (st1,st2)</tt> <i>where each argument and result might be individually
--   wrapped</i> <i>with a context and might also express a partition.</i>
--   
--   <i>(**) see the documentation for <a>-&lt;-</a> for justification</i>
--   <i>of the type</i>
--   
--   
--   The <tt>state</tt> processes generate process networks corresponding
--   to a simple state machine like in the graph above. The difference
--   between <a>state22</a> and <a>stated22</a> is that the latter outputs
--   the current state rather than the next one. There exists a variant
--   with 0 input signals, in which case the process is a signal generator.
--   
--   This library exports constructors of type <tt>stated[0-4][1-4]</tt>.
stated22 :: MoC e => Fun e st1 (Fun e st2 (Fun e a1 (Fun e a2 (Ret e st1, Ret e st2)))) -> (Stream (e st1), Stream (e st2)) -> Stream (e a1) -> Stream (e a2) -> (Stream (e st1), Stream (e st2))

-- | <i>(*) meaning </i> <tt>st -&gt; a1 -&gt; a2 -&gt; st </tt> <i>where
--   each</i> <i>argument and result might be individually wrapped with a
--   context</i> <i>and might also express a partition.</i>
--   
--   <i>(**) meaning </i> <tt>st -&gt; (b1, b2) </tt> <i>where each
--   argument</i> <i>and result might be individually wrapped with a
--   context and might</i> <i>also express a partition.</i>
--   
--   <i>(***) see the documentation for <a>-&lt;-</a> for justification</i>
--   <i>of the type</i>
--   
--   
--   The <tt>moore</tt> processes model Moore state machines.
--   
--   This library exports constructors of type <tt>moore[1-4][1-4]</tt>.
moore22 :: MoC e => Fun e st (Fun e a1 (Fun e a2 (Ret e st))) -> Fun e st (Ret e b1, Ret e b2) -> Stream (e st) -> Stream (e a1) -> Stream (e a2) -> (Stream (e b1), Stream (e b2))

-- | <i>(*) meaning </i> <tt>st -&gt; a1 -&gt; a2 -&gt; st </tt> <i>where
--   each</i> <i>argument and result might be individually wrapped with a
--   context</i> <i>and might also express a partition.</i>
--   
--   <i>(**) meaning </i> <tt>st -&gt; a1 -&gt; a2 -&gt; (b1, b2) </tt>
--   <i>where</i> <i>each argument and result might be individually wrapped
--   with a</i> <i>context and might also express a partition.</i>
--   
--   <i>(***) see the documentation for <a>-&lt;-</a> for justification</i>
--   <i>of the type</i>
--   
--   
--   The <tt>mealy</tt> processes model Mealy state machines.
--   
--   This library exports constructors of type <tt>mealy[1-4][1-4]</tt>.
mealy22 :: MoC e => Fun e st (Fun e a1 (Fun e a2 (Ret e st))) -> Fun e st (Fun e a1 (Fun e a2 (Ret e b1, Ret e b2))) -> Stream (e st) -> Stream (e a1) -> Stream (e a2) -> (Stream (e b1), Stream (e b2))

-- | 
--   Wraps a function with the context needed by some MoCs for their
--   constructors (e.g. rates in SDF).
--   
--   This library exports wrappers of type <tt>ctxt[1-8][1-4]</tt>.
ctxt22 :: (ctx, ctx) -> (ctx, ctx) -> (a1 -> a2 -> (b1, b2)) -> (ctx, a1 -> (ctx, a2 -> ((ctx, b1), (ctx, b2))))

-- | Attaches a context parameter to a function argument (e.g consumption
--   rates in SDF). Used as kernel function in defining e.g. <a>ctxt22</a>.
warg :: c -> (a -> b) -> (c, a -> b)

-- | Attaches a context parameter to a function's result (e.g production
--   rates in SDF). Used as kernel function in defining e.g. <a>ctxt22</a>.
wres :: p -> b -> (p, b)

-- | Utilities for extending the <a>-*</a> atom for dealing with tupled
--   outputs. This library exports operators of form <tt>-*&lt;{1,8}</tt>.
(-*<) :: MoC e => Stream (e (Ret e b1, Ret e b2)) -> (Stream (e b1), Stream (e b2))
infixl 3 -*<


-- | This module defines the data type <a>Vector</a> as a categorical type,
--   and implements the atoms for the <a>Skeleton</a> class. Algorithmic
--   skeletons for <a>Vector</a> are mostly described in their factorized
--   form, which ensures that they are catamorphisms (see the
--   <a>factorization</a> theorem). Where efficiency or practicality is a
--   concern, some skeletons are implemented as recurrences. One can still
--   prove that they are catamorphisms through alternative theorems (see
--   <a>[Skillicorn05]</a>).
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.Skeleton.Vector

-- | The <a>Vector</a>, or at least its interpretation, is the exact
--   equivalent of an infinite list, as defined in <a>[Bird97]</a>. Its
--   name though is borrowed from <a>[Reekie95]</a>, since it is more
--   suggestive in the context of process networks.
--   
--   According to <a>[Bird97]</a>, <a>Vector</a> should be implemented as
--   following:
--   
--   <pre>
--   data Vector a = Null                   -- null element
--                 | Unit a                 -- singleton vector
--                 | Vector a &lt;++&gt; Vector a -- concatenate two vectors
--   </pre>
--   
--   This construction suggests the possibility of splitting a
--   <a>Vector</a> into multiple parts and evaluating it in parallel. Due
--   to reasons of efficiency, and to ensure that the structure is flat and
--   homogeneous, <a>Vector</a> is implemented using the same constructors
--   as an infinite list like in <a>[Bird87]</a> (see below). When defining
--   skeletons of vectors we will not use the real constructors though, but
--   the theoretical ones defined above and provided as <a>functions</a> .
--   This way we align ForSyDe-Atom's <a>Vector</a> type with the
--   categorical type theory and its theorems.
--   
--   Another particularity of <a>Vector</a> is that it instantiates the
--   reduction atom <a>=\=</a> as a <i>right fold</i>, as it is the most
--   efficient implementation in the context of lazy evaluation. As a
--   consequence reduction is performed <b><i>from right to left</i></b>.
--   This is noticeable especially in the case of pipeline-based skeletons
--   (where <a>pipe</a> itself is a reduction with the right-associative
--   composition operator <a>.</a>) is performed from right to left, which
--   comes in natural when considering the order of function composition.
--   Thus for <a>reduce</a>-based skeletons (e.g. <tt>prefix</tt>,
--   <tt>suffix</tt>, <tt>recur</tt>, <tt>cascade</tt>, <tt>mesh</tt>) the
--   result vectors shall be read from end to beginning.
data Vector a

-- | Null element. Terminates a vector.
Null :: Vector a

-- | appends an element at the head of a vector.
(:>) :: a -> (Vector a) -> Vector a

-- | Constructs a null vector.
--   
--   <pre>
--   &gt;&gt;&gt; null
--   &lt;&gt;
--   </pre>
null :: () => Vector a

-- | Constructs a singleton vector.
--   
--   <pre>
--   &gt;&gt;&gt; unit 1
--   &lt;1&gt;
--   </pre>
unit :: () => a -> Vector a

-- | Constructs a vector by appending two existing vectors.
--   
--   <pre>
--   &gt;&gt;&gt; unit 1 &lt;++&gt; unit 2
--   &lt;1,2&gt;
--   </pre>
(<++>) :: () => Vector a -> Vector a -> Vector a
infixr 5 <++>

-- | Converts a list to a vector.
vector :: () => [a] -> Vector a

-- | Converts a vector to a list.
fromVector :: () => Vector a -> [a]

-- | Creates the infinite vector:
--   
--   <pre>
--   &lt;1,2,3,4,...&gt;
--   </pre>
--   
--   Used mainly for operation on indexes.
indexes :: Vector Integer

-- | Returns <tt>True</tt> if the argument is a null vector.
isNull :: () => Vector a -> Bool

-- | Appends an element at the end of a vector.
(<:) :: () => Vector a -> a -> Vector a
infixl 5 <:

-- | <tt>farm</tt> is simply the <a>Vector</a> instance of the skeletom
--   <tt>farm</tt> pattern (see <a>farm22</a>). If the function taken as
--   argument is a process, then it creates a farm network of data parallel
--   processes.
--   
--   Constructors: <tt>farm[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [1,2,3,4,5]
--   
--   &gt;&gt;&gt; S.farm21 (+) v1 v1
--   &lt;2,4,6,8,10&gt;
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let v2 = vector [s1,s1,s1]
--   
--   &gt;&gt;&gt; S.farm11 (comb11 (+1)) v2
--   &lt;{2,3,4,5,6},{2,3,4,5,6},{2,3,4,5,6}&gt;
--   
--   &gt;&gt;&gt; S.farm21 (\x -&gt; comb11 (+x)) v1 v2
--   &lt;{2,3,4,5,6},{3,4,5,6,7},{4,5,6,7,8}&gt;
--   </pre>
--   
--   
farm22 :: (a1 -> a2 -> (b1, b2)) -> Vector a1 -> Vector a2 -> (Vector b1, Vector b2)

-- | As the name suggests, it reduces a vector to an element based on an
--   associative function. If the function is not associative, it can be
--   treated like a pipeline.
--   
--   <a>Vector</a> instantiates the skeletons for both <a>reduce</a> and
--   <a>reducei</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [1,2,3,4,5]
--   
--   &gt;&gt;&gt; S.reduce (+) v1
--   15
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let s2 = SY.signal [10,10,10,10,10]
--   
--   &gt;&gt;&gt; let v2 = vector [s1,s1,s1]
--   
--   &gt;&gt;&gt; S.reduce (comb21 (+)) v2
--   {3,6,9,12,15}
--   
--   &gt;&gt;&gt; S.reducei (comb21 (+)) s2 v2
--   {13,16,19,22,25}
--   </pre>
--   
reduce :: (a -> a -> a) -> Vector a -> a

-- | <tt>prefix</tt> peforms the <i>parallel prefix</i> operation on a
--   vector. Equivalent process networks are constructed if processes are
--   passed as arguments.
--   
--   Similar to <a>reduce</a> and <a>reducei</a>, two versions
--   <a>prefix</a> and <tt>prefixi</tt> are provided.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [1,2,3,4,5]
--   
--   &gt;&gt;&gt; prefix (+) v1
--   &lt;15,14,12,9,5&gt;
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let s2 = SY.signal [10,10,10,10,10]
--   
--   &gt;&gt;&gt; let v2 = vector [s1,s1,s1]
--   
--   &gt;&gt;&gt; prefix (comb21 (+)) v2
--   &lt;{3,6,9,12,15},{2,4,6,8,10},{1,2,3,4,5}&gt;
--   
--   &gt;&gt;&gt; prefixi (comb21 (+)) s2 v2
--   &lt;{13,16,19,22,25},{12,14,16,18,20},{11,12,13,14,15}&gt;
--   </pre>
--   
--   
--   
prefix :: () => (b -> b -> b) -> Vector b -> Vector b

-- | <tt>suffix</tt> peforms the <i>parallel suffix</i> operation on a
--   vector. Equivalent process networks are constructed if processes are
--   passed as arguments.
--   
--   Similar to <a>reduce</a> and <a>reducei</a>, two versions
--   <a>suffix</a> and <tt>suffixi</tt> are provided.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [1,2,3,4,5]
--   
--   &gt;&gt;&gt; suffix (+) v1
--   &lt;1,3,6,10,15&gt;
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let s2 = SY.signal [10,10,10,10,10]
--   
--   &gt;&gt;&gt; let v2 = vector [s1,s1,s1]
--   
--   &gt;&gt;&gt; suffix (comb21 (+)) v2
--   &lt;{1,2,3,4,5},{2,4,6,8,10},{3,6,9,12,15}&gt;
--   
--   &gt;&gt;&gt; suffixi (comb21 (+)) s2 v2
--   &lt;{11,12,13,14,15},{12,14,16,18,20},{13,16,19,22,25}&gt;
--   </pre>
--   
--   
--   
suffix :: () => (b -> b -> b) -> Vector b -> Vector b

-- | <tt>pipe</tt> creates a pipeline of functions from a vector.
--   <a>pipe</a> simply instantiates the <a>=&lt;&lt;=</a> atom whereas
--   <tt>pipeX</tt> instantiate their omologi from the
--   <a>ForSyDe.Atom.Skeleton</a> module (see <a>pipe2</a>).
--   
--   <b>OBS:</b> the pipelining is done in the order dictated by the
--   function composition operator: from right to left.
--   
--   Constructors: <tt>pipe[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [(+1),(+1),(+1)]
--   
--   &gt;&gt;&gt; S.pipe v1 1
--   4
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4]
--   
--   &gt;&gt;&gt; let v2 = vector [1,2,3,4]
--   
--   &gt;&gt;&gt; S.pipe1 (\x -&gt; comb11 (+x)) v2 s1
--   {11,12,13,14}
--   </pre>
--   
pipe :: Vector (a -> a) -> a -> a

-- | Infix operator for <a>recur</a>.
(=/=) :: () => Vector (a -> a) -> a -> Vector a
infixl 2 =/=

-- | <tt>recur</tt> creates a systolic array from a vector of functions.
--   Just like <a>pipe</a> and <tt>pipeX</tt>, there exists a raw
--   <a>recur</a> version with an infix operator <a>=/=</a>, and the
--   enhanced <tt>recurX</tt> which is meant for systematic partial
--   application of a function on an arbitrary number of vectors until the
--   desired vector of functions is obtained.
--   
--   Constructors: <tt>(=/=)</tt>, <tt>recur</tt>, <tt>recuri</tt>,
--   <tt>recur[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [(+1),(+1),(+1)]
--   
--   &gt;&gt;&gt; recur v1 1
--   &lt;4,3,2&gt;
--   
--   &gt;&gt;&gt; recuri v1 1
--   &lt;4,3,2,1&gt;
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4]
--   
--   &gt;&gt;&gt; let v2 = vector [1,2,3,4]
--   
--   &gt;&gt;&gt; recur1 (\x -&gt; comb11 (+x)) v2 s1
--   &lt;{11,12,13,14},{10,11,12,13},{8,9,10,11},{5,6,7,8}&gt;
--   </pre>
--   
--   
recur :: Vector (a -> a) -> a -> Vector a

-- | <tt>cascade</tt> creates a "cascading mesh" as a result of piping a
--   vector into a vector of recur arrays.
--   
--   Constructors: <tt>cascade</tt>, <tt>cascade[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [1,2,3,4]
--   
--   &gt;&gt;&gt; cascade (+) v1 v1
--   &lt;238,119,49,14&gt;
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4]
--   
--   &gt;&gt;&gt; let vs = vector [s1, s1, s1]
--   
--   &gt;&gt;&gt; cascade (comb21 (+)) vs vs
--   &lt;{20,40,60,80},{10,20,30,40},{4,8,12,16}&gt;
--   
--   &gt;&gt;&gt; let vv = vector [vector [1,-1,1], vector [-1,1,-1], vector [1,-1,1] ]
--   
--   &gt;&gt;&gt; cascade1 (\x -&gt; comb21 (\y z-&gt; x*(y+z))) vv vs vs
--   &lt;{16,32,48,64},{8,16,24,32},{-2,-4,-6,-8}&gt;
--   </pre>
--   
--   
cascade2 :: (a2 -> a1 -> a -> a -> a) -> Vector (Vector a2) -> Vector (Vector a1) -> Vector a -> Vector a -> Vector a

-- | <tt>mesh</tt> creates a 2D systolic array as a result of piping a
--   vector into a vector of 1D systolic arrays.
--   
--   Constructors: <tt>mesh</tt>, <tt>mesh[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = vector [1,2,3,4]
--   
--   &gt;&gt;&gt; mesh (+) v1 v1
--   &lt;&lt;238,119,49,14&gt;,&lt;119,70,35,13&gt;,&lt;49,35,22,11&gt;,&lt;14,13,11,8&gt;&gt;
--   
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4]
--   
--   &gt;&gt;&gt; let vs = vector [s1, s1, s1]
--   
--   &gt;&gt;&gt; mesh (comb21 (+)) vs vs
--   &lt;&lt;{20,40,60,80},{10,20,30,40},{4,8,12,16}&gt;,&lt;{10,20,30,40},{6,12,18,24},{3,6,9,12}&gt;,&lt;{4,8,12,16},{3,6,9,12},{2,4,6,8}&gt;&gt;
--   
--   &gt;&gt;&gt; let vv = vector [vector [1,-1,1], vector [-1,1,-1], vector [1,-1,1]]
--   
--   &gt;&gt;&gt; mesh1 (\x -&gt; comb21 (\y z-&gt; x*(y+z))) vv vs vs
--   &lt;&lt;{16,32,48,64},{8,16,24,32},{-2,-4,-6,-8}&gt;,&lt;{8,16,24,32},{-6,-12,-18,-24},{-3,-6,-9,-12}&gt;,&lt;{-2,-4,-6,-8},{-3,-6,-9,-12},{2,4,6,8}&gt;&gt;
--   </pre>
--   
--   
mesh2 :: (a2 -> a1 -> a -> a -> a) -> Vector (Vector a2) -> Vector (Vector a1) -> Vector a -> Vector a -> Vector (Vector a)

-- | returns the number of elements in a value.
--   
--   <pre>
--   &gt;&gt;&gt; length $ vector [1,2,3,4,5]
--   5
--   </pre>
--   
length :: Num p => Vector a -> p

-- | returns a vector with the indexes from another vector.
--   
--   <pre>
--   &gt;&gt;&gt; index $ vector [1,1,1,1,1,1,1]
--   &lt;1,2,3,4,5,6,7&gt;
--   </pre>
index :: () => Vector a2 -> Vector Integer

-- | <a>fanout</a> repeats an element. As a process network it distributes
--   the same value or signal to all the connected processes down the line.
--   Depending on the target platform and the refinement decisions
--   involved, it may be interpreted in the following implementations:
--   
--   <ul>
--   <li>global or shared memory in case of a massively parallel platform
--   (e.g. GPU)</li>
--   <li>a (static) memory or cache location in memory-driven architectures
--   (e.g. CPU)</li>
--   <li>a fanout in case of a HDL system</li>
--   <li>a broadcast in case of a distributed system</li>
--   </ul>
fanout :: () => t -> Vector t

-- | <a>fanoutn</a> is the same as <a>fanout</a>, but the length of the
--   result is also provided.
--   
--   <pre>
--   &gt;&gt;&gt; fanoutn 5 1
--   &lt;1,1,1,1,1&gt;
--   </pre>
fanoutn :: (Num t, Ord t) => t -> a -> Vector a

-- | <a>generate</a> creates a vector based on a kernel function. It is
--   just a restricted version of <a>recur</a>.
--   
--   <pre>
--   &gt;&gt;&gt; generate 5 (+1) 1
--   &lt;6,5,4,3,2&gt;
--   </pre>
--   
generate :: (Num t, Ord t) => t -> (a -> a) -> a -> Vector a

-- | <a>iterate</a> is a version of <a>generate</a> which keeps the initial
--   element as well. It is a restricted version of <tt>recuri</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; iterate 5 (+1) 1
--   &lt;5,4,3,2,1&gt;
--   </pre>
iterate :: (Num t, Ord t) => t -> (a -> a) -> a -> Vector a

-- | Instance of <a>first</a>
--   
--   <pre>
--   &gt;&gt;&gt; S.first $ vector [1,2,3,4,5]
--   1
--   </pre>
first :: Vector a -> a

-- | Instance of <a>last</a>
--   
--   <pre>
--   &gt;&gt;&gt; S.last $ vector [1,2,3,4,5]
--   5
--   </pre>
last :: Vector a -> a

-- | creates a vector of all the initial segments in a vector.
--   
--   <pre>
--   &gt;&gt;&gt; inits $ vector [1,2,3,4,5]
--   &lt;&lt;1&gt;,&lt;1,2&gt;,&lt;1,2,3&gt;,&lt;1,2,3,4&gt;,&lt;1,2,3,4,5&gt;&gt;
--   </pre>
--   
--   
inits :: () => Vector a -> Vector Vector a

-- | creates a vector of all the final segments in a vector.
--   
--   <pre>
--   &gt;&gt;&gt; tails $ vector [1,2,3,4,5]
--   &lt;&lt;1,2,3,4,5&gt;,&lt;2,3,4,5&gt;,&lt;3,4,5&gt;,&lt;4,5&gt;,&lt;5&gt;&gt;
--   </pre>
--   
--   
tails :: () => Vector a -> Vector Vector a

-- | Returns the initial segment of a vector.
--   
--   <pre>
--   &gt;&gt;&gt; init $ vector [1,2,3,4,5]
--   &lt;1,2,3,4&gt;
--   </pre>
--   
init :: () => Vector a -> Vector a

-- | Returns the tail of a vector.
--   
--   <pre>
--   &gt;&gt;&gt; tail $ vector [1,2,3,4,5]
--   &lt;2,3,4,5&gt;
--   </pre>
--   
tail :: () => Vector a -> Vector a

-- | concatenates a vector of vectors.
--   
--   <pre>
--   &gt;&gt;&gt; concat $ vector [vector[1,2,3,4], vector[5,6,7]]
--   &lt;1,2,3,4,5,6,7&gt;
--   </pre>
--   
concat :: () => Vector Vector a -> Vector a

-- | reverses the elements in a vector.
--   
--   <pre>
--   &gt;&gt;&gt; reverse $ vector [1,2,3,4,5]
--   &lt;5,4,3,2,1&gt;
--   </pre>
--   
--   
reverse :: () => Vector a -> Vector a

-- | groups a vector into sub-vectors of <i>n</i> elements.
--   
--   <pre>
--   &gt;&gt;&gt; group 3 $ vector [1,2,3,4,5,6,7,8]
--   &lt;&lt;1,2,3&gt;,&lt;4,5,6&gt;,&lt;7,8&gt;&gt;
--   </pre>
--   
--   
group :: () => Integer -> Vector a -> Vector Vector a

-- | right-shifts a vector with an element.
--   
--   <pre>
--   &gt;&gt;&gt; vector [1,2,3,4] `shiftr` 8
--   &lt;8,1,2,3&gt;
--   </pre>
--   
shiftr :: () => Vector a -> a -> Vector a

-- | left-shifts a vector with an element.
--   
--   <pre>
--   &gt;&gt;&gt; vector [1,2,3,4] `shiftl` 8
--   &lt;2,3,4,8&gt;
--   </pre>
--   
shiftl :: () => Vector a -> a -> Vector a

-- | rotates a vector to the right.
--   
--   <pre>
--   &gt;&gt;&gt; rotr $ vector [1,2,3,4]
--   &lt;4,1,2,3&gt;
--   </pre>
--   
rotr :: () => Vector a -> Vector a

-- | rotates a vector to the left.
--   
--   <pre>
--   &gt;&gt;&gt; rotl $ vector [1,2,3,4]
--   &lt;2,3,4,1&gt;
--   </pre>
--   
rotl :: () => Vector a -> Vector a

-- | takes the first <i>n</i> elements of a vector.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ vector [1,2,3,4,5,6,7,8,9]
--   &lt;1,2,3,4,5&gt;
--   </pre>
--   
take :: () => Integer -> Vector a -> Vector a

-- | drops the first <i>n</i> elements of a vector.
--   
--   <pre>
--   &gt;&gt;&gt; drop 5 $ vector [1,2,3,4,5,6,7,8,9]
--   &lt;6,7,8,9&gt;
--   </pre>
--   
drop :: () => Integer -> Vector a -> Vector a

-- | takes the first elements in a vector until the first element that does
--   not fulfill a predicate.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt;5) $ vector [1,2,3,4,5,6,7,8,9]
--   &lt;1,2,3,4&gt;
--   </pre>
--   
takeWhile :: () => (a -> Bool) -> Vector a -> Vector a

-- | returns a vector containing only the elements of another vector whose
--   index satisfies a predicate.
--   
--   <pre>
--   &gt;&gt;&gt; filterIdx (\x -&gt; x `mod` 3 == 0) $ vector [0,1,2,3,4,5,6,7,8,9]
--   &lt;2,5,8&gt;
--   </pre>
--   
--   
filterIdx :: () => (Integer -> Bool) -> Vector a -> Vector a

odds :: () => Vector a -> Vector a

evens :: () => Vector a -> Vector a

-- | does a stride-selection on a vector.
--   
--   <pre>
--   &gt;&gt;&gt; stride 1 3 $ vector [1,2,3,4,5,6,7,8,9]
--   &lt;1,4,7&gt;
--   </pre>
--   
--   
stride :: Integer -> Integer -> Vector a -> Vector a

-- | returns the <i>n</i>-th element in a vector, or <tt>Nothing</tt> if
--   <i>n &gt; l</i>.
--   
--   <pre>
--   &gt;&gt;&gt; get 3 $ vector [1,2,3,4,5]
--   Just 3
--   </pre>
--   
get :: () => Integer -> Vector a -> Maybe a

-- | the same as <a>get</a> but with flipped arguments.
(<@) :: () => Vector a -> Integer -> Maybe a

-- | unsafe version of <a>&lt;@&gt;</a>. Throws an exception if <i>n &gt;
--   l</i>.
(<@!) :: () => Vector p -> Integer -> p

-- | selects the elements in a vector at the incexes contained by another
--   vector.
--   
--   The following versions of this skeleton are available, the number
--   suggesting how many nested vectors it is operating upon:
--   <tt>gather[1-5]</tt>
--   
--   <pre>
--   &gt;&gt;&gt; let ix = vector [vector [1,3,4], vector [3,5,1], vector [5,8,9]]
--   
--   &gt;&gt;&gt; let v = vector [11,12,13,14,15]
--   
--   &gt;&gt;&gt; gather2 ix v
--   &lt;&lt;Just 11,Just 13,Just 14&gt;,&lt;Just 13,Just 15,Just 11&gt;,&lt;Just 15,Nothing,Nothing&gt;&gt;
--   </pre>
--   
--   
gather1 :: Vector Integer -> Vector a -> Vector (Maybe a)

-- | the same as <a>gather1</a> but with flipped arguments
--   
--   The following versions of this skeleton are available, the number
--   suggesting how many nested vectors it is operating upon.
--   
--   <pre>
--   (&lt;@&gt;), (&lt;&lt;@&gt;&gt;), (&lt;&lt;&lt;@&gt;&gt;&gt;), (&lt;&lt;&lt;&lt;@&gt;&gt;&gt;&gt;), (&lt;&lt;&lt;&lt;&lt;@&gt;&gt;&gt;&gt;&gt;),
--   </pre>
(<@>) :: Vector a -> Vector Integer -> Vector (Maybe a)

-- | replaces the <i>n</i>-th element in a vector with another.
--   
--   <pre>
--   &gt;&gt;&gt; replace 5 15 $ vector [1,2,3,4,5,6,7,8,9]
--   &lt;1,2,3,4,15,6,7,8,9&gt;
--   </pre>
--   
--   
replace :: () => Integer -> p -> Vector p -> Vector p

-- | scatters the elements in a vector based on the indexes contained by
--   another vector.
--   
--   <pre>
--   &gt;&gt;&gt; scatter (vector [2,4,5]) (vector [0,0,0,0,0,0,0,0]) (vector [1,1,1])
--   &lt;0,1,0,1,1,0,0,0&gt;
--   </pre>
--   
--   
scatter :: () => Vector Integer -> Vector p -> Vector p -> Vector p

-- | performs a bit-reverse permutation.
--   
--   
--   <pre>
--   &gt;&gt;&gt; bitrev $ vector ["000","001","010","011","100","101","110","111"]
--   &lt;"111","011","101","001","110","010","100","000"&gt;
--   </pre>
bitrev :: () => Vector a -> Vector a

-- | splits a vector in two equal parts.
--   
--   <pre>
--   &gt;&gt;&gt; duals $ vector [1,2,3,4,5,6,7]
--   (&lt;1,2,3&gt;,&lt;4,5,6&gt;)
--   </pre>
duals :: () => Vector b2 -> (Vector b2, Vector b2)

-- | concatenates a previously split vector. See also <a>duals</a>
unduals :: () => Vector a -> Vector a -> Vector a

-- | <a>zipx</a> is a template skeleton for "zipping" a vector of signals.
--   It synchronizes all signals (of the same MoC) in a vector and outputs
--   one signal with vectors of the synced values. For each signal in the
--   input vector it requires a function which <i>translates</i> a
--   partition of events (see <a>ForSyDe.Atom.MoC</a>) into sub-vectors.
--   
--   There exist helper intances of the <a>zipx</a> skeleton interface for
--   all supported MoCs.
--   
zipx :: MoC e => Vector ((Vector a -> Vector a -> Vector a) -> Fun e (Vector a) (Fun e (Vector a) (Ret e (Vector a)))) -> Vector (Stream (e a)) -> Stream (e (Vector a))

-- | <a>unzipx</a> is a template skeleton to unzip a signal carrying
--   vectors into a vector of multiple signals. It required a function that
--   <i>splits</i> a vector of values into a vector of event partitions
--   belonging to output signals. Unlike <a>zipx</a>, it also requires the
--   number of output signals. The reason for this is that it is impossible
--   to determine the length of the output vector without "sniffing" the
--   content of the input events, which is out of the scope of skeletons
--   and may lead to unsafe behavior. The length of the output vector is
--   needed in order to avoid infinite recurrence.
--   
--   There exist helper intances of the <a>unzipx</a> skeleton interface
--   for all supported MoCs.
--   
unzipx :: (MoC e) => (Vector a -> Vector (Ret e a)) -> Integer -> Stream (e (Vector a)) -> Vector (Stream (e a))


-- | The <tt>SDF</tt> library implements the atoms holding the sematics for
--   the synchronous data flow computation model. It also provides a set of
--   helpers for properly instantiating process network patterns as process
--   constructors.
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.MoC.SDF

-- | The CT type, identifying a discrete time event and implementing an
--   instance of the <a>MoC</a> class. A discrete event explicitates its
--   tag which is represented as an integer.
newtype SDF a
SDF :: a -> SDF a
[val] :: SDF a -> a

-- | Type synonym for a SY signal, i.e. "a signal of SY events"
type Signal a = Stream (SDF a)

-- | Type synonym for consumption rate
type Prod = Int

-- | Type synonym for production rate
type Cons = Int

-- | Transforms a list of values into a SDF signal with only one partition,
--   i.e. all events share the same (initial) tag.
signal :: [a] -> Signal a

-- | Reads a signal from a string. Like with the <tt>read</tt> function
--   from <tt>Prelude</tt>, you must specify the tipe of the signal.
--   
--   <pre>
--   &gt;&gt;&gt; readSignal "{1,2,3,4,5}" :: Signal Int
--   {1,2,3,4,5}
--   </pre>
readSignal :: Read a => String -> Signal a

-- | The <tt>delay</tt> process "delays" a signal with initial events built
--   from a list. It is an instantiation of the <a>delay</a> constructor.
--   
--   <pre>
--   &gt;&gt;&gt; let s = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; delay [0,0,0] s
--   {0,0,0,1,2,3,4,5}
--   </pre>
--   
delay :: [a] -> Signal a -> Signal a

-- | Similar to the previous, but this is the raw instantiation of the
--   <a>delay</a> pattern. It appends the contents of one signal at the
--   head of another signal.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = signal [0,0,0]
--   
--   &gt;&gt;&gt; let s2 = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; delay' s1 s2
--   {0,0,0,1,2,3,4,5}
--   </pre>
--   
delay' :: Signal a -> Signal a -> Signal a

-- | <tt>comb</tt> processes map combinatorial functions on signals and
--   take care of synchronization between input signals. It instantiates
--   the <tt>comb</tt> atom pattern (see <a>comb22</a>).
--   
--   Constructors: <tt>comb[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = signal [1..]
--   
--   &gt;&gt;&gt; let s2 = signal [1,1,1,1,1,1,1]
--   
--   &gt;&gt;&gt; let f [a,b,c] [d,e] = [a+d, c+e]
--   
--   &gt;&gt;&gt; comb21 ((3,2),2,f) s1 s2
--   {2,4,5,7,8,10}
--   </pre>
--   
--   Incorrect usage (not covered by <tt>doctest</tt>):
--   
--   <pre>
--   λ&gt; comb21 ((3,2),3,f) s1 s2
--   *** Exception: [MoC.SDF] Wrong production
--   </pre>
--   
comb22 :: ((Cons, Cons), (Prod, Prod), [a1] -> [a2] -> ([b1], [b2])) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>reconfig</tt> creates an SDF adaptive process where the first
--   signal carries functions and the other carry the arguments. It
--   instantiates the <tt>reconfig</tt> atom pattern (see
--   <a>reconfig22</a>). According to our SDF definition, the production
--   and consumption rates need to be fixed, so they are passed as
--   parameters to the constructor, whereas the first signal carries
--   adaptive functions only. For the adaptive signal it only makes sense
--   that the consumption rate is always 1.
--   
--   Constructors: <tt>reconfig[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let f1 a = [sum a]
--   
--   &gt;&gt;&gt; let f2 a = [maximum a]
--   
--   &gt;&gt;&gt; let sf = signal [f1,f2,f1,f2,f1,f2,f1]
--   
--   &gt;&gt;&gt; let s1 = signal [1..]
--   
--   &gt;&gt;&gt; reconfig11 (4,1) sf s1
--   {10,8,42,16,74,24,106}
--   </pre>
--   
reconfig22 :: ((Cons, Cons), (Prod, Prod)) -> Signal ([a1] -> [a2] -> ([b1], [b2])) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | A signal generator which repeats the initial tokens indefinitely. It
--   is actually an instantiation of the <tt>stated0X</tt> constructor
--   (check <a>stated22</a>).
--   
--   Constructors: <tt>constant[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let (s1, s2) = constant2 ([1,2,3],[2,1])
--   
--   &gt;&gt;&gt; takeS 7 s1
--   {1,2,3,1,2,3,1}
--   
--   &gt;&gt;&gt; takeS 5 s2
--   {2,1,2,1,2}
--   </pre>
--   
constant2 :: ([b1], [b2]) -> (Signal b1, Signal b2)

-- | A signal generator based on a function and a kernel value. It is
--   actually an instantiation of the <tt>stated0X</tt> constructor (check
--   <a>stated22</a>).
--   
--   Constructors: <tt>generate[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let f a b = ([sum a, sum a],[sum b, sum b, sum b])
--   
--   &gt;&gt;&gt; let (s1,s2) = generate2 ((2,3),(2,3),f) ([1,1],[2,2,2])
--   
--   &gt;&gt;&gt; takeS 7 s1
--   {1,1,2,2,4,4,8}
--   
--   &gt;&gt;&gt; takeS 8 s2
--   {2,2,2,6,6,6,18,18}
--   </pre>
--   
generate2 :: ((Cons, Cons), (Prod, Prod), [b1] -> [b2] -> ([b1], [b2])) -> ([b1], [b2]) -> (Signal b1, Signal b2)

-- | <tt>stated</tt> is a state machine without an output decoder. It is an
--   instantiation of the <tt>state</tt> MoC constructor (see
--   <a>stated22</a>).
--   
--   Constructors: <tt>stated[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let f [a] [b,c] = [a+b+c]
--   
--   &gt;&gt;&gt; let s = signal [1,2,3,4,5,6,7]
--   
--   &gt;&gt;&gt; stated11 ((1,2),1,f) [1] s
--   {1,4,11,22}
--   </pre>
--   
stated22 :: ((Cons, Cons, Cons, Cons), (Prod, Prod), [b1] -> [b2] -> [a1] -> [a2] -> ([b1], [b2])) -> ([b1], [b2]) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>state</tt> is a state machine without an output decoder. It is an
--   instantiation of the <tt>stated</tt> MoC constructor (see
--   <a>state22</a>).
--   
--   Constructors: <tt>state[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let f [a] [b,c] = [a+b+c]
--   
--   &gt;&gt;&gt; let s = signal [1,2,3,4,5,6,7]
--   
--   &gt;&gt;&gt; state11 ((1,2),1,f) [1] s
--   {4,11,22}
--   </pre>
--   
state22 :: ((Cons, Cons, Cons, Cons), (Prod, Prod), [b1] -> [b2] -> [a1] -> [a2] -> ([b1], [b2])) -> ([b1], [b2]) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>moore</tt> processes model Moore state machines. It is an
--   instantiation of the <tt>moore</tt> MoC constructor (see
--   <a>moore22</a>).
--   
--   Constructors: <tt>moore[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let ns [a] [b,c] = [a+b+c]
--   
--   &gt;&gt;&gt; let od [a]       = [a+1,a*2]
--   
--   &gt;&gt;&gt; let s = signal [1,2,3,4,5,6,7]
--   
--   &gt;&gt;&gt; moore11 ((1,2),1,ns) (1,2,od) [1] s
--   {2,2,5,8,12,22,23,44}
--   </pre>
--   
moore22 :: ((Cons, Cons, Cons), Prod, [st] -> [a1] -> [a2] -> [st]) -> (Cons, (Prod, Prod), [st] -> ([b1], [b2])) -> [st] -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>mealy</tt> processes model Mealy state machines. It is an
--   instantiation of the <tt>mealy</tt> MoC constructor (see
--   <a>mealy22</a>).
--   
--   Constructors: <tt>mealy[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let ns [a] [b,c] = [a+b+c]
--   
--   &gt;&gt;&gt; let od [a] [b]   = [a+b,a*b]
--   
--   &gt;&gt;&gt; let s = signal [1,2,3,4,5,6,7]
--   
--   &gt;&gt;&gt; mealy11 ((1,2),1,ns) ((1,1),2,od) [1] s
--   {2,1,6,8,14,33,26,88}
--   </pre>
--   
mealy22 :: ((Cons, Cons, Cons), Prod, [st] -> [a1] -> [a2] -> [st]) -> ((Cons, Cons, Cons), (Prod, Prod), [st] -> [a1] -> [a2] -> ([b1], [b2])) -> [st] -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | Transforms a (set of) <a>SDF</a> signal(s) into the equivalent
--   <a>SY</a> signal(s). The only change is the event consructor. The
--   partial order of DE is interpreted as SY's total order, based on the
--   positioning of events in the signals (e.g. FIFO buffers) at that
--   moment.
--   
--   Constructors: <tt>toSY[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = SDF.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; toSY s
--   {1,2,3,4,5}
--   </pre>
--   
toSY2 :: Signal a -> Signal b -> (Signal a, Signal b)

-- | Consumes tokens from a vector of signals and merges them into a signal
--   of vectors, with a production rate of 1. It instantiates the
--   <a>zipx</a> skeleton.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = SDF.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let s2 = SDF.signal [11,12,13,14,15]
--   
--   &gt;&gt;&gt; let v1 = V.vector [s1,s1,s2,s2]
--   
--   &gt;&gt;&gt; let r  = V.vector [2,1,2,1]
--   
--   &gt;&gt;&gt; v1
--   &lt;{1,2,3,4,5},{1,2,3,4,5},{11,12,13,14,15},{11,12,13,14,15}&gt;
--   
--   &gt;&gt;&gt; zipx r v1
--   {&lt;1,2,1,11,12,11&gt;,&lt;3,4,2,13,14,12&gt;}
--   </pre>
--   
zipx :: Vector Cons -> Vector (Signal a) -> Signal (Vector a)

-- | Consumes the vectors carried by a signal with a rate of 1, and unzips
--   them into a vector of signals based on the user provided rates. It
--   instantiates the <a>unzipx</a> skeleton.
--   
--   <b>OBS:</b> due to the <a>recur</a> pattern contained by
--   <a>unzipx</a>, the vector of production rates needs to be provided in
--   reverse order (see <a>ForSyDe.Atom.Skeleton.Vector</a>).
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = SDF.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let s2 = SDF.signal [11,12,13,14,15]
--   
--   &gt;&gt;&gt; let v1 = V.vector [s1,s1,s2,s2]
--   
--   &gt;&gt;&gt; let r  = V.vector [2,1,2,1]
--   
--   &gt;&gt;&gt; let sz = zipx r v1
--   
--   &gt;&gt;&gt; v1
--   &lt;{1,2,3,4,5},{1,2,3,4,5},{11,12,13,14,15},{11,12,13,14,15}&gt;
--   
--   &gt;&gt;&gt; sz
--   {&lt;1,2,1,11,12,11&gt;,&lt;3,4,2,13,14,12&gt;}
--   
--   &gt;&gt;&gt; unzipx (V.reverse r) sz
--   &lt;{1,2,3,4},{1,2},{11,12,13,14},{11,12}&gt;
--   </pre>
--   
unzipx :: Vector Prod -> Signal (Vector a) -> Vector (Signal a)


-- | This module exports the core entities of the extended behavior layer:
--   interfaces for atoms and common patterns of atoms. It does <i>NOT</i>
--   export any implementation or instantiation of any specific behavior
--   extension type.
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.ExB

-- | Class which defines the atoms for the extended behavior layer.
--   
--   As its name suggests, this layer is extending the behavior of
--   processes (or merely of functions if we ignore timing semantics
--   completely), by expanding the domains of the wrapped layer (e.g. the
--   set of values) with symbols having clearly-defined semantics (e.g.
--   special events with known responses).
--   
--   The types associated with this layer can simply be describes as:
--   
--   
--   where <i>α</i> is a base type and <i>b</i> is the type extension, i.e.
--   a set of symbols with clearly-defined semantics.
--   
--   Extended behavior atoms are functions of these types, defined as
--   interfaces in the <a>ExB</a> type class.
class Functor b => ExB b

-- | Extends a value (from a layer below) with a set of symbols with known
--   semantics, as described by a type instantiating this class.
extend :: ExB b => a -> b a

-- | Basic functor operator. Lifts a function (from a layer below) into the
--   domain of the extended behavior layer.
--   
(/.\) :: ExB b => (a -> a') -> b a -> b a'

-- | Applicative operator. Defines a res between two extended behavior
--   symbols.
--   
(/*\) :: ExB b => b (a -> a') -> b a -> b a'

-- | Predicate operator. Generates a defined behavior based on an extended
--   Boolean predicate.
--   
(/&\) :: ExB b => b Bool -> b a -> b a

-- | Degrade operator. Degrades a behavior-extended value into a
--   non-extended one (from a layer below), based on a kernel value. Used
--   also to throw exceptions.
--   
(/!\) :: ExB b => a -> b a -> a

-- | 
--   The <tt>res</tt> behavior pattern lifts a function on values to the
--   extended behavior domain, and applies a resolution between two
--   extended behavior symbols.
--   
--   Constructors: <tt>res[1-8][1-4]</tt>.
res22 :: ExB b => (a1 -> a2 -> (a1', a2')) -> b a1 -> b a2 -> (b a1', b a2')

-- | Prefix name for the prefix operator <a>/&amp;\</a>.
filter :: ExB b => b Bool -> b a -> b a

-- | Same as <a>filter</a> but takes base (non-extended) values as input
--   arguments.
filter' :: ExB b => Bool -> a -> b a

-- | Prefix name for the degrade operator <a>/!\</a>.
degrade :: ExB b => a -> b a -> a

-- | 
--   The <tt>ignoreXY</tt> pattern takes a function of <tt>Y + X</tt>
--   arguments, <tt>Y</tt> basic inputs followed by <tt>X</tt>
--   behavior-extended inputs. The <tt>X</tt> behavior-extended arguments
--   are subjugated to a res, and the result is then degraded using the
--   first <tt>Y</tt> arguments as fallback. The effect is similar to
--   "ignoring" a the result of a res function if ∈ <i>b</i>.
--   
--   The main application of this pattern is as extended behavior wrapper
--   for state machine functions which do not "understand" extended
--   behavior semantics, i.e. it simply propagates the current state (∈
--   <i>α</i>) if the inputs (their res) belongs to the set of extended
--   values (∈ <i>b</i>).
--   
--   Constructors: <tt>ignore[1-4][1-4]</tt>.
ignore22 :: ExB b => (a1 -> a2 -> a1' -> a2' -> (a1, a2)) -> a1 -> a2 -> b a1' -> b a2' -> (a1, a2)


-- | This module implements the constructors and assocuated utilities of a
--   type which extends the behavior of a function to express "absent
--   events" (see <a>[Halbwachs91]</a>).
--   
--   The <a>AbstExt</a> type can be used directly with the atom patterns
--   defined in <a>ForSyDe.Atom.ExB</a>, and no helpers or utilities are
--   needed. Example usage:
--   
--   <pre>
--   &gt;&gt;&gt; res21 (+) (Prst 1) (Prst 2)
--   3
--   
--   &gt;&gt;&gt; res21 (+) Abst     Abst
--   ⟂
--   
--   &gt;&gt;&gt; filter Abst         (Prst 1)
--   ⟂
--   
--   &gt;&gt;&gt; filter (Prst False) (Prst 1)
--   ⟂
--   
--   &gt;&gt;&gt; filter (Prst True)  (Prst 1)
--   1
--   
--   &gt;&gt;&gt; filter' False 1 :: AbstExt Int
--   ⟂
--   
--   &gt;&gt;&gt; filter' True  1 :: AbstExt Int
--   1
--   
--   &gt;&gt;&gt; degrade 0 (Prst 1)
--   1
--   
--   &gt;&gt;&gt; degrade 0 Abst
--   0
--   
--   &gt;&gt;&gt; ignore11 (+) 1 (Prst 1)
--   2
--   
--   &gt;&gt;&gt; ignore11 (+) 1 Abst
--   1
--   </pre>
--   
--   Incorrect usage (not covered by <tt>doctest</tt>):
--   
--   <pre>
--   λ&gt; res21 (+) (Prst 1) Abst 
--   *** Exception: [ExB.Absent] Illegal occurrence of an absent and present event
--   </pre>
module ForSyDe.Atom.ExB.Absent

-- | The <a>AbstExt</a> type extends the base type with the '⊥' symbol
--   denoting the absence of a value/event (see <a>[Halbwachs91]</a>).
data AbstExt a

-- | ⊥ denotes the absence of a value
Abst :: AbstExt a

-- | ⊤ a present event with a value
Prst :: a -> AbstExt a

-- | Implements the absent semantics of the extended behavior atoms.

-- | Shows <a>Abst</a> as '⊥', while a present event is represented with
--   its value.

-- | Reads the '_' character to an <a>Abst</a> and a normal value to
--   <a>Prst</a>-wrapped one.

-- | <a>Functor</a> instance. Bypasses the special values and maps a
--   function to the wrapped value. Provides the <tt>(&lt;$&gt;)</tt>
--   operator.

-- | <a>Applicative</a> instance. Check source code for the lifting rules.
--   Provides the <tt>(&lt;*&gt;)</tt> operator
instance GHC.Classes.Eq a => GHC.Classes.Eq (ForSyDe.Atom.ExB.Absent.AbstExt a)
instance ForSyDe.Atom.ExB.ExB ForSyDe.Atom.ExB.Absent.AbstExt
instance GHC.Show.Show a => GHC.Show.Show (ForSyDe.Atom.ExB.Absent.AbstExt a)
instance GHC.Read.Read a => GHC.Read.Read (ForSyDe.Atom.ExB.Absent.AbstExt a)
instance GHC.Base.Functor ForSyDe.Atom.ExB.Absent.AbstExt
instance GHC.Base.Applicative ForSyDe.Atom.ExB.Absent.AbstExt


-- | This module imports plotting and data dumping functions working with
--   "plottable" data types, i.e. instances of the <a>Plot</a> and
--   <a>Plottable</a> type classes.
module ForSyDe.Atom.Utility.Plot

-- | Record structure containing configuration settings for the plotting
--   commands.
data Config
Cfg :: Bool -> String -> String -> Float -> Float -> [String] -> Bool -> Bool -> Config

-- | verbose printouts on terminal
[verbose] :: Config -> Bool

-- | directory where all dumped files will be found
[path] :: Config -> String

-- | base name for dumped files
[title] :: Config -> String

-- | sample rate if relevant. Useful for explicit-tagged signals, ignored
--   otherwise.
[rate] :: Config -> Float

-- | Maximum X coordinate. Mandatory for infinite structures, optional
--   otherwise.
[xmax] :: Config -> Float

-- | list of labels with the names of the structures plotted
[labels] :: Config -> [String]

-- | if relevant, fires a plotting or compiling program.
[fire] :: Config -> Bool

-- | if relevant, dumps additional scripts and plots.
[other] :: Config -> Bool

-- | Default configuration: verbose, dump everything possible, fire
--   whatever program needed. Check source for settings.
--   
--   Example usage:
--   
--   <pre>
--   &gt;&gt;&gt; defaultCfg {xmax = 15, verbose = False, labels = ["john","doe"]}
--   Cfg {verbose = False, path = "./fig", title = "plot", rate = 1.0e-2, xmax = 15.0, labels = ["john","doe"], fire = True, other = True}
--   </pre>
defaultCfg :: Config

-- | Silent configuration: does not fire any program or print our
--   unnecessary info. Check source for settings.
silentCfg :: Config

-- | Clean configuration: verbose, does not dump more than necessary, fire
--   whatever program needed. Check source for settings.
noJunkCfg :: Config

-- | Prepares a single plottable data structure to be dumped and/or
--   plotted.
prepare :: (Plot a) => Config -> a -> PlotData

-- | Prepares a list of plottable data structures to be dumped and/or
--   plotted. See <a>prepare</a>.
prepareL :: (Plot a) => Config -> [a] -> PlotData

-- | Prepares a vector of plottable data structures to be dumped and/or
--   plotted. See <a>prepare</a>.
prepareV :: (Plot a) => Config -> Vector a -> PlotData

-- | Prints out the sampled contents of a <a>prepare</a>d data set.
showDat :: PlotData -> IO ()

-- | Dumps the sampled contents of a <a>prepare</a>d data set into separate
--   <tt>.dat</tt> files.
dumpDat :: PlotData -> IO [String]

-- | Generates a GNUplot script and <tt>.dat</tt> files for plotting the
--   sampled contents of a <a>prepare</a>d data set. Depending on the
--   configuration settings, it also dumps LaTeX and PDF plots, and fires
--   the script.
--   
--   <b>OBS:</b> needless to say that <a>GNUplot</a> needs to be installed
--   in order to use this command. Also, in order to fire GNUplot from a
--   ghci session you might need to install <tt>gnuplot-x11</tt>.
plotGnu :: PlotData -> IO ()

-- | Similar to <a>plotGnu</a> but creates a heatmap plot using the GNUplot
--   engine. For this, the input needs to contain at least two columns of
--   data, otherwise the plot does not show anything, i.e. the samples need
--   to be lists or vectors of two or more elements.
--   
--   <b>OBS:</b> same dependencies are needed as for <a>plotGnu</a>.
heatmapGnu :: PlotData -> IO ()

-- | Prints out a LaTeX environment from a <a>prepare</a>d data set. This
--   environment should be paste inside a <tt>tikzpicture</tt> in a
--   document title which imports the ForSyDe-LaTeX package.
showLatex :: PlotData -> IO ()

-- | Dumps a set of formatted data files with the extension <tt>.flx</tt>
--   that can be imported by a LaTeX document which uses the ForSyDe-LaTeX
--   package.
dumpLatex :: PlotData -> IO [String]

-- | Creates a standalone LaTeX document which uses the ForSyDe-LaTeX
--   package, plotting a <a>prepare</a>d data set. Depending on the
--   configuration settings, the command <tt>pdflatex</tt> may also be
--   invoked to compile a pdf image.
--   
--   <b>OBS:</b> A LaTeX compiler is required to run the <tt>pdflatex</tt>
--   command. The <a>ForSyDe-LaTeX</a> package also needs to be installed
--   according to the instructions on the project web page.
plotLatex :: PlotData -> IO ()

-- | This class gathers types which can be sampled and converted to a
--   numerical string which can be read and interpreted by a plotter
--   engine.
class Plottable a

-- | Transforms the input type into a coordinate string.
toCoord :: Plottable a => a -> String

-- | This class gathers all ForSyDe-Atom structures that can be plotted.
class Plot a

-- | Samples the data according to a given step size.
sample :: Plot a => Float -> a -> Samples

-- | Samples the data according to the internal structure.
sample' :: Plot a => a -> Samples

-- | Takes the first samples until a given tag.
takeUntil :: Plot a => Float -> a -> a

-- | Returns static information about the data type.
getInfo :: Plot a => a -> PInfo

-- | Static information of each plottable data type.
data PInfo
Info :: String -> String -> String -> String -> Bool -> Bool -> PInfo

-- | id used usually in implicit tags
[typeid] :: PInfo -> String

-- | LaTeX identifier
[command] :: PInfo -> String

-- | unit of measure
[measure] :: PInfo -> String

-- | style tweaking in the GNUplot script
[style] :: PInfo -> String

-- | if the plot is stacking
[stacking] :: PInfo -> Bool

-- | if the sampled data is sparse instead of dense
[sparse] :: PInfo -> Bool

-- | Alias for sampled data
type Samples = [(String, String)]

-- | Alias for a data set <a>prepare</a>d to be plotted.
type PlotData = (Config, PInfo, [(String, Samples)])
instance GHC.Show.Show ForSyDe.Atom.Utility.Plot.PInfo
instance GHC.Show.Show ForSyDe.Atom.Utility.Plot.Config
instance ForSyDe.Atom.Utility.Plot.Plottable ForSyDe.Atom.MoC.TimeStamp.TimeStamp
instance (GHC.Show.Show a, ForSyDe.Atom.Utility.Plot.Plottable a) => ForSyDe.Atom.Utility.Plot.Plottable (ForSyDe.Atom.ExB.Absent.AbstExt a)
instance ForSyDe.Atom.Utility.Plot.Plottable a => ForSyDe.Atom.Utility.Plot.Plottable (ForSyDe.Atom.Skeleton.Vector.Core.Vector a)
instance (GHC.Show.Show a, GHC.Real.Real a) => ForSyDe.Atom.Utility.Plot.Plottable a
instance ForSyDe.Atom.Utility.Plot.Plottable a => ForSyDe.Atom.Utility.Plot.Plot (ForSyDe.Atom.MoC.SDF.Core.Signal a)
instance ForSyDe.Atom.Utility.Plot.Plottable a => ForSyDe.Atom.Utility.Plot.Plot (ForSyDe.Atom.MoC.SY.Core.Signal a)
instance ForSyDe.Atom.Utility.Plot.Plottable a => ForSyDe.Atom.Utility.Plot.Plot (ForSyDe.Atom.MoC.DE.Core.Signal a)
instance ForSyDe.Atom.Utility.Plot.Plottable a => ForSyDe.Atom.Utility.Plot.Plot (ForSyDe.Atom.MoC.CT.Core.Signal a)
instance ForSyDe.Atom.Utility.Plot.Plottable a => ForSyDe.Atom.Utility.Plot.Plot (ForSyDe.Atom.Skeleton.Vector.Core.Vector a)


-- | The <tt>CT</tt> library implements the atoms holding the sematics for
--   the continuous time computation model. It also provides a set of
--   helpers for properly instantiating process network patterns as process
--   constructors.
--   
--   For working with time or timestamps please check the utilities
--   provided by the <a>ForSyDe.Atom.MoC.Time</a> and
--   <a>ForSyDe.Atom.MoC.TimeStamp</a> modules.
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.MoC.CT

-- | Alias for the type representing discrete time. It is inherently
--   quantizable, the quantum being a picosecond (10⁻¹² seconds), thus it
--   can be considered order-isomorphic with a set of integers, i.e.
--   between any two timestamps there is a finite number of timestamps.
--   Moreover, a timestamp can be easily translated into a rational number
--   representing fractions of a second, so the conversion between
--   timestamps (discrete time) and rationals (analog/continuous time) is
--   straightforward.
--   
--   This type is used in the explicit tags of the <a>DE</a> MoC (and
--   subsequently the discrete event evaluation engine for simulating the
--   <a>CT</a> MoC).
type TimeStamp = DiffTime

-- | Type alias for the type to represent metric (continuous) time.
--   Underneath we use <a>Rational</a> that is able to represent any
--   <i>t</i> between <i>t₁</i> &lt; <i>t₂</i> ∈ <i>T</i>.
type Time = Rational

-- | The CT type, identifying a continuous time event and implementing an
--   instance of the <a>MoC</a> class.
data CT a
CT :: TimeStamp -> Time -> (Time -> a) -> CT a

-- | start time of event
[tag] :: CT a -> TimeStamp

-- | phase. Models function delays
[phase] :: CT a -> Time

-- | function of time
[func] :: CT a -> Time -> a

-- | Type synonym for a CT signal, i.e. "a signal of CT events"
type Signal a = Stream (CT a)

-- | Wraps a (tuple of) pair(s) <tt>(time, function)</tt> into the
--   equivalent unit signal(s), i.e. signal(s) with one event with the
--   period <tt>time</tt> carrying <tt>function</tt>.
--   
--   Helpers: <tt>unit</tt> and <tt>unit[2-4]</tt>.
unit2 :: () => ((TimeStamp, Time -> a1), (TimeStamp, Time -> a2)) -> (Signal a1, Signal a2)

-- | Creates an infinite signal.
infinite :: (Time -> a) -> Signal a

-- | Transforms a list of tuples such as the ones taken by <tt>event</tt>
--   into a CT signal
signal :: [(TimeStamp, Time -> a)] -> Signal a

-- | Checks if a signal is well-formed or not, according to the CT MoC
--   interpretation in <tt>ForSyDe-Atom</tt>.
checkSignal :: () => Stream CT a -> Stream CT a

-- | The <tt>delay</tt> process "delays" a signal with one event.
--   Instantiates the <a>delay</a> pattern. In the CT MoC, this process can
--   be interpreted as an ideal "delay line".
--   
--   <pre>
--   &gt;&gt;&gt; let s  = infinite (sin')
--   
--   &gt;&gt;&gt; let s' = delay 2 (\_ -&gt; 0) s
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["delay"]} $ s'
--   Dumped delay in ./fig
--   ["./fig/delay.dat"]
--   </pre>
--   
delay :: TimeStamp -> (Time -> a) -> Signal a -> Signal a

-- | Similar to the previous, but this is the raw instantiation of the
--   <a>delay</a> pattern. It "borrows" the first event from one signal and
--   appends it at the head of another signal.
--   
--   <pre>
--   &gt;&gt;&gt; let s  = infinite (sin')
--   
--   &gt;&gt;&gt; let s' = signal [(0, \_ -&gt; 0), (2, \_ -&gt; 1)]
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["delayp"]} $ delay' s' s
--   Dumped delayp in ./fig
--   ["./fig/delayp.dat"]
--   </pre>
--   
delay' :: Signal a -> Signal a -> Signal a

-- | <tt>comb</tt> processes map combinatorial functions on signals and
--   take care of synchronization between input signals. It instantiates
--   the <tt>comb</tt> pattern (see <a>comb22</a>).
--   
--   Constructors: <tt>comb[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = infinite (sin')
--   
--   &gt;&gt;&gt; let s2 = signal [(0,\_-&gt;0),(pi',\_-&gt;1),(2*pi',\_-&gt;0),(3*pi',\_-&gt;1)]
--   
--   &gt;&gt;&gt; let o1 = comb11 (+1) s2
--   
--   &gt;&gt;&gt; let (o2_1, o2_2) = comb22 (\a b-&gt; (a+b,a*b)) s1 s2
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["comb11"]} o1
--   Dumped comb11 in ./fig
--   ["./fig/comb11.dat"]
--   
--   &gt;&gt;&gt; dumpDat $ prepareL cfg {labels=["comb22-1","comb22-2"]} [o2_1, o2_2]
--   Dumped comb22-1, comb22-2 in ./fig
--   ["./fig/comb22-1.dat","./fig/comb22-2.dat"]
--   </pre>
--   
comb22 :: (a1 -> a2 -> (b1, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>reconfig</tt> creates a CT adaptive process where the first signal
--   carries functions and the other carry the arguments. It instantiates
--   the <tt>reconfig</tt> atom pattern (see <a>reconfig22</a>).
--   
--   Constructors: <tt>reconfig[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = infinite (sin')
--   
--   &gt;&gt;&gt; let sf = signal [(0,\_-&gt;(*0)),(pi',\_-&gt;(+1)),(2*pi',\_-&gt;(*0)),(3*pi',\_-&gt;(+1))]
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["reconfig"]} $ reconfig11 sf s1
--   Dumped reconfig in ./fig
--   ["./fig/reconfig.dat"]
--   </pre>
reconfig22 :: Signal (a1 -> a2 -> (b1, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | A generator for a constant signal. As compared with the
--   <a>constant2</a>, it just constructs an infinite signal with constant
--   value (i.e. a signal with one event starting from time 0).
--   
--   Constructors: <tt>constant[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["constant"]} $ constant1 2
--   Dumped constant in ./fig
--   ["./fig/constant.dat"]
--   </pre>
--   
constant2 :: (b1, b2) -> (Signal b1, Signal b2)

-- | A generator for an infinite signal. Similar to <a>constant2</a>.
--   
--   Constructors: <tt>infinite[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let (inf1, inf2) = infinite2 (sin', cos')
--   
--   &gt;&gt;&gt; dumpDat $ prepareL cfg {labels=["infinite2-1", "infinite2-2"]} [inf1, inf2]
--   Dumped infinite2-1, infinite2-2 in ./fig
--   ["./fig/infinite2-1.dat","./fig/infinite2-2.dat"]
--   </pre>
--   
infinite2 :: (Time -> b1, Time -> b2) -> (Signal b1, Signal b2)

-- | A signal generator based on a function and a kernel value. It is
--   actually an instantiation of the <tt>stated0X</tt> constructor (check
--   <a>stated22</a>).
--   
--   Constructors: <tt>generate[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let { osc 0 = 1 ; osc 1 = 0 }
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["generate"]} $ generate1 osc (pi', \_-&gt;0)
--   Dumped generate in ./fig
--   ["./fig/generate.dat"]
--   </pre>
--   
--   
--   Another example simulating an RC oscillator:
--   
--   <pre>
--   &gt;&gt;&gt; let vs = 2                                -- Vs : supply voltage
--   
--   &gt;&gt;&gt; let r  = 100                              -- R : resistance
--   
--   &gt;&gt;&gt; let c  = 0.0005                           -- C : capacitance
--   
--   &gt;&gt;&gt; let vc t = vs * (1 - exp' (-t / (r * c))) -- Vc(t) : voltage charging through capacitor
--   
--   &gt;&gt;&gt; let ns v = vs + (-1 * v)                  -- next state : charging / discharging
--   
--   &gt;&gt;&gt; let rcOsc = generate1 ns (milisec 500, vc)
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["rcosc"]} $ rcOsc
--   Dumped rcosc in ./fig
--   ["./fig/rcosc.dat"]
--   </pre>
--   
generate2 :: (b1 -> b2 -> (b1, b2)) -> ((TimeStamp, Time -> b1), (TimeStamp, Time -> b2)) -> (Signal b1, Signal b2)

-- | <tt>stated</tt> is a state machine without an output decoder. It is an
--   instantiation of the <tt>state</tt> MoC constructor (see
--   <a>stated22</a>).
--   
--   Constructors: <tt>stated[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let { osc 0 a = a; osc _ a = 0 }
--   
--   &gt;&gt;&gt; let s1 = signal [(0,\_-&gt;1), (6,\_-&gt;0)]
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["stated"]} $ stated11 osc (1,\_-&gt;0) s1
--   Dumped stated in ./fig
--   ["./fig/stated.dat"]
--   </pre>
--   
stated22 :: (b1 -> b2 -> a1 -> a2 -> (b1, b2)) -> ((TimeStamp, Time -> b1), (TimeStamp, Time -> b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>state</tt> is a state machine without an output decoder, and the
--   state non-transparent. It is an instantiation of the <tt>state</tt>
--   MoC constructor (see <a>state22</a>).
--   
--   Constructors: <tt>state[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let { osc 0 a = a; osc _ a = 0 }
--   
--   &gt;&gt;&gt; let s1 = signal [(0,\_-&gt;1), (6,\_-&gt;0)]
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["state"]} $ state11 osc (1,\_-&gt;0) s1
--   Dumped state in ./fig
--   ["./fig/state.dat"]
--   </pre>
--   
state22 :: (b1 -> b2 -> a1 -> a2 -> (b1, b2)) -> ((TimeStamp, Time -> b1), (TimeStamp, Time -> b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>moore</tt> processes model Moore state machines. It is an
--   instantiation of the <tt>moore</tt> MoC constructor (see
--   <a>moore22</a>).
--   
--   Constructors: <tt>moore[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let { osc 0 a = a; osc _ a = 0 }
--   
--   &gt;&gt;&gt; let s1 = signal [(0,\_-&gt;1), (6,\_-&gt;0)]
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["moore"]} $ moore11 osc (*3) (1,\_-&gt;0) s1
--   Dumped moore in ./fig
--   ["./fig/moore.dat"]
--   </pre>
--   
moore22 :: (st -> a1 -> a2 -> st) -> (st -> (b1, b2)) -> (TimeStamp, Time -> st) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>mealy</tt> processes model Mealy state machines. It is an
--   instantiation of the <tt>mealy</tt> MoC constructor (see
--   <a>mealy22</a>).
--   
--   Constructors: <tt>mealy[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let { osc (-1) _ = 1; osc 1 _ = (-1) }
--   
--   &gt;&gt;&gt; let s1 = infinite sin'
--   
--   &gt;&gt;&gt; dumpDat $ prepare cfg {labels=["mealy"]} $ mealy11 osc (*) (pi',\_-&gt;1) s1
--   Dumped mealy in ./fig
--   ["./fig/mealy.dat"]
--   </pre>
--   
mealy22 :: (st -> a1 -> a2 -> st) -> (st -> a1 -> a2 -> (b1, b2)) -> (TimeStamp, Time -> st) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | Translates a (set of) <a>CT</a> signal(s) into <a>DE</a> semantics
--   without loss of information. In <a>DE</a>, the abstract function of
--   time inferred by the <a>CT</a> event loses its abstraction and it is
--   "dropped" to explicit form, under a lower layer. In other words the
--   implicit time semantics are lost, the carried value simply becoming an
--   ordinary function.
--   
--   Constructors: <tt>toDE[1-4]</tt>.
--   
toDE1 :: Signal a -> Signal (Time -> a)

-- | Synchronizes a (set of) <a>CT</a> signal(s) with a <a>DE</a> carrier
--   which holds the timestamps at which the CT signal must be sampled, and
--   outputs the respective (set of) <a>DE</a> signal(s).
--   
--   Constructors: <tt>sampDE[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = CT.infinite (fromRational . sin')
--   
--   &gt;&gt;&gt; let c = DE.generate1 id (pi'/2, 1)
--   
--   &gt;&gt;&gt; takeS 6 $ sampDE1 c s
--   { 0.0 @0s, 1.0 @1.570796326794s, 1.793238520564752e-12 @3.141592653588s, -1.0 @4.712388980382s, 0.0 @6.283185307176s, 1.0 @7.85398163397s}
--   </pre>
--   
sampDE2 :: Signal t -> Signal a -> Signal b -> (Signal a, Signal b)

-- | Synchronizes all the signals contained by a vector and zips them into
--   one signal of vectors. It instantiates the <a>zipx</a> skeleton.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = CT.signal [(0,const 1), (2,const 2), (6,const 3)]
--   
--   &gt;&gt;&gt; let s2 = CT.signal [(0,const 1), (2,const 2), (4,const 3)]
--   
--   &gt;&gt;&gt; let v1 = V.vector [s1,s1,s2,s2]
--   
--   &gt;&gt;&gt; zipx v1
--   { &lt;1,1,1,1&gt; @0s, &lt;2,2,2,2&gt; @2s, &lt;2,2,3,3&gt; @4s, &lt;3,3,3,3&gt; @6s}
--   </pre>
--   
--   See <a>zipx</a> from the <a>ForSyDe.Atom.MoC.DE</a> library for a
--   comprehensive visual example.
zipx :: Vector (Signal a) -> Signal (Vector a)

-- | Unzips the vectors carried by a signal into a vector of signals. It
--   instantiates the <a>unzipx</a> skeleton. To avoid infinite recurrence,
--   the user needs to provict the length of the output vector.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = V.vector [1,2,3,4]
--   
--   &gt;&gt;&gt; let s1 = CT.signal [(0,const v1),(2,const v1),(6,const v1)]
--   
--   &gt;&gt;&gt; unzipx 4 s1
--   &lt;{ 4 @0s, 4 @2s, 4 @6s},{ 3 @0s, 3 @2s, 3 @6s},{ 2 @0s, 2 @2s, 2 @6s},{ 1 @0s, 1 @2s, 1 @6s}&gt;
--   </pre>
--   
--   See <a>unzipx</a> from the <a>ForSyDe.Atom.MoC.DE</a> library for a
--   comprehensive visual example.
unzipx :: Integer -> Signal (Vector a) -> Vector (Signal a)

-- | Same as <a>unzipx</a>, but "sniffs" the first event to determine the
--   length of the output vector. Might have unsafe behavior!
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = V.vector [1,2,3,4]
--   
--   &gt;&gt;&gt; let s1 = CT.signal [(0,const v1),(2,const v1),(6,const v1)]
--   
--   &gt;&gt;&gt; unzipx' s1
--   &lt;{ 4 @0s, 4 @2s, 4 @6s},{ 3 @0s, 3 @2s, 3 @6s},{ 2 @0s, 2 @2s, 2 @6s},{ 1 @0s, 1 @2s, 1 @6s}&gt;
--   </pre>
unzipx' :: Signal (Vector a) -> Vector (Signal a)


-- | The <tt>SY</tt> library implements the atoms holding the sematics for
--   the synchronous computation model. It also provides a set of helpers
--   for properly instantiating process network patterns as process
--   constructors.
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.MoC.SY

-- | The SY event. It identifies a synchronous signal.
newtype SY a
SY :: a -> SY a
[val] :: SY a -> a

-- | Type synonym for a SY signal, i.e. "an ordered stream of SY events"
type Signal a = Stream (SY a)

-- | Wraps a (tuple of) value(s) into the equivalent unit signal(s).
--   
--   Helpers: <tt>unit</tt>, <tt>unit2</tt>, <tt>unit3</tt>,
--   <tt>unit4</tt>.
unit2 :: () => (a1, a2) -> (Signal a1, Signal a2)

-- | Transforms a list of values into a SY signal.
signal :: [a] -> Signal a

-- | Reads a signal from a string. Like with the <tt>read</tt> function
--   from <tt>Prelude</tt>, you must specify the tipe of the signal.
--   
--   <pre>
--   &gt;&gt;&gt; readSignal "{1,2,3,4,5}" :: Signal Int
--   {1,2,3,4,5}
--   </pre>
readSignal :: Read a => String -> Signal a

-- | The <tt>delay</tt> process "delays" a signal with one event.
--   Instantiates the <a>delay</a> pattern.
--   
--   <pre>
--   &gt;&gt;&gt; let s = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; delay 0 s
--   {0,1,2,3,4,5}
--   </pre>
--   
delay :: a -> Signal a -> Signal a

-- | <tt>comb</tt> processes map combinatorial functions on signals and
--   take care of synchronization between input signals. It instantiates
--   the <tt>comb</tt> pattern (see <a>comb22</a>).
--   
--   Constructors: <tt>comb[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = signal [1..]
--   
--   &gt;&gt;&gt; let s2 = signal [1,1,1,1,1]
--   
--   &gt;&gt;&gt; comb11 (+1) s2
--   {2,2,2,2,2}
--   
--   &gt;&gt;&gt; comb22 (\a b-&gt; (a+b,a-b)) s1 s2
--   ({2,3,4,5,6},{0,1,2,3,4})
--   </pre>
--   
comb22 :: (a1 -> a2 -> (b1, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>reconfig</tt> creates an synchronous adaptive process where the
--   first signal carries functions and the other carry the arguments. It
--   instantiates the <tt>reconfig</tt> atom pattern (see
--   <a>reconfig22</a>).
--   
--   Constructors: <tt>reconfig[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let sf = signal [(+1),(*2),(+1),(*2),(+1),(*2),(+1)]
--   
--   &gt;&gt;&gt; let s1 = signal [1..]
--   
--   &gt;&gt;&gt; reconfig11 sf s1
--   {2,4,4,8,6,12,8}
--   </pre>
--   
reconfig22 :: Signal (a1 -> a2 -> (b1, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | A signal generator which keeps a value constant. It is actually an
--   instantiation of the <tt>stated0X</tt> constructor (check
--   <a>stated22</a>).
--   
--   Constructors: <tt>constant[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let (s1, s2) = constant2 (1,2)
--   
--   &gt;&gt;&gt; takeS 3 s1
--   {1,1,1}
--   
--   &gt;&gt;&gt; takeS 5 s2
--   {2,2,2,2,2}
--   </pre>
--   
constant2 :: (b1, b2) -> (Signal b1, Signal b2)

-- | A signal generator based on a function and a kernel value. It is
--   actually an instantiation of the <tt>stated0X</tt> constructor (check
--   <a>stated22</a>).
--   
--   Constructors: <tt>generate[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let (s1,s2) = generate2 (\a b -&gt; (a+1,b+2)) (1,2)
--   
--   &gt;&gt;&gt; takeS 5 s1
--   {1,2,3,4,5}
--   
--   &gt;&gt;&gt; takeS 7 s2
--   {2,4,6,8,10,12,14}
--   </pre>
--   
generate2 :: (b1 -> b2 -> (b1, b2)) -> (b1, b2) -> (Signal b1, Signal b2)

-- | <tt>stated</tt> is a state machine without an output decoder. It is an
--   instantiation of the <tt>state</tt> MoC constructor (see
--   <a>stated22</a>).
--   
--   Constructors: <tt>stated[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; stated11 (+) 1 s1
--   {1,2,4,7,11,16}
--   </pre>
--   
stated22 :: (b1 -> b2 -> a1 -> a2 -> (b1, b2)) -> (b1, b2) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>state</tt> is a state machine without an output decoder. It is an
--   instantiation of the <tt>stated</tt> MoC constructor (see
--   <a>state22</a>).
--   
--   Constructors: <tt>state[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; state11 (+) 1 s1
--   {2,4,7,11,16}
--   </pre>
--   
state22 :: (b1 -> b2 -> a1 -> a2 -> (b1, b2)) -> (b1, b2) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>moore</tt> processes model Moore state machines. It is an
--   instantiation of the <tt>moore</tt> MoC constructor (see
--   <a>moore22</a>).
--   
--   Constructors: <tt>moore[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; moore11 (+) (+1) 1 s1
--   {2,3,5,8,12,17}
--   </pre>
--   
moore22 :: (st -> a1 -> a2 -> st) -> (st -> (b1, b2)) -> st -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>mealy</tt> processes model Mealy state machines. It is an
--   instantiation of the <tt>mealy</tt> MoC constructor (see
--   <a>mealy22</a>).
--   
--   Constructors: <tt>mealy[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; mealy11 (+) (-) 1 s1
--   {0,0,1,3,6}
--   </pre>
--   
mealy22 :: (st -> a1 -> a2 -> st) -> (st -> a1 -> a2 -> (b1, b2)) -> st -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | This process predicates the existence of values in a signal based on a
--   signal of boolean values (conditions). It is similar to the
--   <tt>when</tt> construct in the synchronous language Lustre
--   <a>[Halbwachs91]</a>, based on which clock calculus can be performed.
--   
--   <b>OBS:</b> this process assumes that all signals carry
--   absent-extended values, which is appropriate in describing multi-clock
--   systems. For a version which inputs signals of non-extended values,
--   check <a>when'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = (signal . map Prst) [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let pred = (signal . map Prst) [False,False,False,True,True]
--   
--   &gt;&gt;&gt; when pred s1
--   {⟂,⟂,⟂,4,5}
--   </pre>
--   
when :: Signal (AbstExt Bool) -> Signal (AbstExt a) -> Signal (AbstExt a)

-- | Same as <a>when</a> but inputs signals of non-extended values.
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let pred = signal [False,False,False,True,True]
--   
--   &gt;&gt;&gt; when' pred s1
--   {⟂,⟂,⟂,4,5}
--   </pre>
when' :: Signal Bool -> Signal a -> Signal (AbstExt a)

-- | Simple wrapper for applying a predicate function on a signal of
--   absent-extended events.
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = signal $ map Prst [1,2,3,4,5]
--   
--   &gt;&gt;&gt; s1 `is` (&gt;3)
--   {False,False,False,True,True}
--   </pre>
is :: Signal (AbstExt a) -> (a -> Bool) -> Signal (AbstExt Bool)

-- | Same as <a>when</a> but triggering the output events merely based on
--   the presence of the first input rather than a predicate function.
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = signal $ map Prst [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let sp   = signal [Prst 1, Prst 1, Abst, Prst 1, Abst]
--   
--   &gt;&gt;&gt; whenPresent sp s1
--   {1,2,⟂,4,⟂}
--   </pre>
whenPresent :: () => Signal AbstExt a1 -> Signal AbstExt a2 -> Signal AbstExt a2

-- | Filters out values to <a>Abst</a> if they do not fulfill a predicate
--   function.
--   
--   <b>OBS:</b> this process assumes that all signals carry
--   absent-extended values, which is appropriate in describing multi-clock
--   systems. For a version which inputs signals of non-extended values,
--   check <a>filter'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = (signal . map Prst) [1,2,3,4,5]
--   
--   &gt;&gt;&gt; filter (&gt;3) s1
--   {⟂,⟂,⟂,4,5}
--   </pre>
--   
filter :: (a -> Bool) -> Signal (AbstExt a) -> Signal (AbstExt a)

-- | Same as <a>filter</a> but inputs signals of non-extended values.
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; filter' (&gt;3) s1
--   {⟂,⟂,⟂,4,5}
--   </pre>
filter' :: (a -> Bool) -> Signal a -> Signal (AbstExt a)

-- | Fills absent events with a pre-defined value.
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = signal [Abst, Abst, Prst 1, Prst 2, Abst, Prst 3]
--   
--   &gt;&gt;&gt; fill 0 s1
--   {0,0,1,2,0,3}
--   </pre>
--   
fill :: a -> Signal (AbstExt a) -> Signal a

-- | Similar to <a>fill</a>, but holds the last non-absent value if there
--   was one. It implements a <tt>state</tt> pattern (see <a>state22</a>).
--   
--   <pre>
--   &gt;&gt;&gt; let s1   = signal [Abst, Abst, Prst 1, Prst 2, Abst, Prst 3]
--   
--   &gt;&gt;&gt; hold 0 s1
--   {0,0,1,2,2,3}
--   </pre>
--   
hold :: a -> Signal (AbstExt a) -> Signal a

-- | Creates a wrapper enabling a reactive behvior to absent-extended
--   signals for processes which would otherwise degrade the
--   absent-extension (e.g. state machines with <tt>ignore22</tt>
--   behavior).
--   
--   Constructors: <tt>reactAbst[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = readSignal "{1,1,1,_,1,_,1}" :: Signal (AbstExt Int)
--   
--   &gt;&gt;&gt; let proc = stated11 (B.ignore11 (+)) 0
--   
--   &gt;&gt;&gt; proc s1
--   {0,1,2,3,3,4,4,5}
--   
--   &gt;&gt;&gt; reactAbst1 proc s1
--   {0,1,2,⟂,3,⟂,4} 
--   </pre>
--   
reactAbst2 :: (Signal (AbstExt a1) -> Signal (AbstExt a2) -> Signal b) -> Signal (AbstExt a1) -> Signal (AbstExt a2) -> Signal (AbstExt b)

-- | Wraps explicit timestamps to a (set of) <a>SY</a> signal(s), rendering
--   the equivalent synchronized <a>DE</a> signal(s).
--   
--   Constructors: <tt>toDE</tt>, <tt>toDE2</tt>, <tt>toDE3</tt>,
--   <tt>toDE4</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = SY.signal [0,3,4,6,9]
--   
--   &gt;&gt;&gt; let s2 = SY.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; toDE s1 s2
--   { 1 @0s, 2 @3s, 3 @4s, 4 @6s, 5 @9s}
--   </pre>
--   
toDE2 :: Signal TimeStamp -> Signal a -> Signal b -> (Signal a, Signal b)

-- | Transforms a (set of) <a>SY</a> signal(s) into the equivalent
--   <a>SDF</a> signal(s). The only change is the event consructor. The
--   total order of SY is interpreted as partial order by the next SDF
--   process downstream.
--   
--   Constructors: <tt>toSDF</tt>, <tt>toSDF2</tt>, <tt>toSDF3</tt>,
--   <tt>toSDF4</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = SY.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; toSDF s
--   {1,2,3,4,5}
--   </pre>
--   
toSDF2 :: Signal a -> Signal b -> (Signal a, Signal b)

-- | Synchronizes all the signals contained by a vector and zips them into
--   one signal of vectors. It instantiates the <a>zipx</a> skeleton.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = SY.signal [1,2,3,4,5]
--   
--   &gt;&gt;&gt; let s2 = SY.signal [11,12,13,14,15]
--   
--   &gt;&gt;&gt; let v1 = V.vector [s1,s1,s2,s2]
--   
--   &gt;&gt;&gt; v1
--   &lt;{1,2,3,4,5},{1,2,3,4,5},{11,12,13,14,15},{11,12,13,14,15}&gt;
--   
--   &gt;&gt;&gt; zipx v1
--   {&lt;1,1,11,11&gt;,&lt;2,2,12,12&gt;,&lt;3,3,13,13&gt;,&lt;4,4,14,14&gt;,&lt;5,5,15,15&gt;}
--   </pre>
--   
zipx :: Vector (Signal a) -> Signal (Vector a)

-- | Unzips the vectors carried by a signal into a vector of signals. It
--   instantiates the <a>unzipx</a> skeleton. To avoid infinite recurrence,
--   the user needs to provide the length of the output vector.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = V.vector [1,2,3,4]
--   
--   &gt;&gt;&gt; let s1 = SY.signal [v1,v1,v1,v1,v1]
--   
--   &gt;&gt;&gt; s1
--   {&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;}
--   
--   &gt;&gt;&gt; unzipx 4 s1
--   &lt;{1,1,1,1,1},{2,2,2,2,2},{3,3,3,3,3},{4,4,4,4,4}&gt;
--   </pre>
--   
unzipx :: Integer -> Signal (Vector a) -> Vector (Signal a)

-- | Same as <a>unzipx</a>, but "sniffs" the first event to determine the
--   length of the output vector. Might have unsafe behavior!
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = V.vector [1,2,3,4]
--   
--   &gt;&gt;&gt; let s1 = SY.signal [v1,v1,v1,v1,v1]
--   
--   &gt;&gt;&gt; s1
--   {&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;,&lt;1,2,3,4&gt;}
--   
--   &gt;&gt;&gt; unzipx' s1
--   &lt;{1,1,1,1,1},{2,2,2,2,2},{3,3,3,3,3},{4,4,4,4,4}&gt;
--   </pre>
unzipx' :: Signal (Vector a) -> Vector (Signal a)


-- | The <tt>DE</tt> library implements the atoms holding the sematics for
--   the discrete event computation model. It also provides a set of
--   helpers for properly instantiating process network patterns as process
--   constructors.
--   
--   <b>IMPORTANT!!!</b> see the <a>naming convention</a> rules on how to
--   interpret, use and develop your own constructors.
module ForSyDe.Atom.MoC.DE

-- | Alias for the type representing discrete time. It is inherently
--   quantizable, the quantum being a picosecond (10⁻¹² seconds), thus it
--   can be considered order-isomorphic with a set of integers, i.e.
--   between any two timestamps there is a finite number of timestamps.
--   Moreover, a timestamp can be easily translated into a rational number
--   representing fractions of a second, so the conversion between
--   timestamps (discrete time) and rationals (analog/continuous time) is
--   straightforward.
--   
--   This type is used in the explicit tags of the <a>DE</a> MoC (and
--   subsequently the discrete event evaluation engine for simulating the
--   <a>CT</a> MoC).
type TimeStamp = DiffTime

-- | The DE event. It identifies a discrete event signal.
data DE a
DE :: TimeStamp -> a -> DE a

-- | timestamp
[tag] :: DE a -> TimeStamp

-- | the value
[val] :: DE a -> a

-- | Type synonym for a SY signal, i.e. "a signal of SY events"
type Signal a = Stream (DE a)

-- | Wraps a (tuple of) pair(s) <tt>(tag, value)</tt> into the equivalent
--   unit signal(s), in this case a signal with one event with the period
--   <tt>tag</tt> carrying <tt>value</tt>.
--   
--   Helpers: <tt>unit</tt> and <tt>unit[2-4]</tt>.
unit2 :: () => ((TimeStamp, a1), (TimeStamp, a2)) -> (Signal a1, Signal a2)

-- | Creates an infinite signal.
infinite :: a -> Signal a

-- | Takes the first part of the signal util a given timestamp. The last
--   event of the resulting signal is at the given timestamp and carries
--   the previous value. This utility is useful when plotting a signal, to
--   specify the interval of plotting.
until :: TimeStamp -> Signal a -> Signal a

-- | Transforms a list of tuples <tt>(tag, value)</tt> into a DE signal.
--   Checks if it is well-formed.
signal :: [(TimeStamp, a)] -> Signal a

-- | Checks if a signal is well-formed or not, according to the DE MoC
--   interpretation in <tt>ForSyDe-Atom</tt>.
checkSignal :: () => Stream DE a -> Stream DE a

-- | Reads a signal from a string and checks if it is well-formed. Like
--   with the <tt>read</tt> function from <tt>Prelude</tt>, you must
--   specify the type of the signal.
--   
--   <pre>
--   &gt;&gt;&gt; readSignal "{ 1@0, 2@2, 3@5, 4@7, 5@10 }" :: Signal Int
--   { 1 @0s, 2 @2s, 3 @5s, 4 @7s, 5 @10s}
--   </pre>
--   
--   Incorrect usage (not covered by <tt>doctest</tt>):
--   
--   <pre>
--   λ&gt; readSignal "{ 1@0, 2@2, 3@5, 4@10, 5@7 }" :: Signal Int
--   { 1 @0s, 2 @2s, 3 @5s*** Exception: [MoC.DE] malformed signal
--   λ&gt; readSignal "{ 1@1, 2@2, 3@5, 4@7, 5@10 }" :: Signal Int
--   *** Exception: [MoC.DE] signal does not start from global 0
--   </pre>
readSignal :: Read a => String -> Signal a

-- | The <tt>delay</tt> process "delays" a signal with one event.
--   Instantiates the <a>delay</a> pattern.
--   
--   <pre>
--   &gt;&gt;&gt; let s = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: Signal Int
--   
--   &gt;&gt;&gt; delay 3 0 s
--   { 0 @0s, 1 @3s, 2 @5s, 3 @9s, 4 @11s, 5 @12s}
--   </pre>
--   
delay :: TimeStamp -> a -> Signal a -> Signal a

-- | Similar to the previous, but this is the raw instantiation of the
--   <a>delay</a> pattern. It "borrows" the first event from one signal and
--   appends it at the head of another signal.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: Signal Int
--   
--   &gt;&gt;&gt; let s2 = readSignal "{3@0, 4@4, 5@5, 6@8, 7@9}" :: Signal Int
--   
--   &gt;&gt;&gt; delay' s1 s2
--   { 1 @0s, 3 @2s, 4 @6s, 5 @7s, 6 @10s, 7 @11s}
--   </pre>
--   
delay' :: Signal a -> Signal a -> Signal a

-- | <tt>comb</tt> processes map combinatorial functions on signals and
--   take care of synchronization between input signals. It instantiates
--   the <tt>comb</tt> pattern (see <a>comb22</a>).
--   
--   Constructors: <tt>comb[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = infinite 1
--   
--   &gt;&gt;&gt; let s2 = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: Signal Int
--   
--   &gt;&gt;&gt; comb11 (+1) s2
--   { 2 @0s, 3 @2s, 4 @6s, 5 @8s, 6 @9s}
--   
--   &gt;&gt;&gt; comb22 (\a b-&gt; (a+b,a-b)) s1 s2
--   ({ 2 @0s, 3 @2s, 4 @6s, 5 @8s, 6 @9s},{ 0 @0s, -1 @2s, -2 @6s, -3 @8s, -4 @9s})
--   </pre>
--   
comb22 :: (a1 -> a2 -> (b1, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>reconfig</tt> creates a DE adaptive process where the first signal
--   carries functions and the other carry the arguments. It instantiates
--   the <tt>reconfig</tt> atom pattern (see <a>reconfig22</a>).
--   
--   Constructors: <tt>reconfig[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let sf = signal [(0,(+1)),(2,(*2)),(5,(+1)),(7,(*2))]
--   
--   &gt;&gt;&gt; let s1 = signal [(0,1),(3,2),(5,3),(9,4)]
--   
--   &gt;&gt;&gt; reconfig11 sf s1
--   { 2 @0s, 2 @2s, 4 @3s, 4 @5s, 6 @7s, 8 @9s}
--   </pre>
--   
reconfig22 :: Signal (a1 -> a2 -> (b1, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>sync</tt> synchronizes multiple signals, so that they have the
--   same set of tags, and consequently, the same number of events. It
--   instantiates the <tt>comb</tt> atom pattern (see <a>comb22</a>).
--   
--   Constructors: <tt>sync[1-4]</tt>
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = readSignal "{1@0, 2@2, 3@6, 4@8,  5@9}"  :: Signal Int
--   
--   &gt;&gt;&gt; let s2 = readSignal "{1@0, 2@5, 3@6, 4@10, 5@12}" :: Signal Int
--   
--   &gt;&gt;&gt; sync2 s1 s2
--   ({ 1 @0s, 2 @2s, 2 @5s, 3 @6s, 4 @8s, 5 @9s, 5 @10s, 5 @12s},{ 1 @0s, 1 @2s, 2 @5s, 3 @6s, 3 @8s, 3 @9s, 4 @10s, 5 @12s})
--   </pre>
--   
sync2 :: Signal a1 -> Signal a2 -> (Signal a1, Signal a2)

-- | A signal generator which keeps a value constant. As compared with the
--   <a>SY</a>, it just constructs an infinite signal with constant value
--   (i.e. a signal with one event starting from time 0).
--   
--   Constructors: <tt>constant[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; constant1 2
--   { 2 @0s}
--   </pre>
--   
constant2 :: (b1, b2) -> (Signal b1, Signal b2)

-- | A signal generator based on a function and a kernel value. It is
--   actually an instantiation of the <tt>stated0X</tt> constructor (check
--   <a>stated22</a>).
--   
--   Constructors: <tt>generate[1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let (s1,s2) = generate2 (\a b -&gt; (a+1,b+2)) ((3,1),(1,2))
--   
--   &gt;&gt;&gt; takeS 5 s1
--   { 1 @0s, 2 @3s, 2 @4s, 2 @5s, 3 @6s}
--   
--   &gt;&gt;&gt; takeS 7 s2
--   { 2 @0s, 4 @1s, 6 @2s, 8 @3s, 10 @4s, 12 @5s, 14 @6s}
--   </pre>
--   
generate2 :: (b1 -> b2 -> (b1, b2)) -> ((TimeStamp, b1), (TimeStamp, b2)) -> (Signal b1, Signal b2)

-- | <tt>stated</tt> is a state machine without an output decoder. It is an
--   instantiation of the <tt>state</tt> MoC constructor (see
--   <a>stated22</a>).
--   
--   Constructors: <tt>stated[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: Signal Int
--   
--   &gt;&gt;&gt; takeS 7 $ stated11 (+) (6,1) s
--   { 1 @0s, 2 @6s, 3 @8s, 5 @12s, 7 @14s, 8 @15s, 10 @18s}
--   </pre>
--   
stated22 :: (b1 -> b2 -> a1 -> a2 -> (b1, b2)) -> ((TimeStamp, b1), (TimeStamp, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>state</tt> is a state machine without an output decoder, and the
--   state non-transparent. It is an instantiation of the <tt>state</tt>
--   MoC constructor (see <a>state22</a>).
--   
--   Constructors: <tt>state[1-4][1-4]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let s = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: Signal Int
--   
--   &gt;&gt;&gt; takeS 7 $ state11 (+) (6,1) s
--   { 2 @0s, 3 @2s, 5 @6s, 7 @8s, 8 @9s, 10 @12s, 12 @14s}
--   </pre>
--   
state22 :: (b1 -> b2 -> a1 -> a2 -> (b1, b2)) -> ((TimeStamp, b1), (TimeStamp, b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>moore</tt> processes model Moore state machines. It is an
--   instantiation of the <tt>moore</tt> MoC constructor (see
--   <a>moore22</a>).
--   
--   Constructors: <tt>moore[1-4][1-4]</tt>
--   
--   <pre>
--   &gt;&gt;&gt; let s = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: Signal Int
--   
--   &gt;&gt;&gt; takeS 7 $ moore11 (+) (+1) (6,1) s
--   { 2 @0s, 3 @6s, 4 @8s, 6 @12s, 8 @14s, 9 @15s, 11 @18s}
--   </pre>
--   
moore22 :: (st -> a1 -> a2 -> st) -> (st -> (b1, b2)) -> (TimeStamp, st) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | <tt>mealy</tt> processes model Mealy state machines. It is an
--   instantiation of the <tt>mealy</tt> MoC constructor (see
--   <a>mealy22</a>).
--   
--   Constructors: <tt>mealy[1-4][1-4]</tt>
--   
--   <pre>
--   &gt;&gt;&gt; let s = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: Signal Int
--   
--   &gt;&gt;&gt; takeS 7 $ mealy11 (+) (-) (6,1) s
--   { 0 @0s, -1 @2s, -1 @6s, -1 @8s, -2 @9s, 0 @12s, 2 @14s}
--   </pre>
--   
mealy22 :: (st -> a1 -> a2 -> st) -> (st -> a1 -> a2 -> (b1, b2)) -> (TimeStamp, st) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)

-- | Synchronizes a (set of) <a>DE</a> signal(s) an strips off their
--   explicit tags, outputting the equivalent <a>SY</a> signal(s), tupled
--   with an SY signal carrying the timestamps for the synchronization
--   points.
--   
--   Constructors: <tt>toSY[1-4]</tt>
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = DE.infinite 1
--   
--   &gt;&gt;&gt; let s2 = DE.readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: DE.Signal Int
--   
--   &gt;&gt;&gt; toSY2 s1 s2
--   ({0s,2s,6s,8s,9s},{1,1,1,1,1},{1,2,3,4,5})
--   </pre>
--   
toSY2 :: Signal a -> Signal b -> (Signal TimeStamp, Signal a, Signal b)

-- | Semantic preserving transformation between a (set of) DE signal(s) and
--   the equivalent CT signals. The <a>DE</a> events must carry a function
--   of <a>Time</a> which will be lifted by providing it with <a>CT</a>
--   implicit time semantics.
--   
--   Constructors: <tt>toCT[1-4]</tt>.
--   
toCT2 :: Signal (Time -> a) -> Signal (Time -> b) -> (Signal a, Signal b)

-- | Synchronizes all the signals contained by a vector and zips them into
--   one signal of vectors. It instantiates the <a>zipx</a> skeleton.
--   
--   <pre>
--   &gt;&gt;&gt; let s1 = DE.readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: DE.Signal Int
--   
--   &gt;&gt;&gt; let s2 = DE.readSignal "{1@0, 2@2, 3@4, 4@8, 5@9}" :: DE.Signal Int
--   
--   &gt;&gt;&gt; let v1 = V.vector [s1,s1,s2,s2]
--   
--   &gt;&gt;&gt; v1
--   &lt;{ 1 @0s, 2 @2s, 3 @6s, 4 @8s, 5 @9s},{ 1 @0s, 2 @2s, 3 @6s, 4 @8s, 5 @9s},{ 1 @0s, 2 @2s, 3 @4s, 4 @8s, 5 @9s},{ 1 @0s, 2 @2s, 3 @4s, 4 @8s, 5 @9s}&gt;
--   
--   &gt;&gt;&gt; zipx v1
--   { &lt;1,1,1,1&gt; @0s, &lt;2,2,2,2&gt; @2s, &lt;2,2,3,3&gt; @4s, &lt;3,3,3,3&gt; @6s, &lt;4,4,4,4&gt; @8s, &lt;5,5,5,5&gt; @9s}
--   </pre>
--   
zipx :: Vector (Signal a) -> Signal (Vector a)

-- | Unzips the vectors carried by a signal into a vector of signals. It
--   instantiates the <a>unzipx</a> skeleton. To avoid infinite recurrence,
--   the user needs to provide the length of the output vector.
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = V.vector [1,2,3,4]
--   
--   &gt;&gt;&gt; let s1 = DE.signal [(0,v1),(2,v1),(6,v1),(8,v1),(9,v1)]
--   
--   &gt;&gt;&gt; s1
--   { &lt;1,2,3,4&gt; @0s, &lt;1,2,3,4&gt; @2s, &lt;1,2,3,4&gt; @6s, &lt;1,2,3,4&gt; @8s, &lt;1,2,3,4&gt; @9s}
--   
--   &gt;&gt;&gt; unzipx 4 s1
--   &lt;{ 1 @0s, 1 @2s, 1 @6s, 1 @8s, 1 @9s},{ 2 @0s, 2 @2s, 2 @6s, 2 @8s, 2 @9s},{ 3 @0s, 3 @2s, 3 @6s, 3 @8s, 3 @9s},{ 4 @0s, 4 @2s, 4 @6s, 4 @8s, 4 @9s}&gt;
--   </pre>
--   
unzipx :: Integer -> Signal (Vector a) -> Vector (Signal a)

-- | Same as <a>unzipx</a>, but "sniffs" the first event to determine the
--   length of the output vector. Might have unsafe behavior!
--   
--   <pre>
--   &gt;&gt;&gt; let v1 = V.vector [1,2,3,4]
--   
--   &gt;&gt;&gt; let s1 = DE.signal [(0,v1),(2,v1),(6,v1),(8,v1),(9,v1)]
--   
--   &gt;&gt;&gt; s1
--   { &lt;1,2,3,4&gt; @0s, &lt;1,2,3,4&gt; @2s, &lt;1,2,3,4&gt; @6s, &lt;1,2,3,4&gt; @8s, &lt;1,2,3,4&gt; @9s}
--   
--   &gt;&gt;&gt; unzipx' s1
--   &lt;{ 1 @0s, 1 @2s, 1 @6s, 1 @8s, 1 @9s},{ 2 @0s, 2 @2s, 2 @6s, 2 @8s, 2 @9s},{ 3 @0s, 3 @2s, 3 @6s, 3 @8s, 3 @9s},{ 4 @0s, 4 @2s, 4 @6s, 4 @8s, 4 @9s}&gt;
--   </pre>
unzipx' :: Signal (Vector a) -> Vector (Signal a)

-- | Embeds a <a>SY</a> process inside a <a>DE</a> environment. Internally,
--   it synchronizes the input signals, translates them to SY, feeds them
--   to a SY process and translates the result back to DE using the same
--   input tags. Seen from outside, this process behaves like a DE process
--   with "instantaneous response", even for feedback loops.
--   
--   Constructors: <tt>embedSY[1-4][1-4]</tt>.
--   
--   For the following example, see the difference between its output and
--   the one of <a>stated22</a>
--   
--   <pre>
--   &gt;&gt;&gt; let s = readSignal "{1@0, 2@2, 3@6, 4@8, 5@9}" :: DE.Signal Int
--   
--   &gt;&gt;&gt; embedSY11 (SY.stated11 (+) 1) s
--   { 1 @0s, 2 @2s, 4 @6s, 7 @8s, 11 @9s}
--   </pre>
--   
embedSY22 :: (Signal a1 -> Signal a2 -> (Signal b1, Signal b2)) -> Signal a1 -> Signal a2 -> (Signal b1, Signal b2)


-- | The formal foundation upon which ForSyDe <a>[Sander04]</a> defines its
--   semantics is the <i>tagged signal model</i> <a>[Lee98]</a>. This is a
--   denotational framework introduced by Lee and Sangiovanni-Vincentelli
--   as a common meta model for describing properties of concurrent systems
--   in general terms as sets of possible behaviors. Systems are regarded
--   as <i>compositions</i> of <i>processes</i> acting on <i>signals</i>
--   which are sets of <i>tagged events</i>. Signals are characterized by a
--   <i>tag system</i> which determines causality between events, and could
--   model time, precedence relationships, synchronization points, and
--   other key properties. Based on how tag systems are defined, one can
--   identify several <i>Models of Computations (MoCs)</i> as classes of
--   behaviors dictating the semantics of execution and concurrency in a
--   network of processes.
--   
--   These concepts are the supporting pillars of ForSyDe's philosophy, and
--   state the purpose of the <tt>forsyde-atom</tt> library: it is supposed
--   to be a modelling framework used as a proof-of-concept for the
--   atom-based approach to cyber-physical systems <a>[Ungureanu17]</a>.
--   This approach extends the tagged signal model by systematically
--   deconstructing processes to their basic semantics and recreating them
--   using a minimal language of primitive building blocks called
--   <i>atoms</i>. It also tries to expand the scope of this model by
--   exploiting more aspects than just timing, by adding primitives for
--   parallelism, behavior, etc.
--   
--   The API documentation is structured as follows: this page provides an
--   overview of the general notions and concepts, gently introducing the
--   separate modules and the motivation behind them. Each major module
--   corresponds to a separate <i>layer</i> <a>[Ungureanu17]</a>
--   implemented as a type class. The documentation pages for each layer
--   and for each of their instances contains in-depth knowledge and
--   examples, and can be accessed from the contents page or by following
--   the links suggested. For more complex examples and tutorials follow
--   the links in the <a>project web page</a>.
--   
--   <b>IMPORTANT!!!</b> All multi-parameter patterns and utilities
--   provided by the library API as higher-order functions are named along
--   the lines of <tt>functionMN</tt> where <tt>M</tt> represents the
--   number of <b><i>curried</i></b> inputs (i.e. <tt>a1 -&gt; a2 -&gt; ...
--   -&gt; aM</tt>), while <tt>N</tt> represents the number of
--   <b><i>tupled</i></b> outputs (i.e. <tt>(b1,b2,...,bN)</tt>). To avoid
--   repetition we only provide documentation for functions with 2 inputs
--   and 2 outputs (i.e. <tt>function22</tt>), while the available ones are
--   mentioned as a regex (i.e. <tt>function[1-4][1-4]</tt>). In case the
--   provided functions do not suffice, feel free to implement your own
--   patterns following the examples in the source code.
module ForSyDe.Atom

-- | Class which defines the atoms for the extended behavior layer.
--   
--   As its name suggests, this layer is extending the behavior of
--   processes (or merely of functions if we ignore timing semantics
--   completely), by expanding the domains of the wrapped layer (e.g. the
--   set of values) with symbols having clearly-defined semantics (e.g.
--   special events with known responses).
--   
--   The types associated with this layer can simply be describes as:
--   
--   
--   where <i>α</i> is a base type and <i>b</i> is the type extension, i.e.
--   a set of symbols with clearly-defined semantics.
--   
--   Extended behavior atoms are functions of these types, defined as
--   interfaces in the <a>ExB</a> type class.
class Functor b => ExB b

-- | Extends a value (from a layer below) with a set of symbols with known
--   semantics, as described by a type instantiating this class.
extend :: ExB b => a -> b a

-- | Basic functor operator. Lifts a function (from a layer below) into the
--   domain of the extended behavior layer.
--   
(/.\) :: ExB b => (a -> a') -> b a -> b a'

-- | Applicative operator. Defines a res between two extended behavior
--   symbols.
--   
(/*\) :: ExB b => b (a -> a') -> b a -> b a'

-- | Predicate operator. Generates a defined behavior based on an extended
--   Boolean predicate.
--   
(/&\) :: ExB b => b Bool -> b a -> b a

-- | Degrade operator. Degrades a behavior-extended value into a
--   non-extended one (from a layer below), based on a kernel value. Used
--   also to throw exceptions.
--   
(/!\) :: ExB b => a -> b a -> a

-- | Defines a stream of events, encapsulating them in a structure
--   isomorphic to an infinite list <a>[Bird87]</a>, thus all properties of
--   lists may also be applied to <a>Stream</a>s. While, in combination
--   with lazy evaluation, it is possible to create and simulate infinite
--   signals, we need to ensure that the first/previous event is always
--   fully evaluated. This can be translated into the following rule:
--   
--   <ul>
--   <li><i>zero-delay feedbacks</i> are forbidden, due to un-evaluated
--   self-referential calls. In a feedback loop, there always has to be
--   enough events to ensure the data flow.</li>
--   </ul>
--   
--   This rule imposes that the stream of data is uninterrupted in order to
--   have an evaluatable kernel every time a new event is produced (i.e. to
--   avoid deadlocks). Thus we can add the rule:
--   
--   <ul>
--   <li><i>cleaning of output events</i> is also forbidden. In other
--   words, for each new input at any instant in time, a process must react
--   with <i>at least</i> one output event.</li>
--   </ul>
data Stream e

-- | terminates a signal
NullS :: Stream e

-- | the default constructor appends an event to the head of the stream
(:-) :: e -> Stream e -> Stream e

-- | Type alias for the type to represent metric (continuous) time.
--   Underneath we use <a>Rational</a> that is able to represent any
--   <i>t</i> between <i>t₁</i> &lt; <i>t₂</i> ∈ <i>T</i>.
type Time = Rational

-- | Alias for the type representing discrete time. It is inherently
--   quantizable, the quantum being a picosecond (10⁻¹² seconds), thus it
--   can be considered order-isomorphic with a set of integers, i.e.
--   between any two timestamps there is a finite number of timestamps.
--   Moreover, a timestamp can be easily translated into a rational number
--   representing fractions of a second, so the conversion between
--   timestamps (discrete time) and rationals (analog/continuous time) is
--   straightforward.
--   
--   This type is used in the explicit tags of the <a>DE</a> MoC (and
--   subsequently the discrete event evaluation engine for simulating the
--   <a>CT</a> MoC).
type TimeStamp = DiffTime

-- | This is a type class defining interfaces for the MoC layer atoms. Each
--   model of computation exposes its tag system through a unique event
--   constructor as an instance of this class, which defines <i>T</i> ×
--   <i>V</i>.
--   
--   To express all possible MoCs which can be described using a
--   <i>tagged</i> <i>signal</i> <i>model</i> we need to capture the most
--   general form of their atoms. Recall that all atoms in the layered
--   framework are represented as higher-order functions on structured
--   types (instances of this class), taking functions of other (lower)
--   layers as arguments. While this principle stands also for this layer,
--   the functions taken as arguments need to be formatted for each MoC in
--   particular in order to capture additional information, which we can
--   call in general terms as the <i>execution context</i>.
--   
--   One typical example of additional information is the consumption and
--   production rates of for data flow MoCs (e.g. SDF). In this case the
--   passed functions are defined over "partitions" of events, i.e.
--   groupings of events with the same partial order in relation to, for
--   example, a process firing. The formal description of such a "formatted
--   function" taken as argument by a MoC entity is:
--   
--   
--   where <i>a</i> and <i>b</i> might be Cartesian products of different
--   types, corresponding to how many signals the constructor is applied to
--   or how many signals it yields, and each type is expressed as:
--   
--   
--   While, as you can see above, the execution context can be extracted
--   from the type information, working with type-level parameters is not a
--   trivial task in Haskell, especially if we want to describe a general
--   and extensible type class. This is why we have chosen a pragmatic
--   approach in implementing the <a>MoC</a> class:
--   
--   <ul>
--   <li>any (possible) Cartesian product of <i>α</i> is represented using
--   a recursive type, namely a list [<i>α</i>].</li>
--   <li>as the execution context cannot (or can hardly) be extracted from
--   the recursive type, in the most general case we pass both context
--   <i>and</i> argument as a pair (see each instance in particular). To
--   aid in pairing contexts with each argument in a function, the
--   <tt>ctxt</tt> utilities are provided (see <a>ctxt22</a>).</li>
--   <li>this artifice was masked using the generic type families
--   <a>Fun</a> and <tt>Res</tt>.</li>
--   </ul>
class (Applicative e) => MoC e where {
    type family Fun e a b;
    type family Ret e b;
}

-- | This atom is mapping a function on values (in the presence of a
--   context) to a signal, i.e. stream of tagged events. As ForSyDe deals
--   with <i>determinate</i>, <i>functional</i> processes, this atom
--   defines the (only) <i>behavior</i> of a process in rapport to one
--   input signal <a>[Lee98]</a>.
--   
(-.-) :: MoC e => Fun e a b -> Stream (e a) -> Stream (e b)

-- | This atom synchronizes two signals, one carrying functions on values
--   (in the presence of a context), and the other containing values,
--   during which it applies the former on the latter. As concerning the
--   process created, this atom defines a <i>relation</i> between two
--   signals <a>[Lee98]</a>.
--   
(-*-) :: MoC e => Stream (e (Fun e a b)) -> Stream (e a) -> Stream (e b)

-- | Artificial <i>utility</i> which drops the context and/or partitioning
--   yielding a clean signal type.
--   
(-*) :: MoC e => Stream (e (Ret e b)) -> Stream (e b)

-- | This atom appends a (partition of) events at the beginning of a
--   signal. This atom is necessary to ensure <i>complete partial order</i>
--   of a signal and assures the <i>least upper bound</i> necessary for
--   example in the evaluation of feedback loops <a>[Lee98]</a>.
--   
--   
--   Notice the difference between the formal and the implemented type
--   signatures. In the implementation the value/partition is wrapped
--   inside an event type to enable smooth composition. You might also
--   notice the type for the "initial event(s)" as being wrapped inside a
--   signal constructor. This allows defining an DSL for this layer which
--   is centered around signals exclusively, while also enabling to define
--   atoms as homomorphisms to certain extent <a>[Bird97]</a>. Certain MoCs
--   might have additional constraints on the first operand to be finite.
(-<-) :: MoC e => Stream (e a) -> Stream (e a) -> Stream (e a)

-- | This atom allows the manipulation of tags in a signal in a restrictive
--   way which preserves <i>monotonicity</i> and <i>continuity</i> in a
--   process <a>[Lee98]</a>, namely by “phase-shifting” all tags in a
--   signal with the appropriate metric corresponding to each MoC. Thus it
--   preserves the characteristic function intact <a>[Sander04]</a>.
--   
--   
--   As with the <a>-&lt;-</a> atom, we can justify the type signature for
--   smooth composition and the definition of atoms as homomorphisms to
--   certain extent. This in turn allows the interpretation of the
--   <a>-&amp;-</a> operator as "aligning the phases" of two signals: the
--   second operand is aligned based on the first.
(-&-) :: MoC e => Stream (e a) -> Stream (e a) -> Stream (e a)

-- | Class containing all the Skeleton layer atoms.
--   
--   This class is instantiated by a set of categorical types, i.e. types
--   which describe an inherent potential for being evaluated in parallel.
--   Skeletons are patterns from this layer. When skeletons take as
--   arguments entities from the MoC layer (i.e. processes), the results
--   themselves are parallel process networks which describe systems with
--   an inherent potential to be implemented on parallel platforms. All
--   skeletons can be described as composition of the three atoms below
--   (<a>=&lt;&lt;=</a> being just a specific instantiation of <a>=\=</a>).
--   This possible due to an existing theorem in the categorical type
--   theory, also called the Bird-Merteens formalism <a>[Bird97]</a>:
--   
--   
--   <ul>
--   <li><i>factorization</i> A function on a categorical type is an
--   algorithmic skeleton (i.e. catamorphism) <i>iff</i> it can be
--   represented in a factorized form, i.e. as a <i>map</i> composed with a
--   <i>reduce</i>.</li>
--   </ul>
--   
--   Consequently, most of the skeletons for the implemented categorical
--   types are described in their factorized form, taking as arguments
--   either:
--   
--   <ul>
--   <li>type constructors or functions derived from type constructors</li>
--   <li>processes, i.e. MoC layer entities</li>
--   </ul>
--   
--   Most of the ground-work on algorithmic skeletons on which this module
--   is founded has been laid in <a>[Bird97]</a>, <a>[Skillicorn05]</a> and
--   it founds many of the frameworks collected in <a>[Gorlatch03]</a>.
class Functor c => Skeleton c

-- | Atom which maps a function on each element of a structure (i.e.
--   categorical type), defined as:
--   
--   
--   <a>=.=</a> together with <a>=*=</a> form the <tt>map</tt> pattern.
(=.=) :: Skeleton c => (a -> b) -> c a -> c b

-- | Atom which applies the functions contained by as structure (i.e.
--   categorical type), on the elements of another structure, defined as:
--   
--   
--   <a>=.=</a> together with <a>=*=</a> form the <tt>map</tt> pattern.
(=*=) :: Skeleton c => c (a -> b) -> c a -> c b

-- | Atom which reduces a structure to an element based on an
--   <i>associative</i> function, defined as:
--   
(=\=) :: Skeleton c => (a -> a -> a) -> c a -> a

-- | Skeleton which <i>pipes</i> an element through all the functions
--   contained by a structure.
--   
--   <b>N.B.</b>: this is not an atom. It has an implicit definition which
--   might be augmented by instances of this class to include edge cases.
--   
--   
--   As the composition operation is not associative, we cannot treat
--   <tt>pipe</tt> as a true reduction. Alas, it can still be exploited in
--   parallel since it exposes another type of parallelism: time
--   parallelism.
(=<<=) :: Skeleton c => c (a -> a) -> a -> a

-- | Returns the first element in a structure.
--   
--   <b>N.B.</b>: this is not an atom. It has an implicit definition which
--   might be replaced by instances of this class with a more efficient
--   implementation.
--   
first :: Skeleton c => c a -> a

-- | Returns the last element in a structure.
--   
--   <b>N.B.</b>: this is not an atom. It has an implicit definition which
--   might be replaced by instances of this class with a more efficient
--   implementation.
--   
last :: Skeleton c => c a -> a

-- | This set of utility functions "unzip" nested n-tuples, provided as
--   postfix operators. They are crucial for reconstructing data types from
--   higher-order functions which input functions with multiple outputs. It
--   relies on the nested types being instances of <a>Functor</a>.
--   
--   The operator convention is <tt>(|+&lt;+)</tt>, where the number of
--   <tt>|</tt> represent the number of layers the n-tuple is lifted, while
--   the number of <tt>&lt;</tt> + 1 is the order <i>n</i> of the n-tuple.
--   
--   <a>ForSyDe.Atom.Utility</a> exports the constructors below. Please
--   follow the examples in the source code if they do not suffice:
--   
--   <pre>
--      |&lt;,    |&lt;&lt;,    |&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;&lt;,    |&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,
--     ||&lt;,   ||&lt;&lt;,   ||&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;&lt;,   ||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,
--    |||&lt;,  |||&lt;&lt;,  |||&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;&lt;,  |||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,  
--   ||||&lt;, ||||&lt;&lt;, ||||&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;&lt;, ||||&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;, 
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XPostfixOperators
--   
--   &gt;&gt;&gt; ([Just (1,2,3), Nothing, Just (4,5,6)] ||&lt;&lt;)
--   ([Just 1,Nothing,Just 4],[Just 2,Nothing,Just 5],[Just 3,Nothing,Just 6])
--   </pre>
(||<) :: (Functor f1, Functor f2) => f1 (f2 (a1, a2)) -> (f1 (f2 a1), f1 (f2 a2))
infixl 3 ||<
